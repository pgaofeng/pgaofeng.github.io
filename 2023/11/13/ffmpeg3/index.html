<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>FFmpeg解码音频PCM</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>32</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>15</span> <span>标签</span> </a><a class="author-word-count"><span>12.44</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E8%A7%A3%E7%A0%81%E9%9F%B3%E9%A2%91" class="toc-link"><span class="toc-text">解码音频</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E9%9F%B3%E9%A2%91%E4%BF%A1%E6%81%AF" class="toc-link"><span class="toc-text">音频信息</span></a></li><li class="toc-item toc-level-4"><a href="#%E8%A7%A3%E7%A0%81%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE" class="toc-link"><span class="toc-text">解码音频数据</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" class="toc-link"><span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">10</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="FFmpeg解码音频PCM thumbnail" class="image lozad" src="/img/cover/cover-ffmpeg3.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">FFmpeg解码音频PCM</h1></header><div class="post-meta post-show-meta"><time datetime="2023-11-13T07:04:49.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2023-11-13</span> </time><span class="dot"></span> <a href="/categories/Third-Libraries/" class="post-meta-link">Third Libraries </a><span class="dot"></span> <span>约2.7k 字</span></div><div class="post-content" id="section"><p>我们知道使用<code>FFmpeg</code>解封装就是从音频中不断地读取<code>AVPacket</code>，但读取的<code>packet</code>仍是压缩后的数据，如果我们想要播放，还必须要将其解压成原始的音视频数据才能播放，这个过程就是解码操作。同样，反过来将原始的音视频数据压缩成对应的格式的过程，称为编码过程。</p><h3 id="解码音频"><a href="#解码音频" class="headerlink" title="解码音频"></a>解码音频</h3><p>编解码相关的模块是<code>avcodec</code>模块， 因为音视频数据的压缩格式是不同的，因此当读取到音视频流之后，需要根据流的信息来选择不同的解码器进行解码。音频流解码出来的是<code>PCM</code>数据，视频流解码出来的基本上都是<code>YUV</code>数据，具体是什么数据取决于它的压缩方式。</p><p>解封装后我们拿到的是<code>AVPacket</code>，它代表着一段音频或视频数据，我们通过特定的解码器将其解码，解码后的结果就是<code>AVFrame</code>。注意的是，一个<code>AVPacket</code>解码出来后并不是对应一个<code>AVFrame</code>，尤其是对于视频流的解码。可能一个<code>AVPacket</code>解码出多个<code>AVFrame</code>，也可能一个<code>AVFrame</code>也解不出来。</p><h4 id="音频信息"><a href="#音频信息" class="headerlink" title="音频信息"></a>音频信息</h4><p>音频流数据基本上都是<code>PCM</code>数据，它主要的参数就是采样率和采样精度以及通道数。音频本质上就是一个音波，我们将其模拟成数字信息存储在文件中，而从波到数字的转换就是在波上获取采样点，当采样点足够多的时候，这些采样点就可以组成一个波，从而模拟出声波。采样率就是每秒钟的采样个数，通常采样率为<code>44100Hz</code>，采样率越大，声音模拟的越真实，但同样文件大小也会变大。</p><p>然后就是采样精度，采样精度是用来记录波的高度的，如果将其对应到坐标系中，采样精度就是用什么类型的数字来表示<code>y</code>的大小，通常有<code>8bit</code>、<code>16bit</code>等，采样精度越高，对声音的模拟越真实，同样文件大小也会变大。</p><p>通道数也即是声道数，常用的是双声道的立体音。其中每个声道的数据都是独立的，假如有一个单通道的<code>PCM</code>数据的大小是<code>2M</code>，那么双通道的大小为<code>4M</code>，其实就是相当于两个<code>PCM</code>音频拼接成一个音频这样。<strong>在<code>FFmpeg</code>中</strong>多通道的音频在排列上分为平面模式<code>planar</code>和交错模式<code>Interleaved</code>，其中<code>planar</code>模式就是按顺序存放，先第一通道的数据，再第二通道数据，再第三通道数据，类似于简单的拼接，<code>AAABBBCCC</code>这样存储。而<code>Interleaved</code>模式则是交错模式，每个通道的数据交错在一块，如<code>ABCABCABC</code>这样，这也是实际中的<code>PCM</code>的存储方式。</p><h4 id="解码音频数据"><a href="#解码音频数据" class="headerlink" title="解码音频数据"></a>解码音频数据</h4><p>解码后的被称为<code>AVFrame</code>，解码的数据在其<code>data</code>和<code>extend_data</code>数据中，它们都是一个二维数组，区别就是<code>data</code>是一个固定大小为8的数组，而<code>extend_data</code>的大小不固定。对于视频而言它们基本上是没有区别的，但是对于音频来说就有了区别。</p><p>对于<code>planar</code>模式的音频，它们会按顺序排列，即<code>data[0]</code>代表第一个通道数据，<code>data[1]</code>代表的是第二个通道的数据，如果通道数不超过8那没什么区别，如果超过8则只能使用<code>extend_data</code>了。</p><p>对于<code>Interleaved</code>模式的音频，它们会交错在一起，最终看起来就相当于只有一个通道，因此直接使用<code>data[0]</code>或者<code>extend_data[0]</code>来拿数据就行了。</p><figure class="c highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="c hljs"><span class="hljs-type">void</span> <span class="hljs-title function_">read_audio</span><span class="hljs-params">(AVFrame *frame)</span> &#123;<br>    AVSampleFormat sampleFormat = (AVSampleFormat)frame-&gt;format;<br>    <span class="hljs-type">int</span> dataLength = frame-&gt;nb_samples * av_get_bytes_per_sample(sampleFormat);<br>    fwrite(frame-&gt;data[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint8_t</span>), dataLength, pcmFile);    <br>&#125;<br></code></pre></td></tr></table></figure><p>如上示例，简单点就是计算音频数据的长度，然后将第一通道的音频数据写入到输出文件中，该文件就是<code>PCM</code>文件。注意这里的长度是计算出来的，通过采样个数(<code>nb_samples</code>)乘以每个采样点的大小得到的长度。其实也可以通过<code>frame-&gt;linesize[0]</code>来获取到长度，但是可能因为对齐等问题，导致该长度比实际的数据长度要长，因此这里直接通过计算获取长度。</p><p><code>planar</code>模式是在<code>FFmpeg</code>中的模式，大部分的解码器解出来的都是<code>planar</code>模式，但是实际中的音频却都是<code>Interleaved</code>模式。如果我们只想保存某个通道的音频，那<code>planar</code>模式无疑非常简单，但要想所有通道都保存的话，则需要将解码出来的数据重新交错成<code>Interleaved</code>模式。</p><figure class="c highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="c hljs"><span class="hljs-type">void</span> <span class="hljs-title function_">read_audio</span><span class="hljs-params">(AVFrame *frame)</span> &#123;<br>    AVSampleFormat sampleFormat = (AVSampleFormat)frame-&gt;format;<br>    <span class="hljs-type">int</span> sampleLength =  av_get_bytes_per_sample(sampleFormat);<br>    <span class="hljs-comment">// 交错写入，按顺序每个通道一个采样点一个采样点写入</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> sample = <span class="hljs-number">0</span>; sample &lt; frame-&gt;nb_samples; sample++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> channel = <span class="hljs-number">0</span>; channel &lt; frame-&gt;ch_layout.nb_channels; channel++) &#123;<br>            fwrite(<br>                frame-&gt;extended_data[channel] + sample * sampleLength, <br>                <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint8_t</span>),<br>                sampleLength,<br>                pcmFile<br>            );    <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意只有<code>planar</code>模式下才能交错写入，如果是<code>Interleaved</code>模式，直接写入<code>data[0]</code>即可。放在一起就是这样的：</p><figure class="c highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="c hljs"><span class="hljs-type">void</span> <span class="hljs-title function_">read_audio</span><span class="hljs-params">(AVFrame *frame)</span> &#123;<br>    AVSampleFormat sampleFormat = (AVSampleFormat)frame-&gt;format;<br>    <span class="hljs-type">int</span> sampleLength =  av_get_bytes_per_sample(sampleFormat);<br>    <span class="hljs-type">int</span> sampleCount = frame-&gt;nb_samples;<br><br>    <span class="hljs-keyword">if</span>(av_sample_fmt_is_planar(sampleFormat)) &#123;<br>        <span class="hljs-comment">// planar模式下需要交错写入各组通道音频数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> sample = <span class="hljs-number">0</span>; sample &lt; frame-&gt;nb_samples; sample++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> channel = <span class="hljs-number">0</span>; channel &lt; frame-&gt;ch_layout.nb_channels; channel++) &#123;<br>                fwrite(<br>                    frame-&gt;extended_data[channel] + sample * sampleLength, <br>                    <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint8_t</span>),<br>                    sampleLength,<br>                    pcmFile<br>                );    <br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 非planar模式下，各组通道已经交错在一起，直接保存data[0]即可</span><br>        fwrite(frame-&gt;data[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint8_t</span>), sampleLength * sampleCount, pcmFile); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一点，解码出来的<code>PCM</code>裸数据是很大的，一个<code>10M</code>的<code>MP3</code>文件解出来的<code>PCM</code>数据大约<code>100M</code>，注意自己的存储空间。另外就是<code>PCM</code>裸流是无法直接播放的，因为不清楚视频的参数，如采样率、采样大小等信息，因此可以在运行时打印出这些信息，方便我们测试音频是否导出正常：</p><figure class="c highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="c hljs"><span class="hljs-type">char</span> sampleName[<span class="hljs-number">50</span>];<br>av_get_sample_fmt_string(sampleName, <span class="hljs-number">50</span>, audioCodecContext-&gt;sample_fmt);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sampleRame = %d, sampleFmt = %s, channel = %d\n&quot;</span>,<br>        audioCodecContext-&gt;sample_rate,<br>        sampleName, <br>        audioCodecContext-&gt;ch_layout.nb_channels<br>);<br></code></pre></td></tr></table></figure><p>输出内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sampleRame = 44100, sampleFmt = fltp     32 , channel = 2<br></code></pre></td></tr></table></figure><p>因此，当运行结束后，我们可以根据这些参数来进行播放，我们可以将<code>PCM</code>导出到电脑上用<code>ffplay</code>播放，或者在线进行播放都行。</p><p><code>ffplay</code>命令：<code>ffplay.exe -f f32le -ch_layout stereo -sample_rate 44100 -i audio.pcm</code></p><p>主要注意<code>-f</code>参数，也就是我们打印的<code>sampleFmt</code>参数，该参数为<code>fltp 32</code>，也就是32位的浮点数，所以命令参数为<code>f32le</code>；然后是<code>-ch_layout</code>通道数，单通道输入<code>mono</code>，双通道输入<code>stereo</code>。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="c highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="c hljs"><span class="hljs-comment">// C++中使用必须extern</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libavformat/avformat.h&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libavcodec/avcodec.h&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libavutil/samplefmt.h&quot;</span></span><br>&#125;<br><br>AVFormatContext *inFormatCtx = nullptr;<br>AVPacket *packet = nullptr;<br>AVFrame *frame = nullptr;<br><span class="hljs-type">const</span> AVCodec *audioCodec = nullptr;<br>AVCodecContext *audioCodecContext = nullptr;<br>FILE *pcmFile;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_audio</span><span class="hljs-params">(AVFrame *frame)</span> &#123;<br>    AVSampleFormat sampleFormat = (AVSampleFormat)frame-&gt;format;<br>    <span class="hljs-type">int</span> sampleLength =  av_get_bytes_per_sample(sampleFormat);<br>    <span class="hljs-type">int</span> sampleCount = frame-&gt;nb_samples;<br><br>    <span class="hljs-keyword">if</span>(av_sample_fmt_is_planar(sampleFormat)) &#123;<br>        <span class="hljs-comment">// planar模式下需要交错写入各组通道音频数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> sample = <span class="hljs-number">0</span>; sample &lt; frame-&gt;nb_samples; sample++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> channel = <span class="hljs-number">0</span>; channel &lt; frame-&gt;ch_layout.nb_channels; channel++) &#123;<br>                fwrite(<br>                    frame-&gt;extended_data[channel] + sample * sampleLength, <br>                    <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint8_t</span>),<br>                    sampleLength,<br>                    pcmFile<br>                );    <br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 非planar模式下，各组通道已经交错在一起，直接保存data[0]即可</span><br>        fwrite(frame-&gt;data[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint8_t</span>), sampleLength * sampleCount, pcmFile); <br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span>(inFormatCtx != nullptr) &#123;<br>        avformat_close_input(&amp;inFormatCtx);<br>        inFormatCtx = nullptr;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(packet != nullptr) &#123;<br>        av_packet_free(&amp;packet);<br>        packet = nullptr;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (frame != nullptr) &#123;<br>        av_frame_free(&amp;frame);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pcmFile != nullptr) &#123;<br>        fclose(pcmFile);<br>        pcmFile = nullptr;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">convert</span><span class="hljs-params">(<span class="hljs-type">char</span>* inputFile, <span class="hljs-type">char</span>* outputFile)</span> &#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-comment">// 打开输入文件</span><br>    ret = avformat_open_input(&amp;inFormatCtx, inputFile, nullptr, nullptr);<br>    <span class="hljs-keyword">if</span>(ret) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error in open stream&quot;</span>);<br>        <span class="hljs-built_in">free</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 打开输出文件</span><br>    pcmFile = fopen(outputFile, <span class="hljs-string">&quot;wb&quot;</span>);<br>    <span class="hljs-comment">// 查找流</span><br>    ret = avformat_find_stream_info(inFormatCtx, nullptr);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find stream error&quot;</span>);<br>        <span class="hljs-built_in">free</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 音频流的index</span><br>    <span class="hljs-type">int</span> streamIndex = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inFormatCtx-&gt;nb_streams; i++) &#123;<br>        AVStream *stream = inFormatCtx-&gt;streams[i];<br>        <span class="hljs-keyword">if</span>(stream-&gt;codecpar-&gt;codec_type != AVMEDIA_TYPE_AUDIO) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 查找到音频流之后，加载解码器，创建解码器上下文，打开加码器</span><br>        streamIndex = i;<br>        audioCodec = avcodec_find_decoder(stream-&gt;codecpar-&gt;codec_id);<br>        audioCodecContext = avcodec_alloc_context3(audioCodec);<br>        avcodec_parameters_to_context(audioCodecContext, stream-&gt;codecpar);<br>        avcodec_open2(audioCodecContext, audioCodec, nullptr);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(audioCodec == nullptr || audioCodecContext == nullptr) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cannot find audioCodec\n&quot;</span>);<br>        <span class="hljs-built_in">free</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出音频的基本信息，方便后续播放解码出来的pcm</span><br>    <span class="hljs-type">char</span> sampleName[<span class="hljs-number">50</span>];<br>    av_get_sample_fmt_string(sampleName, <span class="hljs-number">50</span>, audioCodecContext-&gt;sample_fmt);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sampleRame = %d, sampleFmt = %s, channel = %d\n&quot;</span>,<br>        audioCodecContext-&gt;sample_rate,<br>            sampleName, <br>            audioCodecContext-&gt;ch_layout.nb_channels<br>        );<br>    <span class="hljs-comment">// 开始解码</span><br>    packet = av_packet_alloc();<br>    frame = av_frame_alloc();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 读一个packet</span><br>        ret = av_read_frame(inFormatCtx, packet);<br>        <span class="hljs-keyword">if</span>(ret) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;end of file\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 只读音频流，清空packet</span><br>        <span class="hljs-keyword">if</span> (packet-&gt;stream_index != streamIndex) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;other packet, ignore\n&quot;</span>);<br>            av_packet_unref(packet);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 把packet发给解码器</span><br>        avcodec_send_packet(audioCodecContext, packet);<br>        <span class="hljs-comment">// 从解码器读取解出来的帧</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            ret = avcodec_receive_frame(audioCodecContext, frame);<br>            <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;    <br>            &#125;<br>            <span class="hljs-comment">// 保存音频帧</span><br>            read_audio(frame);<br>            av_frame_unref(frame);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 读不到packet之后，还需要再次解码，避免丢掉最后几帧，参数传null</span><br>    avcodec_send_packet(audioCodecContext, nullptr);<br>    <span class="hljs-comment">// 解码出frame</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ret = avcodec_receive_frame(audioCodecContext, frame);<br>        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;    <br>        &#125; <br>        read_audio(frame);<br>        av_frame_unref(frame);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;finish\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码逻辑很清晰，还是一样的流程。先打开音视频文件，然后查找流，加载对应的解码器，读<code>packet</code>，将<code>packet</code>发给解码器，从解码器中读解码后的数据<code>frame</code>，将<code>frame</code>中的<code>pcm</code>写入本地。</p><p>然后就是在<code>jni</code>中使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">JNIEXPORT <span class="hljs-type">void</span> JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_example_ffmpegdemo_MainActivity_convert</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">        jobject <span class="hljs-comment">/* this */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        jstring input,</span></span><br><span class="hljs-params"><span class="hljs-function">        jstring output)</span> </span>&#123;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* in = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(input, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* out = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(output, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">convert</span>(in, out);<br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(input, in);<br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(output, out);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>MainActivity</code>中使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">binding.button.setOnClickListener &#123;<br>    <span class="hljs-comment">// 耗时操作，在子线程调用</span><br>    thread &#123;<br>        <span class="hljs-comment">// data/data/com.example.ffmpegdemo/files/cache/1.mkv</span><br>        <span class="hljs-keyword">val</span> inputFile = File(cacheDir, <span class="hljs-string">&quot;1.mkv&quot;</span>)<br>        <span class="hljs-comment">// 同目录下会生成2.pcm</span><br>        <span class="hljs-keyword">val</span> outputFile = File(cacheDir, <span class="hljs-string">&quot;2.pcm&quot;</span>)<br>        convert(inputFile.absolutePath, outputFile.absolutePath)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意这里的<code>input</code>文件，可以是视频文件，也可以是音频文件。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前面是解码音频的逻辑，主要就是在打开文件后查询流信息，然后这里我们只关注了音频的信息，即只创建了音频的解码器和解码器上下文，后面的逻辑就是不断的读<code>packet</code>然后发送给解码器，然后再从解码器中读取解码后的<code>frame</code>。如果我们在查询流信息后也创建了对应的视频解码器和解码器上下文，那么我们就可以将属于音频的<code>packet</code>发送给音频解码器，将属于视频的<code>packet</code>发送给视频解码器，最终各自处理解码后的<code>frame</code>即可。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Mon Nov 13 2023 15:04:49 GMT+0800");let n="Mon Nov 13 2023 15:04:49 GMT+0800";n="2025-03-26 17:33:27 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Third-Libraries/" class="post-footer-category">#&nbsp;Third Libraries</a> <a href="/tags/FFmpeg/" class="post-footer-tag">#&nbsp;FFmpeg</a></div><div class="nav"><div class="nav-item-prev"><a href="/2023/12/20/ffmpeg4/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">FFmpeg解码视频YUV</div></div></a></div><div class="nav-item-next"><a href="/2023/10/05/ffmpeg2/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">FFmpeg解封装与重封装</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E8%A7%A3%E7%A0%81%E9%9F%B3%E9%A2%91" class="toc-link"><span class="toc-text">解码音频</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E9%9F%B3%E9%A2%91%E4%BF%A1%E6%81%AF" class="toc-link"><span class="toc-text">音频信息</span></a></li><li class="toc-item toc-level-4"><a href="#%E8%A7%A3%E7%A0%81%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE" class="toc-link"><span class="toc-text">解码音频数据</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" class="toc-link"><span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-10-05</div><a href="/2023/10/05/ffmpeg2/"><div class="recent-posts-item-content">FFmpeg解封装与重封装</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-09-06</div><a href="/2023/09/06/ffmpeg1/"><div class="recent-posts-item-content">FFmpeg编译so库文件</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-10-12</div><a href="/2021/10/12/bsdiff-translation/"><div class="recent-posts-item-content">【翻译】Naive Differences of Executable Code</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-09-06</div><a href="/2021/09/06/use-bsdiff-to-ugrade/"><div class="recent-posts-item-content">在Android中使用Bsdiff实现增量更新</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-10-05</div><a href="/2023/10/05/ffmpeg2/"><div class="recent-posts-item-content">FFmpeg解封装与重封装</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-09-06</div><a href="/2023/09/06/ffmpeg1/"><div class="recent-posts-item-content">FFmpeg编译so库文件</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>