<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Kotlin协程的实现</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>33</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>15</span> <span>标签</span> </a><a class="author-word-count"><span>12.83</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#Continuation" class="toc-link"><span class="toc-text">Continuation</span></a></li><li class="toc-item toc-level-3"><a href="#suspend%E5%85%B3%E9%94%AE%E5%AD%97" class="toc-link"><span class="toc-text">suspend关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E5%88%9D%E5%A7%8B%E5%90%AF%E5%8A%A8" class="toc-link"><span class="toc-text">初始启动</span></a></li></ol></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Kotlin协程的实现 thumbnail" class="lozad image" src="/img/cover/cover-coroutine-1.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Kotlin协程的实现</h1></header><div class="post-meta post-show-meta"><time datetime="2023-07-11T11:20:27.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2023-07-11</span> </time><span class="dot"></span> <a href="/categories/Kotlin/" class="post-meta-link">Kotlin </a><span class="dot"></span> <span>约2.3k 字</span></div><div class="post-content" id="section"><p>我们了解过协程的使用，通过<code>launch</code>和<code>async</code>创建协程，也知道协程是个挂起恢复的框架。我们可以简单理解它是一个线程调度框架，可以方便切换线程，但这只是它的一种使用方式，它最重要的是代码块的挂起与恢复。它不仅可以在线程之间进行挂起恢复来达到切换线程的目的，甚至可以在同一个线程中将一块块的代码块进行挂起与恢复。本文就是分析它是如何做到这一点的。</p><h3 id="Continuation"><a href="#Continuation" class="headerlink" title="Continuation"></a>Continuation</h3><p>我们从最简单的启动协程来看，即<code>scope.launch</code>启动的协程：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span><br><span class="hljs-params"><span class="hljs-function">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)<br>    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)<br>        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span><br>        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)<br>    coroutine.start(start, coroutine, block)<br>    <span class="hljs-keyword">return</span> coroutine<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是启动的源码，可以看到<code>launch</code>的作用就是创建了一个<code>StandaloneCoroutine</code>，然后通过<code>start</code>方法进行启动。而它是协程的一个具体实例，我们继续追踪可以看到它是继承自<code>AbstractCoroutine</code>的。但最终它实现了很多的接口，我们并不知道谁才是协程的最顶层定义，因此继续往下看：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCoroutine</span>&lt;<span class="hljs-type">in T</span>&gt;(<br>    parentContext: CoroutineContext,<br>    initParentJob: <span class="hljs-built_in">Boolean</span>,<br>    active: <span class="hljs-built_in">Boolean</span><br>) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope &#123;<br>    ...<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">start</span><span class="hljs-params">(start: <span class="hljs-type">CoroutineStart</span>, receiver: <span class="hljs-type">R</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>)</span></span> &#123;<br>        start(block, receiver, <span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>即最终实现是直接调用了<code>CoroutineStart</code>的方法，该参数是在<code>launch</code>启动时传递进去的，它表示的是协程的启动时机，有多个枚举值。这里我们没有直接传递参数，而是使用的默认值<code>CoroutineStart.DEFAULT</code>，继续追踪进入：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineStart</span> &#123;<br>    ...<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">invoke</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>, receiver: <span class="hljs-type">R</span>, completion: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Unit</span> =<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>            DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)<br>            ATOMIC -&gt; block.startCoroutine(receiver, completion)<br>            UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)<br>            LAZY -&gt; <span class="hljs-built_in">Unit</span> <span class="hljs-comment">// will start lazily</span><br>        &#125;<br>&#125;<br><br><span class="hljs-comment">// suspend代码块的拓展函数</span><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> (R)</span></span> -&gt; T).startCoroutineCancellable(<br>    receiver: R, completion: Continuation&lt;T&gt;,<br>    onCancellation: ((cause: Throwable) -&gt; <span class="hljs-built_in">Unit</span>)? = <span class="hljs-literal">null</span><br>) =<br>    runSafely(completion) &#123;<br>        createCoroutineUnintercepted(receiver, completion).intercepted().resumeCancellableWith(Result.success(<span class="hljs-built_in">Unit</span>), onCancellation)<br>    &#125;<br><br><span class="hljs-comment">// Continuation的拓展函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resumeCancellableWith</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    onCancellation: ((<span class="hljs-type">cause</span>: <span class="hljs-type">Throwable</span>) -&gt; <span class="hljs-type">Unit</span>)? = <span class="hljs-literal">null</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: <span class="hljs-built_in">Unit</span> = <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">is</span> DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)<br>    <span class="hljs-keyword">else</span> -&gt; resumeWith(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>所以最终走到的是<code>Continuation.resumeWith</code>方法去启动的协程，从这里也能看到，协程的具体定义实际上就是<code>Continuation</code>接口，我们从这个接口文件中的注释也可以看到它就代表着协程。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Continuation</span>&lt;<span class="hljs-type">in T</span>&gt; &#123;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>它有一个参数以及一个方法，其中参数表示的是协程的上下文，前面文章<a href="https://pgaofeng.github.io/2023/04/29/coroutine-context/" rel="noopener" target="_blank">协程上下文CoroutineContext</a>我们看过其结构实体，其本身就可以代表一组上下文集合，通过<code>Key</code>进行区分。然后就是<code>resumeWith</code>方法，该方法启动该协程。也就是说，实际上我们启动协程就是先创建一个<code>Continuation</code>然后再通过<code>resumeWith</code>启动即可。</p><p>那么我们不用给定的启动协程的接口，像它这样通过<code>suspend</code>来启动协程如何：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">suspend</span> &#123;<br>    log(<span class="hljs-string">&quot;协程体内容&quot;</span>)<br>    delay(<span class="hljs-number">100</span>)<br>    <span class="hljs-comment">// 协程的返回值为10</span><br>    <span class="hljs-number">10</span><br>&#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br>        <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span> &#123;<br>        log(<span class="hljs-string">&quot;resumeWith <span class="hljs-subst">$&#123;result.getOrNull()&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;)<br><br>-------------<br>D  协程体内容<br>D  resumeWith <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="suspend关键字"><a href="#suspend关键字" class="headerlink" title="suspend关键字"></a>suspend关键字</h3><p>我们知道，协程所执行的代码块或者方法必须是被<code>suspend</code>修饰的，该关键字代表着可挂起，因此被修饰的方法或代码块才能在协程中执行。但是，<code>Kotlin</code>是运行在<code>JVM</code>上的，而<code>JVM</code>是没有该关键字的，所以在编译成字节码时，<code>suspend</code>发生了什么？</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">other</span><span class="hljs-params">()</span></span> &#123;&#125;<br><br><span class="hljs-comment">// 编译之后再反编成Java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object other(Continuation $completion) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Unit</span>.INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个普通的<code>suspend</code>函数，我们看到编译器在编译这个方法的时候，给他加了一个<code>Continuation</code>参数，并将返回值改成了<code>Object</code>。经过我们前面的分析知道，<code>Continuation</code>就是协程的本体，它调用<code>suspend</code>方法的时候将本身传入了。这里因为我们定义的<code>suspend</code>方法是一个空实现，因此实际的实现中并没有用到<code>Continuation</code>，但我们根据此可以猜到，它就类似一个回调。</p><p>当我们在一个协程中执行一些操作，然后调用某个可挂起函数时，就将本身<code>Continuation</code>传递给了那个可挂起函数，当那个函数执行完之后，通过<code>continuation.resumeWith</code>再回到原协程体中。我们重新定义一个可挂起函数，让它进行挂起操作：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">other</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;挂起前&quot;</span>)<br>    delay(<span class="hljs-number">100</span>)<br>    println(<span class="hljs-string">&quot;挂起后&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后编译之后再反编成<code>Java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">other</span><span class="hljs-params">(Continuation $completion)</span> &#123;<br>   Continuation $continuation;<br>   label20: &#123;<br>      <span class="hljs-comment">// 判断是否是当前的内部类，也就是下面的ContinuationImpl</span><br>      <span class="hljs-keyword">if</span> ($completion <span class="hljs-keyword">instanceof</span> MainActivity$other$<span class="hljs-number">1</span>) &#123;<br>         <span class="hljs-comment">// 是的话，说明该方法不是第一次调用了，重新获取下当前的最新label</span><br>         $continuation = (MainActivity$other$<span class="hljs-number">1</span>)$completion;<br>         <span class="hljs-keyword">if</span> (($continuation.label &amp; Integer.MIN_VALUE) != <span class="hljs-number">0</span>) &#123;<br>            $continuation.label -= Integer.MIN_VALUE;<br>            <span class="hljs-keyword">break</span> label20;<br>         &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 这里说明是第一次调用other方法，创建一个内部类，代表一个新的可挂起块</span><br>      $continuation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContinuationImpl</span>($completion) &#123;<br>         <span class="hljs-comment">// $FF: synthetic field</span><br>         Object result;<br>         <span class="hljs-type">int</span> label;<br><br>         <span class="hljs-meta">@Nullable</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object $result)</span> &#123;<br>            <span class="hljs-built_in">this</span>.result = $result;<br>            <span class="hljs-built_in">this</span>.label |= Integer.MIN_VALUE;<br>            <span class="hljs-comment">// 再次走到other方法中</span><br>            <span class="hljs-keyword">return</span> MainActivityKt.other((Continuation)<span class="hljs-built_in">this</span>);<br>         &#125;<br>      &#125;;<br>   &#125;<br><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">$result</span> <span class="hljs-operator">=</span> $continuation.result;<br>   <span class="hljs-comment">// 该值是一个常量COROUTINE_SUSPENDED，代表当前协程正在挂起</span><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();<br>   <span class="hljs-keyword">switch</span> ($continuation.label) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>         ResultKt.throwOnFailure($result);<br>         <span class="hljs-comment">// 输出挂起前内容</span><br>         <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;挂起前&quot;</span>;<br>         System.out.println(var1);<br>         <span class="hljs-comment">// 将label指向下一个值</span><br>         $continuation.label = <span class="hljs-number">1</span>;<br>         <span class="hljs-comment">// 进入到另一个可挂起方法中，将当前内部类传递进去</span><br>         <span class="hljs-keyword">if</span> (DelayKt.delay(<span class="hljs-number">100L</span>, $continuation) == var4) &#123;<br>             <span class="hljs-comment">// delay会返回COROUTINE_SUSPENDED，我们也直接返回COROUTINE_SUSPENDED</span><br>             <span class="hljs-keyword">return</span> var4;<br>         &#125;<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>         ResultKt.throwOnFailure($result);<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);<br>   &#125;<br>   <span class="hljs-comment">// 当delay延迟100毫秒后，会再次调用我们的$continuation.invokeWith，然后</span><br>   <span class="hljs-comment">// 我们会回到other方法中走到这里</span><br>   <span class="hljs-type">String</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;挂起后&quot;</span>;<br>   System.out.println(var5);<br>   <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们分析这段代码，可以看到协程的本质就是状态机+回调。这也是为什么<code>suspend</code>必须在协程代码块中执行，因为它需要一个<code>Continuation</code>参数，使用该参数回到原来的协程中。</p><p>因此，协程的启动必须从手动创建一个<code>Continuation</code>开始，然后这个初始<code>Continuation</code>开始调用某个<code>suspend</code>方法，然后将自身传入到这个<code>suspend</code>方法中。然后这个<code>suspend</code>如果内部有挂起点的话，就会把自己编译成一个内部类<code>ContinuationImpl</code>，然后按照挂起点将原本方法的代码分成多个块，每个块放在对应的<code>switch</code>语句中，通过<code>label</code>进行区分。</p><p>上面的代码我们看的是一个<code>suspend</code>方法，实际上<code>suspend</code>代码块编译后也是一样的。</p><h4 id="初始启动"><a href="#初始启动" class="headerlink" title="初始启动"></a>初始启动</h4><p>再次回到我们最开始的启动协程的代码块中，然后一路追踪它是如何开启协程的：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 我们启动一个协程的方式</span><br><span class="hljs-keyword">suspend</span> &#123;<br>    ...<br>&#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br>        <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span> &#123;<br>        log(<span class="hljs-string">&quot;resumeWith <span class="hljs-subst">$&#123;result.getOrNull()&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 拓展方法通过创建Continuation然后再resume启动</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(<br>    completion: Continuation&lt;T&gt;<br>) &#123;<br>    createCoroutineUnintercepted(completion).intercepted().resume(<span class="hljs-built_in">Unit</span>)<br>&#125;<br><br><span class="hljs-comment">// 创建协程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-comment">// 该方法实际就是直接返回completion</span><br>    <span class="hljs-keyword">val</span> probeCompletion = probeCoroutineCreated(completion)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> BaseContinuationImpl)<br>        create(probeCompletion)<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 我们最终会走到这里</span><br>        createCoroutineFromSuspendFunction(probeCompletion) &#123;<br>            (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终是通过<code>createCoroutineFromSuspendFunction</code>方法创建协程的，该方法接收两个参数，第一个参数是<code>probeCompletion</code>也就是我们在<code>startCoroutine</code>是传入的一个匿名内部类；第二个参数是一个表达式，表达式中直接执行了<code>this</code>，也就是我们最开始的<code>suspend</code>代码块。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">createCoroutineFromSuspendFunction</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    completion: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Any</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">val</span> context = completion.context<br>    <span class="hljs-comment">// 我们startCoroutine的时候创建的Continuation的context就是个空上下文，因此走到这个逻辑</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (context === EmptyCoroutineContext)<br>        <span class="hljs-comment">// 又创建了一个Continuation</span><br>        <span class="hljs-keyword">object</span> : RestrictedContinuationImpl(completion <span class="hljs-keyword">as</span> Continuation&lt;Any?&gt;) &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> label = <span class="hljs-number">0</span><br><br>            <span class="hljs-comment">// 我们调用resumeWith开始协程，最终会走到这个方法中</span><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span>: Any? =<br>                <span class="hljs-keyword">when</span> (label) &#123;<br>                    <span class="hljs-number">0</span> -&gt; &#123;<br>                        <span class="hljs-comment">// 将label指向下一块</span><br>                        label = <span class="hljs-number">1</span><br>                        result.getOrThrow() <br>                        <span class="hljs-comment">// 执行代码块，并传入了自身Continuation，该代码块会执行suspend方法</span><br>                        block(<span class="hljs-keyword">this</span>) <br>                    &#125;<br>                    <span class="hljs-number">1</span> -&gt; &#123;<br>                        label = <span class="hljs-number">2</span><br>                        result.getOrThrow()<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;This coroutine had already completed&quot;</span>)<br>                &#125;<br>        &#125;<br>    <span class="hljs-keyword">else</span><br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在启动的协程中，我们又去创建了一个<code>Continuation</code>，然后它也是一个状态机，由它去调用<code>suspend</code>方法，最终走到了各种的回调中去。</p><p><img alt="image-start-coroutine" class="lozad post-image" src="/img/img-start-coroutine.svg" data-src="/img/img-start-coroutine.svg" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Tue Jul 11 2023 19:20:27 GMT+0800");let n="Tue Jul 11 2023 19:20:27 GMT+0800";n="2025-03-05 17:25:13 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Kotlin/" class="post-footer-category">#&nbsp;Kotlin</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" class="post-footer-tag">#&nbsp;协程</a> <a href="/tags/Kotlin/" class="post-footer-tag">#&nbsp;Kotlin</a></div><div class="nav"><div class="nav-item-prev"><a href="/2023/08/27/overscroll/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">View自定义回弹动效</div></div></a></div><div class="nav-item-next"><a href="/2023/06/05/flow-2/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">SharedFlow、StateFlow、SafeFlow的区别</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#Continuation" class="toc-link"><span class="toc-text">Continuation</span></a></li><li class="toc-item toc-level-3"><a href="#suspend%E5%85%B3%E9%94%AE%E5%AD%97" class="toc-link"><span class="toc-text">suspend关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E5%88%9D%E5%A7%8B%E5%90%AF%E5%8A%A8" class="toc-link"><span class="toc-text">初始启动</span></a></li></ol></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-06-05</div><a href="/2023/06/05/flow-2/"><div class="recent-posts-item-content">SharedFlow、StateFlow、SafeFlow的区别</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-05-22</div><a href="/2023/05/22/flow/"><div class="recent-posts-item-content">协程数据流Flow</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-04-29</div><a href="/2023/04/29/coroutine-context/"><div class="recent-posts-item-content">协程上下文CoroutineContext</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-03-15</div><a href="/2023/03/15/coroutine-1/"><div class="recent-posts-item-content">Kotlin协程的使用</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-02-24</div><a href="/2023/02/24/kotlin-note/"><div class="recent-posts-item-content">Kotlin使用笔记</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-01-02</div><a href="/2024/01/02/navigation/"><div class="recent-posts-item-content">在Compose中使用Navigation</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-10-05</div><a href="/2023/10/05/ffmpeg2/"><div class="recent-posts-item-content">FFmpeg解封装与重封装</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>