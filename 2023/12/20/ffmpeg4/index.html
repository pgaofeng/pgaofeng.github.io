<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>FFmpeg解码视频YUV</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>34</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>5</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>16</span> <span>标签</span> </a><a class="author-word-count"><span>13.07</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91" class="toc-link"><span class="toc-text">解码视频</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE" class="toc-link"><span class="toc-text">解码视频数据</span></a></li><li class="toc-item toc-level-4"><a href="#%E8%BD%AC%E6%88%90RGB" class="toc-link"><span class="toc-text">转成RGB</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%86%99%E5%85%A5" class="toc-link"><span class="toc-text">写入</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" class="toc-link"><span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">1</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="FFmpeg解码视频YUV thumbnail" class="image lozad" src="/img/cover/cover-ffmpeg4.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">FFmpeg解码视频YUV</h1></header><div class="post-meta post-show-meta"><time datetime="2023-12-20T13:13:03.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2023-12-20</span> </time><span class="dot"></span> <a href="/categories/Third-Libraries/" class="post-meta-link">Third Libraries </a><span class="dot"></span> <span>约2.8k 字</span></div><div class="post-content" id="section"><p>一个视频文件通常包含两个数据流，一个是音频流，一个是视频流，我们解封装就是为了拿到这两个流。但是这两个流通常都是经过高度压缩后的数据，如果我们想要将其播放出来，就需要对数据流进行解压缩，即解码。</p><h3 id="解码视频"><a href="#解码视频" class="headerlink" title="解码视频"></a>解码视频</h3><p>在<code>FFmpeg</code>中，将音频和视频视作同一类数据，解码流程都是一样的。先直接读一段<code>AVPacket</code>，然后交个各自的解码器去解码，解码后的原始数据在<code>AVFrame</code>中。音频比较简单，解码后的数据就是<code>PCM</code>数据，唯一需要注意的就是多通道音频的排列模式是否是<code>planar</code>模式，如果是的话需要将其重新交错成<code>interleaved</code>模式的数据。</p><p>但视频不同，视频解码后的数据主要分为两类，一类是<code>YUV</code>数据，一类是<code>RGB</code>数据。其中<code>YUV</code>数据中根据<code>U</code>和<code>V</code>分量的大小又分为<code>YUV420</code>、<code>YUV422</code>、<code>YUV444</code>等，然后又根据其各个分量之间的排列方式又分为<code>YUV420p</code>、<code>YUV420sp</code>等，总之就是将三个分量各种排列就成了各种数据格式。<code>RGB</code>也没好到哪里去，首先根据是否有透明度通道分为<code>RGB</code>和<code>ARGB</code>，然后就是各种排列这几个颜色分成<code>RGBA</code>、<code>ABGR</code>、<code>ARGB</code>等等。</p><p>因此，当我们解码视频后，拿到的原始数据可能是各种格式的，而我们要做的就是将其转换成我们想要播放的格式。目前市面上使用最广的编码方式都是<code>H264</code>编码，而其原始数据为<code>YUV420P</code>格式，但在<code>FFmpeg</code>中没有区分<code>YUV420P</code>的子类，即图像是<code>YV12</code>还是<code>YU12</code>？而是只有一个<code>AV_PIX_FMT_YUV420P</code>的格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">YYYYYYYY<br>YYYYYYYY<br>YYYYYYYY<br>YYYYYYYY<br>UUUUUUUU<br>VVVVVVVV<br></code></pre></td></tr></table></figure><p>以上是<code>YUV420P</code>中的<code>YU12</code>的排列方式，即按顺序排列<code>Y</code>、<code>U</code>、<code>V</code>分量，其中<code>U</code>和<code>V</code>分量是<code>Y</code>分量的<code>1/4</code>。</p><p>音频流数据基本上都是<code>PCM</code>数据，它主要的参数就是采样率和采样精度以及通道数。音频本质上就是一个音波，我们将其模拟成数字信息存储在文件中，而从波到数字的转换就是在波上获取采样点，当采样点足够多的时候，这些采样点就可以组成一个波，从而模拟出声波。采样率就是每秒钟的采样个数，通常采样率为<code>44100Hz</code>，采样率越大，声音模拟的越真实，但同样文件大小也会变大。</p><p>然后就是采样精度，采样精度是用来记录波的高度的，如果将其对应到坐标系中，采样精度就是用什么类型的数字来表示<code>y</code>的大小，通常有<code>8bit</code>、<code>16bit</code>等，采样精度越高，对声音的模拟越真实，同样文件大小也会变大。</p><h4 id="解码视频数据"><a href="#解码视频数据" class="headerlink" title="解码视频数据"></a>解码视频数据</h4><p><code>FFmpeg</code>解码后的数据结构为<code>AVFrame</code>，解码的数据在其<code>data</code>和<code>extend_data</code>二维数组中，区别就是<code>data</code>是一个固定大小为8的数组，而<code>extend_data</code>的大小不固定。它们前8个元素指针指向的是相同的，而超过8个后只能通过<code>extend_data</code>来获取数据，因此用哪个数组取数据都是可以的，最通用的方式就是直接用<code>extend_data</code>而不用<code>data</code>。</p><p>对于音频数据我们可以通过采样点的个数和每个采样点的大小来计算数据长度，而对于视频数据，则需要通过<code>width</code>和<code>height</code>属性来计算宽高。注意不要直接使用<code>linesize</code>，因为对其问题可能会导致通过<code>linesize</code>获取的数据长度比原始数据长度要长。</p><figure class="c highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="c hljs"><span class="hljs-type">void</span> <span class="hljs-title function_">read_video</span><span class="hljs-params">(AVFrame *frame)</span> &#123;<br>    <span class="hljs-comment">//YUV420P格式, Y分量大小为宽乘高，U和V分量的大小一样，等于Y的1/4</span><br><br>    <span class="hljs-type">int</span> yLinesize = frame-&gt;linesize[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> uLinesize = frame-&gt;linesize[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> vLinesize = frame-&gt;linesize[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// 写入Y数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; frame-&gt;height; i++) &#123;<br>        fwrite(<br>            frame-&gt;data[<span class="hljs-number">0</span>] + yLinesize * i,<br>            <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint8_t</span>),<br>            frame-&gt;width,<br>            yFile<br>        );<br>    &#125;<br>    <span class="hljs-comment">// 写入U分量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; frame-&gt;height / <span class="hljs-number">2</span>; i++) &#123;<br>        fwrite(<br>            frame-&gt;data[<span class="hljs-number">1</span>] + uLinesize * i,<br>            <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint8_t</span>),<br>            frame-&gt;width / <span class="hljs-number">2</span>,<br>            uFile<br>        );<br>    &#125;<br>    <span class="hljs-comment">// 写入v分量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; frame-&gt;height / <span class="hljs-number">2</span>; i++) &#123;<br>        fwrite(<br>            frame-&gt;data[<span class="hljs-number">2</span>] + vLinesize * i,<br>            <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint8_t</span>),<br>            frame-&gt;width / <span class="hljs-number">2</span>,<br>            vFile<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上示例，<code>YUV</code>数据分别存储在<code>data</code>的三个数组中，直接将其拷贝出来即可。<strong>注意不能一次直接读完</strong>，每个分量我们可以将其理解成一个图片，然后将其每一行连起来形成一个数据，这个数据就是<code>data[0]</code>。但因为对齐问题，图片可能大小是<code>1023*1024</code>，而在<code>FFmpeg</code>中解码后就变成了<code>1024*1024</code>，所以在<code>data[0]</code>中会出现冗余数据，我们读取数据的时候就需要将这个冗余数据剔除出去。这也就是为什么每次读取的长度为<code>width</code>，但偏移量却是<code>linesize[0]</code>。</p><p>通过以上代码我们就可以直接将视频解码并保存各自的分量了，但是，注意这段代码千万不能在手机上运行，因为解码后的<code>YUV</code>数据是非常庞大的，一个<code>1g</code>的<code>mp4</code>文件解出来可能会占用<code>100g</code>的存储空间，手机基本上是存不下的。</p><h4 id="转成RGB"><a href="#转成RGB" class="headerlink" title="转成RGB"></a>转成RGB</h4><p>我们解码视频肯定是为了在手机中播放，而播放我们又通常会选用<code>SurfaceView</code>，因此我们需要将数据的<code>YUV</code>格式转换成<code>RGB</code>格式。当然我们可以自己手动转换，但是注意需要了解各种<code>YUV</code>格式，然后分别获取到各个分量进行转换，这肯定是很麻烦的。好在<code>FFmpeg</code>为我们准备好了对应的方法，使得我们直接可以进行转换，而无需了解各种<code>YUV</code>格式。</p><figure class="c highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="c hljs">   <span class="hljs-comment">// 拿到解码后的帧</span><br>   AVFrame* firstFrame = decodeVideoFirstFrame(file);<br>   SwsContext *swsContext = sws_getContext(<br>           <span class="hljs-comment">// 原始数据的宽高和格式</span><br>           firstFrame-&gt;width, firstFrame-&gt;height, (AVPixelFormat)firstFrame-&gt;format,<br>           <span class="hljs-comment">// 目标数据的宽高和格式</span><br>           targetWidth, targetHeight, AV_PIX_FMT_RGBA,<br>           SWS_BICUBIC, nullptr, nullptr, nullptr<br>   );<br>   <span class="hljs-comment">// 申请一个frame并设置data</span><br>   AVFrame *rgbFrame = av_frame_alloc();<br>   <span class="hljs-type">uint8_t</span> *buffer = (<span class="hljs-type">uint8_t</span>*)av_malloc(<br>           av_image_get_buffer_size(AV_PIX_FMT_RGBA, targetWidth, targetHeight, <span class="hljs-number">1</span>)<br>   );<br>   av_image_fill_arrays(<br>           rgbFrame-&gt;data, rgbFrame-&gt;linesize, buffer, AV_PIX_FMT_RGB24,<br>           targetWidth, targetHeight, <span class="hljs-number">1</span><br>   );<br><br>   <span class="hljs-comment">// 开始转换</span><br>   sws_scale(<br>           swsContext, firstFrame-&gt;data, firstFrame-&gt;linesize, <span class="hljs-number">0</span>, firstFrame-&gt;height,<br>           rgbFrame-&gt;data, rgbFrame-&gt;linesize<br>   );<br><br><span class="hljs-comment">// 转换后的rgbFrame即为目标frame</span><br></code></pre></td></tr></table></figure><p>从这里我们也能看到，实际上我们不需要关注各种图像格式的具体结构，我们只需要了解到我们想要什么结构就行，当解码出来的数据是<code>YUV</code>数据时，我们只需要直接将其转换成我们想要的<code>RGB</code>即可。</p><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>当我们解码到<code>RGB</code>帧后，下一步就是将数据写入到<code>SurfaceView</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jni.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/native_window_jni.h&gt;</span></span><br><br><span class="hljs-built_in">Java_com_example_ffmpegdemo_MainActivity_decodeFirstFrame</span>(<br>        JNIEnv* env,<br>        jobject <span class="hljs-comment">/* this */</span>,<br>        jobject surface,<br>        jstring path) &#123;<br>    <br>    <span class="hljs-comment">// 将Surface转换成nativeWindow</span><br>    ANativeWindow *aNativeWindow = <span class="hljs-built_in">ANativeWindow_fromSurface</span>(env, surface);    <br>	<span class="hljs-comment">// 设置格式，注意这里的宽高不能超过其实际的宽高</span><br>    <span class="hljs-built_in">ANativeWindow_setBuffersGeometry</span>(aNativeWindow,targetWidth, targetHeight, WINDOW_FORMAT_RGBA_8888);<br>    <span class="hljs-comment">// 写入到window中的buffer</span><br>    ANativeWindow_Buffer b;<br>    <span class="hljs-built_in">ANativeWindow_lock</span>(aNativeWindow, &amp;b, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">auto</span> *dst = (<span class="hljs-type">uint8_t</span>* )b.bits;<br>    <span class="hljs-comment">// 逐行将rgbFrame的数据复制到buffer中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; targetHeight; i++) &#123;<br>        <span class="hljs-built_in">memcpy</span>(<br>                dst + i * b.stride * <span class="hljs-number">4</span>,<br>                rgbFrame-&gt;data[<span class="hljs-number">0</span>] + i * rgbFrame-&gt;linesize[<span class="hljs-number">0</span>],<br>                targetWidth * <span class="hljs-number">4</span><br>               );<br>    &#125;<br>    <span class="hljs-comment">// 如果格式一样，可以直接复制</span><br>    <span class="hljs-comment">//if(b.stride == rgbFrame-&gt;linesize[0]) &#123;</span><br>        <span class="hljs-comment">// memcpy(dst, rgbFrame-&gt;data[0], b.stride * targetHeight * 4);</span><br>    <span class="hljs-comment">//&#125;</span><br>    <br>    <span class="hljs-built_in">ANativeWindow_unlockAndPost</span>(aNativeWindow);<br>&#125;<br></code></pre></td></tr></table></figure><p>不像<code>YUV</code>数据那样有三个分量，<code>RGB</code>数据只有一个分量，每个像素点由<code>R</code>、<code>G</code>、<code>B</code>组成，如果有透明度的话，可能还有<code>A</code>数据，它们是交织在一起的，每个像素点由三个或四个元素组成，因此，它们在<code>AVFrame</code>中是只有<code>data[0]</code>一个数据的，同样的也只有<code>linesize[0]</code>有数据。</p><p>在<code>SurfaceView</code>中，数据格式通常有<code>RGBA_8888</code>、<code>RGB_565</code>、<code>RGB_888</code>。意思也是一样的，对于<code>RGBA_8888</code>就是每个像素点有四个分量组成，每个分量占8个<code>bit</code>，按照四个颜色<code>RGBA</code>顺序排列，因此每个像素点占4个<code>byte</code>。同理<code>RGB_565</code>也是这样，每个像素占2个<code>byte</code>。因此在转换<code>YUV</code>到<code>RGB</code>时，最好选择和<code>Surface</code>一样的格式方便直接复制写入。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="c highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="c hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jni.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/native_window_jni.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/log_macros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TAG <span class="hljs-string">&quot;MyTAG&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libavformat/avformat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libavcodec/avcodec.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libswscale/swscale.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libavutil/imgutils.h&quot;</span></span><br>&#125;<br><br>AVFormatContext *inFormatCtx = nullptr;<br>AVPacket *packet = nullptr;<br><span class="hljs-type">const</span> AVCodec *videoCodec = nullptr;<br>AVCodecContext *videoCodecContext = nullptr;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span>(inFormatCtx != nullptr) &#123;<br>        avformat_close_input(&amp;inFormatCtx);<br>        inFormatCtx = nullptr;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(packet != nullptr) &#123;<br>        av_packet_free(&amp;packet);<br>        packet = nullptr;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 解码出视频的第一帧</span><br>AVFrame* <span class="hljs-title function_">decodeVideoFirstFrame</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* file)</span> &#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-comment">// 打开输入文件</span><br>    ret = avformat_open_input(&amp;inFormatCtx, file, nullptr, nullptr);<br>    <span class="hljs-keyword">if</span>(ret) &#123;<br>        ALOGD(<span class="hljs-string">&quot;error in open stream&quot;</span>);<br>        <span class="hljs-built_in">free</span>();<br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br>    <span class="hljs-comment">// 查找流</span><br>    ret = avformat_find_stream_info(inFormatCtx, nullptr);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        ALOGD(<span class="hljs-string">&quot;find stream error&quot;</span>);<br>        <span class="hljs-built_in">free</span>();<br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br>    <span class="hljs-type">int</span> streamIndex = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inFormatCtx-&gt;nb_streams; i++) &#123;<br>        AVStream *stream = inFormatCtx-&gt;streams[i];<br>        <span class="hljs-keyword">if</span>(stream-&gt;codecpar-&gt;codec_type != AVMEDIA_TYPE_VIDEO) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        streamIndex = i;<br>        videoCodec = avcodec_find_decoder(stream-&gt;codecpar-&gt;codec_id);<br>        videoCodecContext = avcodec_alloc_context3(videoCodec);<br>        avcodec_parameters_to_context(videoCodecContext, stream-&gt;codecpar);<br>        avcodec_open2(videoCodecContext, videoCodec, nullptr);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(videoCodec == nullptr || videoCodecContext == nullptr) &#123;<br>        ALOGD(<span class="hljs-string">&quot;cannot find videoCodec\n&quot;</span>);<br>        <span class="hljs-built_in">free</span>();<br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br>    <span class="hljs-comment">// 开始解码</span><br>    packet = av_packet_alloc();<br>    AVFrame *frame = av_frame_alloc();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ret = av_read_frame(inFormatCtx, packet);<br>        <span class="hljs-keyword">if</span>(ret) &#123;<br>            ALOGD(<span class="hljs-string">&quot;end of file\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (packet-&gt;stream_index != streamIndex) &#123;<br>            ALOGD(<span class="hljs-string">&quot;other packet, ignore\n&quot;</span>);<br>            av_packet_unref(packet);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 发送packet</span><br>        avcodec_send_packet(videoCodecContext, packet);<br>        <span class="hljs-comment">// 解码出frame</span><br>        ret = avcodec_receive_frame(videoCodecContext, frame);<br>        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">free</span>();<br>    <span class="hljs-keyword">return</span> frame;<br>&#125;<br><br><span class="hljs-comment">// JNI方法</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> JNIEXPORT <span class="hljs-type">void</span> JNICALL<br><span class="hljs-title function_">Java_com_example_ffmpegdemo_MainActivity_decodeFirstFrame</span><span class="hljs-params">(</span><br><span class="hljs-params">        JNIEnv* env,</span><br><span class="hljs-params">        jobject <span class="hljs-comment">/* this */</span>,</span><br><span class="hljs-params">        jobject surface,</span><br><span class="hljs-params">        jstring path)</span> &#123;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* file = env-&gt;GetStringUTFChars(path, nullptr);<br><br>    <span class="hljs-type">int</span> targetWidth = <span class="hljs-number">1080</span>;<br>    <span class="hljs-type">int</span> targetHeight = <span class="hljs-number">1080</span> * <span class="hljs-number">1080</span> / <span class="hljs-number">1920</span>;<br><br>    AVFrame* firstFrame = decodeVideoFirstFrame(file);<br>    ALOGD(<span class="hljs-string">&quot;first = %dX%d\n&quot;</span>, firstFrame-&gt;width, firstFrame-&gt;height);<br><br>    SwsContext *swsContext = sws_getContext(<br>            <span class="hljs-comment">// 原始数据的宽高和格式</span><br>            firstFrame-&gt;width, firstFrame-&gt;height, (AVPixelFormat)firstFrame-&gt;format,<br>            <span class="hljs-comment">// 目标数据的宽高和格式</span><br>            targetWidth, targetHeight, AV_PIX_FMT_RGBA,<br>            SWS_BICUBIC, nullptr, nullptr, nullptr<br>    );<br><br><br><br>    <span class="hljs-comment">// 申请一个frame并设置data</span><br>    AVFrame *rgbFrame = av_frame_alloc();<br>    <span class="hljs-type">uint8_t</span> *buffer = (<span class="hljs-type">uint8_t</span>*)av_malloc(<br>            av_image_get_buffer_size(AV_PIX_FMT_RGBA, targetWidth, targetHeight, <span class="hljs-number">1</span>)<br>    );<br>    av_image_fill_arrays(<br>            rgbFrame-&gt;data, rgbFrame-&gt;linesize, buffer, AV_PIX_FMT_RGBA,<br>            targetWidth, targetHeight, <span class="hljs-number">1</span><br>    );<br><br>    <span class="hljs-comment">// 开始转换</span><br>    sws_scale(<br>            swsContext,<br>            firstFrame-&gt;data,<br>            firstFrame-&gt;linesize,<br>            <span class="hljs-number">0</span>,<br>            firstFrame-&gt;height,<br>            rgbFrame-&gt;data,<br>            rgbFrame-&gt;linesize<br>    );<br><br>    <span class="hljs-comment">// 解码后将数据复制到surface中</span><br>    ANativeWindow *aNativeWindow = ANativeWindow_fromSurface(env, surface);<br>    ANativeWindow_setBuffersGeometry(aNativeWindow,targetWidth, targetHeight, WINDOW_FORMAT_RGBA_8888);<br><br>    ANativeWindow_Buffer b;<br><br>    ANativeWindow_lock(aNativeWindow, &amp;b, nullptr);<br>    <span class="hljs-keyword">auto</span> *dst = (<span class="hljs-type">uint8_t</span>* )b.bits;<br>    ALOGD(<span class="hljs-string">&quot;stride = %d\n&quot;</span>, b.stride);<br>    <span class="hljs-comment">/*for(int i = 0; i &lt; targetHeight; i++) &#123;</span><br><span class="hljs-comment">        memcpy(</span><br><span class="hljs-comment">                dst + i * b.stride * 4,</span><br><span class="hljs-comment">                rgbFrame-&gt;data[0] + i * rgbFrame-&gt;linesize[0],</span><br><span class="hljs-comment">                targetWidth * 4</span><br><span class="hljs-comment">               );</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-built_in">memcpy</span>(dst, rgbFrame-&gt;data[<span class="hljs-number">0</span>], targetHeight * targetWidth * <span class="hljs-number">4</span>);<br>    ANativeWindow_unlockAndPost(aNativeWindow);<br>    <span class="hljs-keyword">return</span>;<br>    sws_freeContext(swsContext);<br>    av_free(buffer);<br>    av_frame_free(&amp;rgbFrame);<br><br>    env-&gt;ReleaseStringUTFChars(path, file);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上逻辑就是在<code>decodeFirstFrame</code>这个<code>jni</code>方法中解码出第一帧视频帧，然后将其转换成<code>RGBA</code>格式，然后获取到<code>Surface</code>，并将数据直接复制到其对应的缓存中。至于在<code>MainActivity</code>中只需要将其传入即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> holder = binding.surfaceView.holder<br>holder.addCallback(<span class="hljs-keyword">object</span> : SurfaceHolder.Callback &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">surfaceCreated</span><span class="hljs-params">(holder: <span class="hljs-type">SurfaceHolder</span>)</span></span> &#123;<br>        thread &#123;<br>            <span class="hljs-comment">// /data/data/com.example.ffmpegdemo/cache/1.mkv</span><br>            <span class="hljs-keyword">val</span> file = File(cacheDir, <span class="hljs-string">&quot;1.mkv&quot;</span>)<br>            decodeFirstFrame(holder.surface, file.absolutePath)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">surfaceChanged</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        holder: <span class="hljs-type">SurfaceHolder</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        format: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        width: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        height: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;&#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">surfaceDestroyed</span><span class="hljs-params">(holder: <span class="hljs-type">SurfaceHolder</span>)</span></span> &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<code>FFmpeg</code>我们很容易解码视频，也就是获取到实际的音频数据以及视频数据，当我们拿到数据后，对其进行播放也就比较简单了，即<code>PCM</code>的音频数据可以使用<code>AudioTracker</code>播放，视频数据转换成<code>RGBA</code>后使用<code>SurfaceView</code>进行播放即可，这样，我们也就能实现一个音频播放器了。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Wed Dec 20 2023 21:13:03 GMT+0800");let n="Wed Dec 20 2023 21:13:03 GMT+0800";n="2025-04-01 16:45:38 +0800";var d=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-d)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Third-Libraries/" class="post-footer-category">#&nbsp;Third Libraries</a> <a href="/tags/FFmpeg/" class="post-footer-tag">#&nbsp;FFmpeg</a></div><div class="nav"><div class="nav-item-prev"><a href="/2024/01/02/navigation/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">在Compose中使用Navigation</div></div></a></div><div class="nav-item-next"><a href="/2023/11/13/ffmpeg3/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">FFmpeg解码音频PCM</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91" class="toc-link"><span class="toc-text">解码视频</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE" class="toc-link"><span class="toc-text">解码视频数据</span></a></li><li class="toc-item toc-level-4"><a href="#%E8%BD%AC%E6%88%90RGB" class="toc-link"><span class="toc-text">转成RGB</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%86%99%E5%85%A5" class="toc-link"><span class="toc-text">写入</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" class="toc-link"><span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-10-05</div><a href="/2023/10/05/ffmpeg2/"><div class="recent-posts-item-content">FFmpeg解封装与重封装</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-09-06</div><a href="/2023/09/06/ffmpeg1/"><div class="recent-posts-item-content">FFmpeg编译so库文件</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-01-02</div><a href="/2024/01/02/navigation/"><div class="recent-posts-item-content">在Compose中使用Navigation</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-10-12</div><a href="/2021/10/12/bsdiff-translation/"><div class="recent-posts-item-content">【翻译】Naive Differences of Executable Code</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-02-20</div><a href="/2024/02/20/generics/"><div class="recent-posts-item-content">Java泛型</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-01-02</div><a href="/2024/01/02/navigation/"><div class="recent-posts-item-content">在Compose中使用Navigation</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>