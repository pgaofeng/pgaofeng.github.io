<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Kotlin协程的使用</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>24</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>15</span> <span>标签</span> </a><a class="author-word-count"><span>10.56</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E5%8D%8F%E7%A8%8BCoroutine" class="toc-link"><span class="toc-text">协程Coroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8" class="toc-link"><span class="toc-text">协程的启动</span></a></li><li class="toc-item toc-level-4"><a href="#suspend" class="toc-link"><span class="toc-text">suspend</span></a></li><li class="toc-item toc-level-4"><a href="#%E8%B0%83%E5%BA%A6%E5%99%A8Dispatchers" class="toc-link"><span class="toc-text">调度器Dispatchers</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88" class="toc-link"><span class="toc-text">协程的取消</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" class="toc-link"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%9B%9E%E8%B0%83%E8%BD%AC%E5%8D%8F%E7%A8%8B" class="toc-link"><span class="toc-text">回调转协程</span></a></li></ol></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">3</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">5</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Kotlin协程的使用 thumbnail" class="image lozad" src="/img/cover/cover-coroutine-1.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Kotlin协程的使用</h1></header><div class="post-meta post-show-meta"><time datetime="2023-03-15T13:05:26.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2023-03-15</span> </time><span class="dot"></span> <a href="/categories/Kotlin/" class="post-meta-link">Kotlin </a><span class="dot"></span> <span>约3.7k 字</span></div><div class="post-content" id="section"><p><code>Kotlin</code>目前已经是<code>Android</code>开发的首选语言了，其具有丰富的语法糖方便我们开发，以及协程的功能更是大大简化了线程之间的切换处理，本文主要记录协程的基础用法。</p><h3 id="协程Coroutine"><a href="#协程Coroutine" class="headerlink" title="协程Coroutine"></a>协程Coroutine</h3><p>首先回到定义上，协程是什么？在<code>Kotlin</code>中，协程可以看做是一个能够随时挂起恢复的代码块，更可以看做是一套线程框架，我们可以使用它实现各种异步操作，最为出名的就是它能以同步方式实现异步操作。</p><h4 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h4><p>协程是一类特殊的代码块，在它的内部再次启动一个协程块，被称为子协程，在<code>Kotlin</code>中有定义几个启动协程的函数，我们通常都是通过他们来启动一个协程树。</p><ul><li><p><strong>runBlocking</strong>： 顶层函数，直接启动协程</p><p><code>runBlocking</code>可以直接在任何地方启动一个协程，但是会阻塞当前线程，直到协程执行完毕返回，并且返回值就是协程代码块的返回值，通常我们使用的较少，因为它会阻塞当前线程。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 当前线程本来在做一些操作</span><br>    ...<br>   <span class="hljs-comment">// 阻塞当前线程</span><br>   <span class="hljs-keyword">val</span> res = runBlocking &#123; <br>       <span class="hljs-comment">// 在协程中执行别的操作</span><br>       ...<br>       <span class="hljs-comment">// 最后一行返回结果，可以省略return@runBlocking</span><br>       <span class="hljs-keyword">return</span><span class="hljs-symbol">@runBlocking</span> result<br>   &#125;<br>   <span class="hljs-comment">// 恢复原线程的执行，继续执行别的逻辑</span><br>   ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>launch</strong>：拓展函数，需要在协程作用域内启动协程</p><p><code>launch</code>是<code>CoroutineScope</code>的拓展函数，必须通过<code>CoroutineScope</code>启动，也正是因为如此，我们可以通过<code>CoroutineScope</code>去取消掉它名下的所有启动的协程。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 在界面destory的时候不要忘记取消它名下的所有协程</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scope = MainScope()<br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 原线程做一些事</span><br>   ...<br>   <span class="hljs-keyword">val</span> job = scope.launch &#123; <br>      <span class="hljs-comment">// 启动协程去做别的事</span><br>   &#125;<br>   <span class="hljs-comment">// 原线程继续做原来的事，不受协程影响</span><br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><p>使用这种方式启动的协程不会影响原线程，可以理解为启动协程后这部分的代码块就成为异步的了，所以不会影响到后续的逻辑执行，至于这段协程代码块什么时候执行在哪个线程执行，就是协程上下文所决定的了。</p><p>这里启动协程用的是<code>MainScope</code>，这是<code>Android</code>主线程的作用域，也就是说使用该<code>scope</code>启动的协程默认情况下都会执行在主线程上。还有别的如<code>GlobalScope</code>，它是全局单例对象，也可以用来启动协程，但是使用它的时候需要注意及时取消，避免引起内存泄漏。</p><p>当然我们也可以<code>new</code>一个<code>CoroutineScope</code>，同样的是需要注意管理协程的及时取消。如果我们限麻烦，可以使用<code>lifecycleScope</code>和<code>viewModelScope</code>（需要加对应的<code>ktx</code>依赖）来启动协程，这样我们就不需要关注它的取消问题了，因为他们会在对应的组件销毁时直接取消掉。</p><p>还有就是需要注意<code>launch</code>是有返回值的，它代表的是这个协程，我们可以通过它获知到协程的状态等信息，也可以通过它取消当前协程的执行。</p></li><li><p><strong>async</strong>：拓展函数，需要在协程作用域内启动协程</p><p><code>async</code>和<code>launch</code>一样，都是需要通过<code>CoroutineScope</code>来启动的。通常情况下，我们通过<code>launch</code>启动协程后就不需要管它了，相当于从当前位置直接剥离出去了。但是有时候我们还需要协程执行的结果，直接使用<code>launch</code>肯定是无法满足我们的要求的，因此可以使用<code>async</code>。</p><p>它会返回一个<code>Deferred&lt;T&gt;</code>，也是一个<code>Job</code>的子类，还是可以通过它来完成协程的取消以及状态获取等操作的，但它额外增加了一个功能，就是它能存储协程执行的结果，我们可以通过它拿到协程执行的结果。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> scope = MainScope()<br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 启动一个协程</span><br>   scope.launch &#123;<br>       <span class="hljs-comment">// 在协程中启动另一个协程执行别的操作</span><br>       <span class="hljs-keyword">val</span> res = async &#123;<br>           <span class="hljs-comment">// 例如做一些耗时操作</span><br>       &#125;<br>       <span class="hljs-comment">// 等待协程的结果</span><br>       <span class="hljs-keyword">val</span> result = res.await()<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>async</code>的特点就是可以拿到协程的执行结果，通过<code>await</code>获取结果。从上文我们看到，我们并不是直接通过<code>scope</code>来启动<code>async</code>的，而是在协程的内部启动的。当然直接启动也是可以的，但如果想要获取到协程的结果，则必须在协程代码块中获取，因为<code>await</code>方法是<code>suspend</code>函数。</p></li></ul><h4 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h4><p>前面提到的启动协程的几种方式，其传递的代码块都是通过<code>suspend</code>修饰的。该关键字是属于<code>kotlin</code>关键字，被他修饰的代码块或者函数表示其是可挂起的，因此也只能运行在协程中，普通函数是无法直接调用<code>suspend</code>函数的。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">val</span> photo = withContext(Dispatchers.IO) &#123;<br>       ...<br>   &#125;<br>   delay(<span class="hljs-number">100</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，<code>suspend</code>就是协程的关键字，它修饰的代码块只能在协程中执行，所以只有在<code>suspend</code>函数内才能调用别的<code>suspend</code>函数，如上面的<code>withContext</code>和<code>delay</code>方法就是<code>suspend</code>方法。</p><h4 id="调度器Dispatchers"><a href="#调度器Dispatchers" class="headerlink" title="调度器Dispatchers"></a>调度器Dispatchers</h4><p>协程本质上就是一个线程的封装框架，实际底层还是通过线程来处理的。其内置了多个线程池，在协程中被称为调度器，实际就是线程池。</p><ul><li><p><strong>Dispatchers.Main</strong></p><p>主线程调度器，所有通过该调度器调度的协程都会运行在主线程，因此它实际上也是一个单线程的线程池。在<code>Android</code>中我们会在主线程中操作<code>UI</code>，一般通过<code>withContext</code>方法来切换线程，当然我们启动的协程时也可以直接传入<code>Dispatchers</code>来实现切换。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// withContext必须在suspend代码块中调用</span><br>   <span class="hljs-keyword">val</span> photo = withContext(Dispatchers.IO) &#123;<br>       <span class="hljs-comment">// IO线程做耗时操作</span><br>       ...<br>   &#125;<br>   withContext(Dispatchers.Main) &#123;<br>       <span class="hljs-comment">// 切换到主线程更新UI</span><br>       ...<br>   &#125;<br>       <br>   <span class="hljs-comment">// 启动一个协程并指定运行在主线程上</span><br>   scope.launch(Dispatchers.Main) &#123; <br>       ...<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么我们喜欢通过<code>withContext</code>来切换线程，而不是通过<code>launch</code>呢？从上面我们也可以看到，<code>withContext</code>函数只要在<code>suspend</code>代码块中都是可以调用的，而<code>launch</code>必须在<code>scope</code>的作用域内才能启动协程。同时<code>launch</code>是启动另一个协程，相当于从当前协程中脱离出去了，而<code>withContext</code>并不会额外起一个协程，同时它还能有返回值，灵活性比起一个新协程高很多。</p></li><li><p><strong>Dispatchers.IO</strong></p><p><code>IO</code>线程池，通常被用来执行一些<code>IO</code>操作密集型的工作。</p></li><li><p><strong>Dispatchers.Default</strong></p><p>默认线程池，通常被用来执行一些<code>CPU</code>操作密集型的工作。</p></li><li><p><strong>Dispatchers.Unconfined</strong></p><p>无限制调度器，即不主动修改线程。如果在协程的执行过程中发生了线程变化，则恢复后的线程仍是变化的那个线程，如下示例：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> = withContext(Dispatchers.Unconfined)&#123;<br>   log(<span class="hljs-string">&quot;1&quot;</span>)<br>   withContext(Dispatchers.Unconfined) &#123;<br>      log(<span class="hljs-string">&quot;2&quot;</span>)<br>   &#125;<br>   log(<span class="hljs-string">&quot;3&quot;</span>)<br>   withContext(Dispatchers.Default) &#123;<br>      log(<span class="hljs-string">&quot;4&quot;</span>)<br>   &#125;<br>   log(<span class="hljs-string">&quot;5&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">log</span><span class="hljs-params">(msg:<span class="hljs-type">String</span>)</span></span> &#123;<br>    Log.d(TAG, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span> = <span class="hljs-variable">$msg</span>&quot;</span>)<br>&#125;<br> <br>-------------------------<br> D  main = <span class="hljs-number">1</span><br> D  main = <span class="hljs-number">2</span><br> D  main = <span class="hljs-number">3</span><br> D  DefaultDispatcher-worker-<span class="hljs-number">1</span> = <span class="hljs-number">4</span><br> D  DefaultDispatcher-worker-<span class="hljs-number">1</span> = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li><li><p>自定义调度器</p><p>自定义调度器可以通过继承自<code>CoroutineDispatcher</code>来实现，但是会比较麻烦。而我们知道实际的调度器就是个线程池，因此可以直接创建出线程池<code>Executor</code>，然后通过拓展方法<code>asCoroutineDispatcher</code>转换成调度器。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> custom = Executors.newCachedThreadPool().asCoroutineDispatcher()<br>    withContext(custom) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="协程的取消"><a href="#协程的取消" class="headerlink" title="协程的取消"></a>协程的取消</h4><p><code>Job</code>代表的是协程任务，而取消也是通过<code>Job#cancel</code>进行取消的。但是它的取消并不是直接取消掉，而是需要协程本身的响应。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> job = scope.launch &#123;<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.100</span>) &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>)<br>            log(<span class="hljs-string">&quot;协程任务：<span class="hljs-variable">$i</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>    Thread.sleep(<span class="hljs-number">3000</span>)<br>    job.cancel()<br>    log(<span class="hljs-string">&quot;取消协程&quot;</span>)<br>&#125;<br>-----------------<br><br> D  协程任务：<span class="hljs-number">0</span><br> D  协程任务：<span class="hljs-number">1</span><br> D  取消协程<br> D  协程任务：<span class="hljs-number">2</span><br> ....<br></code></pre></td></tr></table></figure><p>像上述示例，我们启动的协程并在其中做循环操作，然后在3秒后取消协程，但是实际它并没有被取消掉。这是因为协程本身并没有去响应取消的操作，正常我们启动的协程必须要响应取消操作。</p><p>上述代码中的<code>for</code>循环中，将<code>Thread.sleep</code>改为<code>delay</code>就可以正常取消了，因为协程库中所有提供的可挂起函数都是已经适配了取消操作的，所以我们可以通过<code>delay</code>来响应取消操作。但是这里我们是通过<code>sleep</code>模拟的耗时操作，实际中是不能直接替换成<code>delay</code>的，所以我们需要别的方式，如：<code>yield</code>。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> job = scope.launch &#123;<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.100</span>) &#123;<br>            yield()<br>            Thread.sleep(<span class="hljs-number">1000</span>) <span class="hljs-comment">// delay(1000)</span><br>            log(<span class="hljs-string">&quot;协程任务：<span class="hljs-variable">$i</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>    Thread.sleep(<span class="hljs-number">3000</span>)<br>    job.cancel()<br>    log(<span class="hljs-string">&quot;取消协程&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>yield</code>更贴切实际开发，因为中间的1秒的耗时操作是真实耗时的，无法被替换成<code>delay</code>的。而<code>yield</code>表示的是让出当前协程的调度，让其他协程有机会在对应的线程中执行，正常是不会影响到我们的执行的，所以响应协程的取消主要就是要在代码块中存在协程的检查点，这个检查点可以是协程提供的挂起函数。</p><p>如果我们不想直接使用协程的挂起函数，那么可以使用<code>isActive</code>来进行判断，当协程取消时，该属性会被置为false，我们可以通过这个属性来取消协程。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> job = scope.launch &#123;<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.100</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!isActive) &#123;<br>                <span class="hljs-comment">// 当前状态为false时，直接结束协程的执行</span><br>                <span class="hljs-keyword">return</span><span class="hljs-symbol">@launch</span><br>            &#125;<br>            Thread.sleep(<span class="hljs-number">1000</span>) <span class="hljs-comment">// delay(1000)</span><br>            log(<span class="hljs-string">&quot;协程任务：<span class="hljs-variable">$i</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>    Thread.sleep(<span class="hljs-number">3000</span>)<br>    job.cancel()<br>    log(<span class="hljs-string">&quot;取消协程&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过在<code>for</code>循环中检查<code>isActive</code>的值来结束协程，这样是可以结束掉协程的，但这属于正常的退出。对于取消操作，我们在结束时还需要抛出<code>CancellationException</code>给到上层。所以上面的<code>return@launch</code>应该修改为<code>throw CancellationException(&quot;msg&quot;)</code>，当然还有更优雅的方式，就是将整个判断改为<code>ensureActive()</code>就可以了，它内部也是这样的一个判断过程。</p><p>所以：如上示例我们的耗时操作是多个耗时操作，每个耗时操作是1秒，所以当我们正在执行操作时被取消了，此时会过去1秒后再次循环时才会进入判断并取消掉。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>协程的执行过程中是可能会发生异常的，正常我们都是通过<code>try catch</code>进行捕获的，我们在协程内部也可以通过<code>try catch</code>在具体的位置进行捕获异常，但是我们无法直接对整个协程进行捕获异常。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 无法捕获到异常，会直接闪退</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        scope.launch &#123;<br>            <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>    &#125;<br>    <span class="hljs-comment">// 协程内部可以捕获到</span><br>    scope.launch &#123; <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 无法捕获异常，会直接闪退</span><br>    scope.launch &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            launch &#123; <br>                <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以不论是父协程还是子协程，异常都是无法直接<code>try catch</code>的。协程中提供了一个专门用于处理异常的捕获器，叫做<code>CoroutineExceptionHandler</code>，整个协程树下的异常都会被其捕获。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;FunctionName&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">CoroutineExceptionHandler</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> handler: (<span class="hljs-type">CoroutineContext</span>, <span class="hljs-type">Throwable</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: CoroutineExceptionHandler =<br>    <span class="hljs-keyword">object</span> : AbstractCoroutineContextElement(CoroutineExceptionHandler), CoroutineExceptionHandler &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> =<br>            handler.invoke(context, exception)<br>    &#125;<br></code></pre></td></tr></table></figure><p>方法名和返回值类型是一样的，这是方便我们直接创建异常处理器。正常直接通过该方法传递一个异常处理的表达式即可，如下例：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scope = CoroutineScope(CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt; <br>    <span class="hljs-comment">// 这里处理异常情况</span><br>    log(<span class="hljs-string">&quot;捕获到的协程的异常： <span class="hljs-variable">$throwable</span>&quot;</span>)<br>&#125;)<br>    <br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>    scope.launch &#123;<br>       <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="回调转协程"><a href="#回调转协程" class="headerlink" title="回调转协程"></a>回调转协程</h4><p>协程是<code>Kotlin</code>中的特性，其底层仍是通过回调方式完成的，实际上协程也提供给了我们一些方法来处理回调问题。我们的老项目，大多数都是<code>Java</code>实现的，基本上所有的异步操作都是通过回调的方式实现的。而有了协程后，再也难以忍受回调了，我们迫切希望使用协程。</p><p>然而使用协程重写一份肯定是非常消耗人力的，并且会对老的代码带来改动，因此我们采用包装的方式，将回调转成协程，这样就不需要改动老代码，而新功能就可以直接使用协程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">(String url,  Callback callback)</span> &#123;<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>            .url(url)<br>            ...<br>            .build();<br>    client.newCall(request)<br>            .enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">okhttp3</span>.Callback() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Call call, <span class="hljs-meta">@NonNull</span> IOException e)</span> &#123;<br>                    callback.onFail(e);<br>                &#125;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Call call, <span class="hljs-meta">@NonNull</span> Response response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                    callback.onSuccess(response.body());<br>                &#125;<br>            &#125;);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callback</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(ResponseBody body)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFail</span><span class="hljs-params">(Throwable throwable)</span>;<br>&#125;<br><br><span class="hljs-comment">// 实际使用中通过回调处理</span><br>request(url, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(ResponseBody body)</span> &#123;<br>        <span class="hljs-comment">// 处理网络请求成功的逻辑</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFail</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>       <span class="hljs-comment">// 处理失败的逻辑</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>如上，通常是我们简单封装网络请求的一种方式，实际使用通过<code>request</code>方法进行网络请求，当然这里只是简化逻辑，实际可能比这个复杂，但整体还是使用的回调的方式。然后我们引入<code>kotlin</code>以及协程后，肯定不想再这样进行网络请求，肯定想要用更时髦的协程方式，因此我们在<code>kotlin</code>中创建一个新的方法来包装回调方法：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">request</span><span class="hljs-params">(url:<span class="hljs-type">String</span>)</span></span>: ResponseBody? = suspendCancellableCoroutine &#123; result -&gt;<br>    kotlin.runCatching &#123;<br>        NetUtils.request(url, <span class="hljs-keyword">object</span> : NetUtils.Callback &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(body: <span class="hljs-type">ResponseBody</span>?)</span></span> &#123;<br>                result.resumeWith(Result.success(body))<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFail</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                result.resumeWithException(e)<br>            &#125;<br>        &#125;)<br>    &#125;.onFailure &#123;<br>        result.resumeWithException(it)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实际使用</span><br>launch &#123;<br>    <span class="hljs-keyword">val</span> body = request(url)<br>    <span class="hljs-comment">// 处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，通过<code>suspendCancellableCoroutine</code>可以包裹整块逻辑，然后在后面的代码块中执行我们实际的请求逻辑，这里并没有重新封装网络请求，仍然是调用的老的回调方式的网络请求，然后在回调中将协程的结果返回，这样就可以将回调转成协程了，使用方式也更加简单。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Wed Mar 15 2023 21:05:26 GMT+0800");let n="Wed Mar 15 2023 21:05:26 GMT+0800";n="2025-03-01 18:42:52 +0800";var a=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-a)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Kotlin/" class="post-footer-category">#&nbsp;Kotlin</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" class="post-footer-tag">#&nbsp;协程</a> <a href="/tags/Kotlin/" class="post-footer-tag">#&nbsp;Kotlin</a></div><div class="nav"><div class="nav-item-prev"><a href="/2023/05/22/flow/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">协程数据流Flow</div></div></a></div><div class="nav-item-next"><a href="/2023/02/24/kotlin-note/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Kotlin使用笔记</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E5%8D%8F%E7%A8%8BCoroutine" class="toc-link"><span class="toc-text">协程Coroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8" class="toc-link"><span class="toc-text">协程的启动</span></a></li><li class="toc-item toc-level-4"><a href="#suspend" class="toc-link"><span class="toc-text">suspend</span></a></li><li class="toc-item toc-level-4"><a href="#%E8%B0%83%E5%BA%A6%E5%99%A8Dispatchers" class="toc-link"><span class="toc-text">调度器Dispatchers</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88" class="toc-link"><span class="toc-text">协程的取消</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" class="toc-link"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%9B%9E%E8%B0%83%E8%BD%AC%E5%8D%8F%E7%A8%8B" class="toc-link"><span class="toc-text">回调转协程</span></a></li></ol></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-06-05</div><a href="/2023/06/05/flow-2/"><div class="recent-posts-item-content">SharedFlow、StateFlow、SafeFlow的区别</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-05-22</div><a href="/2023/05/22/flow/"><div class="recent-posts-item-content">协程数据流Flow</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-02-24</div><a href="/2023/02/24/kotlin-note/"><div class="recent-posts-item-content">Kotlin使用笔记</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-06-05</div><a href="/2023/06/05/flow-2/"><div class="recent-posts-item-content">SharedFlow、StateFlow、SafeFlow的区别</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-05-22</div><a href="/2023/05/22/flow/"><div class="recent-posts-item-content">协程数据流Flow</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-03-15</div><a href="/2023/03/15/coroutine-1/"><div class="recent-posts-item-content">Kotlin协程的使用</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-02-24</div><a href="/2023/02/24/kotlin-note/"><div class="recent-posts-item-content">Kotlin使用笔记</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>