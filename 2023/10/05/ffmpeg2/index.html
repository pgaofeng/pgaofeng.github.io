<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>FFmpeg解封装与重封装</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.1.1" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>44</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>18.05</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E5%B0%81%E8%A3%85-%E8%A7%A3%E5%B0%81%E8%A3%85" class="toc-link"><span class="toc-text">封装&amp;解封装</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">9</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="FFmpeg解封装与重封装 thumbnail" class="lozad image" src="/img/cover/cover-ffmpeg2.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">FFmpeg解封装与重封装</h1></header><div class="post-meta post-show-meta"><time datetime="2023-10-05T08:38:41.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2023-10-05</span> </time><span class="dot"></span> <a href="/categories/Third-Libraries/" class="post-meta-link">Third Libraries </a><span class="dot"></span> <span>约1.4k 字</span></div><div class="post-content" id="section"><p><code>FFmpeg</code>有七个模块，在我们的使用中会被编译成七个<code>so</code>库文件，其中最重要的就是<code>avformat</code>、<code>avcodec</code>和<code>avutil</code>。</p><p>其中<code>avformat</code>处理的是对音视频的解封装相关，视频通常至少包含两个数据，音频流和视频流，然后这两个数据会被封装成一个整体，即视频文件，如常见的<code>mp4</code>、<code>flv</code>等。而<code>avformat</code>就是处理这些文件的，它能够将其解封装，拆解出对应的音频流和视频流。当然反过来它也可以将音频流和视频流再重新封装，封装成不同的格式。</p><p>解封装后的音频流和视频流还是不能直接播放的，因为它们都是压缩后的。原始的音频流和视频流都是非常大的，直接存储会占用大量的存储空间，因此会将其进行压缩，也称为编码。音频流常用编码<code>aac</code>等，视频流常见编码<code>h264</code>等，想要播放音频或视频，就必须将其解码成原始数据，如音频流的<code>pcm</code>数据，视频流的<code>yuv</code>数据等。而<code>avcodec</code>就是用来解码的模块，当然返过来他也可以对其进行编码。</p><p><img alt="视频" class="lozad post-image" src="/img/img-ffmpeg-video.webp" data-src="/img/img-ffmpeg-video.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><p>而<code>avutil</code>就是工具类模块，其中封装了大量的常用的函数，基本上每个模块都会用到它。</p><h3 id="封装-解封装"><a href="#封装-解封装" class="headerlink" title="封装&amp;解封装"></a>封装&amp;解封装</h3><p>封装和解封装是针对视频的，因为视频文件是多路流一起封装起来的。所谓的解封装就是将一个视频文件中的视频流和音频流拆解出来，而封装则是将视频流和音频流合并成一个完整的视频文件。封装和解封装的概念是针对于视频文件的，只有我们需要处理视频文件时，才需要考虑解封装。</p><p><code>FFmpeg</code>处理视频文件的流程就是先打开文件，然后查找到对应的流信息，接着就是读取一个个的<code>Packet</code>，这些<code>Packet</code>就是流数据，不管是视频流还是音频流，都会被读成<code>AVPacket</code>。如果仅仅是为了解封装，其实到这里我们就已经做到了，我们完全可以将这些<code>Packet</code>重新写入到另一个封装容器中，从而实现换格式的场景。</p><p>大概的流程如下：</p><p><img alt="流程" class="lozad post-image" src="/img/img-ffmpeg-demux.webp" data-src="/img/img-ffmpeg-demux.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><p>实际上看到解封装和重新封装的流程很简单，就是不断的读<code>packet</code>，再不断地写入到新文件中即可，实际上的编码也是一样的简单。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// 在C++中引入C的头文件必须要extern</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> “libavformat/avformat.h”</span><br>&#125;<br><br>AVFormatContext *inFormatCtx = <span class="hljs-literal">nullptr</span>, *outFormatCtx = <span class="hljs-literal">nullptr</span>;<br>AVPacket *packet = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 申请的对象都必须要释放掉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(inFormatCtx != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">avformat_close_input</span>(&amp;inFormatCtx);<br>        inFormatCtx = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(outFormatCtx != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">avformat_free_context</span>(outFormatCtx);<br>        outFormatCtx = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(packet != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">av_packet_free</span>(&amp;packet);<br>        packet = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实际的转换函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-type">char</span>* inputFile, <span class="hljs-type">char</span>* outputFile)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-comment">// 打开输入文件</span><br>    ret = <span class="hljs-built_in">avformat_open_input</span>(&amp;inFormatCtx, inputFile, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span>(ret) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error in open stream&quot;</span>);<br>        <span class="hljs-built_in">free</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查找流</span><br>    ret = <span class="hljs-built_in">avformat_find_stream_info</span>(inFormatCtx, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find stream error&quot;</span>);<br>        <span class="hljs-built_in">free</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 根据文件名的后缀创建输出上下文</span><br>    ret = <span class="hljs-built_in">avformat_alloc_output_context2</span>(&amp;outFormatCtx, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, outputFile);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error in open output&quot;</span>);<br>        <span class="hljs-built_in">free</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inFormatCtx-&gt;nb_streams; i++) &#123;<br>        AVStream *stream = inFormatCtx-&gt;streams[i];<br>        <span class="hljs-comment">// 输出文件创建对应的流</span><br>        AVStream *out = <span class="hljs-built_in">avformat_new_stream</span>(outFormatCtx, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-comment">// 复制输入流的参数</span><br>        <span class="hljs-built_in">avcodec_parameters_copy</span>(out-&gt;codecpar, stream-&gt;codecpar);<br>    &#125;<br>    <span class="hljs-comment">// 打开输出流</span><br>    ret = <span class="hljs-built_in">avio_open2</span>(&amp;outFormatCtx-&gt;pb, outputFile, AVIO_FLAG_WRITE, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error in open AVIO&quot;</span>);<br>        <span class="hljs-built_in">free</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取数据</span><br>    packet = <span class="hljs-built_in">av_packet_alloc</span>();<br>    <span class="hljs-comment">// 1. 写入文件头</span><br>    ret = <span class="hljs-built_in">avformat_write_header</span>(outFormatCtx, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-comment">// 2. 写入packet</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ret = <span class="hljs-built_in">av_read_frame</span>(inFormatCtx, packet);<br>        <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;end of file&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> index = packet-&gt;stream_index;<br>        AVStream *in = inFormatCtx-&gt;streams[index];<br>        AVStream *out = outFormatCtx-&gt;streams[index];<br>        <span class="hljs-built_in">av_packet_rescale_ts</span>(packet, in-&gt;time_base, out-&gt;time_base);<br>        <span class="hljs-built_in">av_interleaved_write_frame</span>(outFormatCtx, packet);<br>    &#125;<br>    <span class="hljs-comment">// 3. 写入文件尾</span><br>    <span class="hljs-built_in">av_write_trailer</span>(outFormatCtx);<br>    <span class="hljs-built_in">free</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>过程并没有什么复杂的，按照流程一步一步来即可。然后是在<code>Android</code>中使用，其实方法实现了，我们只需要在<code>jni</code>中使用即可：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">JNIEXPORT <span class="hljs-type">void</span> JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_example_ffmpegdemo_MainActivity_convert</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">        jobject <span class="hljs-comment">/* this */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        jstring input,</span></span><br><span class="hljs-params"><span class="hljs-function">        jstring output)</span> </span>&#123;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* in = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(input, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* out = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(output, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">convert</span>(in, out);<br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(input, in);<br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(output, out);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是在<code>MainActivity</code>中调用即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">binding.button.setOnClickListener &#123;<br>    <span class="hljs-comment">// 注意在子线程中调用</span><br>    thread &#123;<br>        <span class="hljs-comment">// 输入文件是/data/data/com.example.ffmpegdemo/files/cache/1.mkv</span><br>        <span class="hljs-keyword">val</span> inputFile = File(cacheDir, <span class="hljs-string">&quot;1.mkv&quot;</span>)<br>        <span class="hljs-comment">// 输出文件会在该目录下生成一个2.mp4文件</span><br>        <span class="hljs-keyword">val</span> outputFile = File(cacheDir, <span class="hljs-string">&quot;2.mp4&quot;</span>)<br>        convert(inputFile.absolutePath, outputFile.absolutePath)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后找一个<code>mkv</code>视频文件，重命名为<code>1.mkv</code>，然后<code>push</code>到应用的缓存目录中，<code>/data/data/com.example.ffmpegdemo/files/cache</code>目录下，再运行即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>视频封装就是将音频流、视频流等封装成一个文件，根据其封装格式其内部有不同的结构，可能是一段音频一段视频这样交错组织，也可能是以别的模式组织。而解封装的意义就是将这些组织在一块的音频和视频分开，我们通过<code>FFmpeg</code>读取到的<code>AVPacket</code>就代表着这样的一段音频或者视频数据，注意的是，这些数据仍是压缩后的数据，想要播放的话还需要对这些数据进行解码才行。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Thu Oct 05 2023 16:38:41 GMT+0800");let n="Thu Oct 05 2023 16:38:41 GMT+0800";n="2025-03-26 10:51:15 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Third-Libraries/" class="post-footer-category">#&nbsp;Third Libraries</a> <a href="/tags/FFmpeg/" class="post-footer-tag">#&nbsp;FFmpeg</a></div><div class="nav"><div class="nav-item-prev"><a href="/2023/11/13/ffmpeg3/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">FFmpeg解码音频PCM</div></div></a></div><div class="nav-item-next"><a href="/2023/09/06/ffmpeg1/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">FFmpeg编译so库文件</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E5%B0%81%E8%A3%85-%E8%A7%A3%E5%B0%81%E8%A3%85" class="toc-link"><span class="toc-text">封装&amp;解封装</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-09-06</div><a href="/2023/09/06/ffmpeg1/"><div class="recent-posts-item-content">FFmpeg编译so库文件</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-01-02</div><a href="/2024/01/02/navigation/"><div class="recent-posts-item-content">在Compose中使用Navigation</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-10-12</div><a href="/2021/10/12/bsdiff-translation/"><div class="recent-posts-item-content">【翻译】Naive Differences of Executable Code</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-12-20</div><a href="/2024/12/20/flutter-getx-source/"><div class="recent-posts-item-content">GetX原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-09-10</div><a href="/2024/09/10/flutter-state/"><div class="recent-posts-item-content">Flutter状态管理</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>