<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>GetX原理分析</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.1.1" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>45</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>18.72</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" class="toc-link"><span class="toc-text">依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E6%B3%A8%E5%85%A5" class="toc-link"><span class="toc-text">注入</span></a></li><li class="toc-item toc-level-4"><a href="#%E8%8E%B7%E5%8F%96" class="toc-link"><span class="toc-text">获取</span></a></li><li class="toc-item toc-level-4"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="toc-link"><span class="toc-text">生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86" class="toc-link"><span class="toc-text">状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#GetxController" class="toc-link"><span class="toc-text">GetxController</span></a></li><li class="toc-item toc-level-4"><a href="#obs%E3%80%81obx" class="toc-link"><span class="toc-text">obs、obx</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">10</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="GetX原理分析 thumbnail" class="image lozad" src="/img/cover/cover-flutter-getx-source.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">GetX原理分析</h1></header><div class="post-meta post-show-meta"><time datetime="2024-12-20T11:37:03.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2024-12-20</span> </time><span class="dot"></span> <a href="/categories/Flutter/" class="post-meta-link">Flutter </a><span class="dot"></span> <span>约7.4k 字</span></div><div class="post-content" id="section"><p><code>GetX</code>也是<code>Flutter</code>中非常火的一个项目，它不是一个单一功能的库，而是一个功能非常全面的脚手架，包括有依赖注入、状态管理、多语言、路由管理、网络请求等等，实际上对于规模较小的应用，基本上只使用这一个库就可以完成整个项目的开发了。当然也可以选择性的使用，例如我们可以只使用它的状态管理功能，其他功能使用别的方式实现也是可以的。</p><p>本文专注于<code>GetX</code>的依赖注入和状态管理，版本是<code>4.7.2</code>。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入是<code>GetX</code>非常重要的一个功能，它的很多其他功能其实都是以依赖注入为基础的，例如状态管理中，对于状态的提供就是通过依赖注入来创建了查询的。</p><p>使用中我们其实更倾向于用它作为依赖管理而不是依赖注入，即创建对象依旧由我们来控制，只是我们创建完之后交由<code>GetX</code>进行管理。</p><h4 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h4><p>注入一个对象，我们最常用的注入方式就是直接通过<code>Get.put</code>添加一个已有的对象：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="dart hljs">S put&lt;S&gt;(S dependency,<span class="hljs-comment">// 注入的对象</span><br>     &#123;<span class="hljs-built_in">String?</span> tag, <span class="hljs-comment">// tag</span><br>      <span class="hljs-built_in">bool</span> permanent = <span class="hljs-keyword">false</span>, <span class="hljs-comment">// 是否永久存储</span><br>      InstanceBuilderCallback&lt;S&gt;? builder&#125;) =&gt;<br>  GetInstance().put&lt;S&gt;(dependency, tag: tag, permanent: permanent);<br></code></pre></td></tr></table></figure><p>虽然该方法参数有四个，但是最后的一个参数<code>builder</code>并没有用到，这个<code>builder</code>是用来构建对象的函数，因为我们是直接注入已有对象的，因此不需要关注如何构建。</p><p>最后的关键实际上是直接调用了<code>GetInstance().put</code>完成的注入：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetInstance</span> </span>&#123;<br>  <span class="hljs-comment">// 实际上拿到的是单例对象</span><br>  <span class="hljs-keyword">factory</span> GetInstance() =&gt; _getInstance ??= <span class="hljs-keyword">const</span> GetInstance._();<br>  <span class="hljs-keyword">const</span> GetInstance._();<br>  <span class="hljs-keyword">static</span> GetInstance? _getInstance;<br>  <span class="hljs-comment">// 存放注入对象的map集合  </span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, _InstanceBuilderFactory&gt; _singl = &#123;&#125;;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>简单看下，实际通过<code>GetInstance()</code>拿到的是全局单例对象，它内部有一个<code>map</code>集合，用于存储所有的对象，这就是依赖注入的基础，通过全局单例来实现全局都能进行注入和获取。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="dart hljs">S put&lt;S&gt;(<br>    S dependency, &#123;<br>    <span class="hljs-built_in">String?</span> tag,<br>    <span class="hljs-built_in">bool</span> permanent = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-meta">@Deprecated</span>(<span class="hljs-string">&quot;Do not use builder, it will be removed in the next update&quot;</span>)<br>    InstanceBuilderCallback&lt;S&gt;? builder,<br>&#125;) &#123;<br>    <span class="hljs-comment">// 具体逻辑是在`_insert`中</span><br>    _insert(<br>        isSingleton: <span class="hljs-keyword">true</span>,<br>        name: tag,<br>        permanent: permanent,<br>        <span class="hljs-comment">// 这里的builder直接返回实例本身</span><br>        builder: builder ?? (() =&gt; dependency));<br>    <span class="hljs-comment">// 返回值是调用find来查询，而不是直接返回dependency对象</span><br>    <span class="hljs-keyword">return</span> find&lt;S&gt;(tag: tag);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到最终的逻辑是通过<code>_insert</code>完成的，实际上<code>GetX</code>的多种注入方式，如：<code>put</code>、<code>lazyPut</code>、<code>putAsync</code>、<code>create</code>最终都是通过<code>_insert</code>，将各种参数打包成一个<code>_InstanceBuilderFactory</code>，最终存储在集合中的。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">void</span> _insert&lt;S&gt;(&#123;<br>    <span class="hljs-built_in">bool?</span> isSingleton,<br>    <span class="hljs-built_in">String?</span> name,<br>    <span class="hljs-built_in">bool</span> permanent = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">required</span> InstanceBuilderCallback&lt;S&gt; builder,<br>    <span class="hljs-built_in">bool</span> fenix = <span class="hljs-keyword">false</span>,<br>  &#125;) &#123;<br>    <span class="hljs-comment">// 根据类型获取key</span><br>    <span class="hljs-keyword">final</span> key = _getKey(S, name);<br>    <span class="hljs-comment">// 如果在集合中已经存在了</span><br>    <span class="hljs-keyword">if</span> (_singl.containsKey(key)) &#123;<br>      <span class="hljs-keyword">final</span> dep = _singl[key];<br>      <span class="hljs-keyword">if</span> (dep != <span class="hljs-keyword">null</span> &amp;&amp; dep.isDirty) &#123;<br>        <span class="hljs-comment">// 重新存储</span><br>        _singl[key] = _InstanceBuilderFactory&lt;S&gt;(<br>          isSingleton,<br>          builder,<br>          permanent,<br>          <span class="hljs-keyword">false</span>,<br>          fenix,<br>          name,<br>          <span class="hljs-comment">// 并将原来的factory记录在lateRemove中</span><br>          lateRemove: dep <span class="hljs-keyword">as</span> _InstanceBuilderFactory&lt;S&gt;,<br>        );<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 直接插入新的factory</span><br>      _singl[key] = _InstanceBuilderFactory&lt;S&gt;(<br>        isSingleton,<br>        builder,<br>        permanent,<br>        <span class="hljs-keyword">false</span>,<br>        fenix,<br>        name,<br>      );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果设置了name（对应的是tag），则使用类型+tag，否则直接用类型作为key</span><br><span class="hljs-built_in">String</span> _getKey(<span class="hljs-built_in">Type</span> type, <span class="hljs-built_in">String?</span> name) &#123;<br>   <span class="hljs-keyword">return</span> name == <span class="hljs-keyword">null</span> ? type.toString() : type.toString() + name;<br>&#125;<br></code></pre></td></tr></table></figure><p>这逻辑就很简单了，就是构建<code>key</code>（类型+<code>tag</code>），构建<code>value</code>（<code>_InstanceBuilderFactory</code>），然后将其存储在<code>map</code>集合中就完成了。其中<code>_InstanceBuilderFactory</code>如他的名字一样，实例构建工厂，当查询时，也会构建对应的<code>key</code>，然后查询到这个<code>factory</code>，由它来给出依赖的对象。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_InstanceBuilderFactory</span>&lt;<span class="hljs-title">S</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 是否是单例对象</span><br>  <span class="hljs-built_in">bool?</span> isSingleton;<br>  <span class="hljs-comment">// 保留构建工厂，即移除时只会移除依赖的对象，而不会移除构建对象的方法</span><br>  <span class="hljs-comment">// 代表着如果我在A界面注入过ClassA，则其他任何界面都能再次获取到ClassA或者</span><br>  <span class="hljs-comment">// 新的ClassA</span><br>  <span class="hljs-built_in">bool</span> fenix;<br>  <span class="hljs-comment">// 存储实例对象</span><br>  S? dependency;<br>  <span class="hljs-comment">// 用于构建实例的builder</span><br>  InstanceBuilderCallback&lt;S&gt; builderFunc;<br>  <span class="hljs-comment">// 是否永久存储实例</span><br>  <span class="hljs-built_in">bool</span> permanent = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">// 是否已经初始化了</span><br>  <span class="hljs-built_in">bool</span> isInit = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">// 重新put时，如果原来的factory被标记为dirty，则创建一个</span><br>  <span class="hljs-comment">// 新的factory，老的就是这个</span><br>  _InstanceBuilderFactory&lt;S&gt;? lateRemove;<br>  <span class="hljs-comment">// 标记为脏的</span><br>  <span class="hljs-built_in">bool</span> isDirty = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">// tag</span><br>  <span class="hljs-built_in">String?</span> tag;<br><br>  _InstanceBuilderFactory(<br>    <span class="hljs-keyword">this</span>.isSingleton,<br>    <span class="hljs-keyword">this</span>.builderFunc,<br>    <span class="hljs-keyword">this</span>.permanent,<br>    <span class="hljs-keyword">this</span>.isInit,<br>    <span class="hljs-keyword">this</span>.fenix,<br>    <span class="hljs-keyword">this</span>.tag, &#123;<br>    <span class="hljs-keyword">this</span>.lateRemove,<br>  &#125;);<br><br>  <span class="hljs-keyword">void</span> _showInitLog() &#123;<br>    <span class="hljs-keyword">if</span> (tag == <span class="hljs-keyword">null</span>) &#123;<br>      Get.log(<span class="hljs-string">&#x27;Instance &quot;<span class="hljs-subst">$S</span>&quot; has been created&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Get.log(<span class="hljs-string">&#x27;Instance &quot;<span class="hljs-subst">$S</span>&quot; has been created with tag &quot;<span class="hljs-subst">$tag</span>&quot;&#x27;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 获取依赖实例</span><br>  S getDependency() &#123;<br>    <span class="hljs-comment">// 单例对象</span><br>    <span class="hljs-keyword">if</span> (isSingleton!) &#123;<br>      <span class="hljs-comment">// 如果未初始化过，则通过builder构建</span><br>      <span class="hljs-keyword">if</span> (dependency == <span class="hljs-keyword">null</span>) &#123;<br>        _showInitLog();<br>        dependency = builderFunc();<br>      &#125;<br>      <span class="hljs-comment">// 否则直接返回</span><br>      <span class="hljs-keyword">return</span> dependency!;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 非单例对象，通过builder构建对象</span><br>      <span class="hljs-keyword">return</span> builderFunc();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>_InstanceBuilderFactory</code>中定义很多的参数，分别用于不同的场景。例如被标记为单例，则每次获取时实际上都是取的同一个对象，否则每次都是构建一个新的对象。</p><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>获取只有一个方法，<code>Get.find</code>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="dart hljs">S find&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag&#125;) =&gt; GetInstance().find&lt;S&gt;(tag: tag);<br></code></pre></td></tr></table></figure><p>还是走的<code>GetInstance()</code>单例对象的<code>find</code>方法，这也与我们的预期相符，毕竟我们存储时就是将它存在<code>GetInstance()</code>中的一个<code>map</code>集合里。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 是否已经注入过了</span><br><span class="hljs-built_in">bool</span> isRegistered&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag&#125;) =&gt; _singl.containsKey(_getKey(S, tag));<br><br>S find&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag&#125;) &#123;<br>    <span class="hljs-comment">// 构建key</span><br>    <span class="hljs-keyword">final</span> key = _getKey(S, tag);<br>    <span class="hljs-comment">// 如果已经注入过</span><br>    <span class="hljs-keyword">if</span> (isRegistered&lt;S&gt;(tag: tag)) &#123;<br>      <span class="hljs-comment">// 取出factory</span><br>      <span class="hljs-keyword">final</span> dep = _singl[key];<br>      <span class="hljs-comment">// 初始化依赖</span><br>      <span class="hljs-keyword">final</span> i = _initDependencies&lt;S&gt;(name: tag);<br>      <span class="hljs-comment">// 直接通过getDependency获取实例</span><br>      <span class="hljs-keyword">return</span> i ?? dep.getDependency() <span class="hljs-keyword">as</span> S;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 未注册过直接抛异常</span><br>      <span class="hljs-keyword">throw</span> ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里查询实际上也是直接构建<code>key</code>，然后从集合中取出对应的<code>factory</code>，从而获取到实例。注意这里在取出<code>factory</code>之后，还会调用一次<code>_initDependencies</code>，当它返回值为空时，才通过<code>fatory</code>来获取依赖对象。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="dart hljs">S? _initDependencies&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> name&#125;) &#123;<br>    <span class="hljs-comment">// 构建key</span><br>    <span class="hljs-keyword">final</span> key = _getKey(S, name);<br>    <span class="hljs-comment">// 是否初始化过，默认是false</span><br>    <span class="hljs-keyword">final</span> isInit = _singl[key]!.isInit;<br>    S? i;<br>    <span class="hljs-keyword">if</span> (!isInit) &#123;<br>      <span class="hljs-comment">// 未初始化过的，如果是Controller，则初始化一次</span><br>      i = _startController&lt;S&gt;(tag: name);<br>      <span class="hljs-keyword">if</span> (_singl[key]!.isSingleton!) &#123;<br>        <span class="hljs-comment">// 只有单例对象才有初始化</span><br>        _singl[key]!.isInit = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (Get.smartManagement != SmartManagement.onlyBuilder) &#123;<br>          <span class="hljs-comment">// 构建依赖关系</span><br>          RouterReportManager.reportDependencyLinkedToRoute(_getKey(S, name));<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>在初始化依赖中，会做两件事：一是对<code>controller</code>初始化，一是建立与路由的关联。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="dart hljs">S _startController&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag&#125;) &#123;<br>    <span class="hljs-keyword">final</span> key = _getKey(S, tag);<br>    <span class="hljs-comment">// 获取实例</span><br>    <span class="hljs-keyword">final</span> i = _singl[key]!.getDependency() <span class="hljs-keyword">as</span> S;<br>    <span class="hljs-comment">// 一般我们用的GetController就是这个类型的子类</span><br>    <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">is</span> GetLifeCycleBase) &#123;<br>      <span class="hljs-comment">// 调用它的onStart</span><br>      i.onStart();<br>      <span class="hljs-keyword">if</span> (tag == <span class="hljs-keyword">null</span>) &#123;<br>        Get.log(<span class="hljs-string">&#x27;Instance &quot;<span class="hljs-subst">$S</span>&quot; has been initialized&#x27;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        Get.log(<span class="hljs-string">&#x27;Instance &quot;<span class="hljs-subst">$S</span>&quot; with tag &quot;<span class="hljs-subst">$tag</span>&quot; has been initialized&#x27;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 非单例对象会加入到当前路由的_routesByCreate集合中</span><br>      <span class="hljs-keyword">if</span> (!_singl[key]!.isSingleton!) &#123;<br>        RouterReportManager.appendRouteByCreate(i);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> appendRouteByCreate(GetLifeCycleBase i) &#123;<br>    _routesByCreate[_current] ??= HashSet&lt;<span class="hljs-built_in">Function</span>&gt;();<br>    <span class="hljs-comment">// 将controller的onDelete加入到当前路由的集合中</span><br>    _routesByCreate[_current]!.add(i.onDelete);<br>&#125;<br></code></pre></td></tr></table></figure><p>这一步的初始化路由中，会先获取到依赖对象<code>Controller</code>，然后执行它的<code>onStart</code>方法，如果是非单例对象将其<code>onDelete</code>加入到当前路由的集合中，从而跟随路由的生命周期而执行。单例对象会在销毁时<code>onDelete</code>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 将依赖对象的key添加到当前路由的keys集合中，方便跟随路由生命周期变化</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> reportDependencyLinkedToRoute(<span class="hljs-built_in">String</span> depedencyKey) &#123;<br>    <span class="hljs-keyword">if</span> (_current == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (_routesKey.containsKey(_current)) &#123;<br>      _routesKey[_current!]!.add(depedencyKey);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      _routesKey[_current] = &lt;<span class="hljs-built_in">String</span>&gt;[depedencyKey];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取的整体逻辑也很简单，就是根据<code>key</code>获取到<code>factory</code>，然后开始构建对象。对于标记为单例的依赖，会在初始化时做一些操作。如果是<code>Controller</code>，则会调用它的<code>onStart</code>，并且将其<code>onDelete</code>加入到当前路由的<code>_routesByCreate</code>中。然后就是同时，也会将依赖对象的<code>key</code>加入到当前路由的<code>_routesKey</code>中。这也是依赖管理能够智能的处理依赖对象的生命周期的关键。<strong>这也就是说，如果用到了<code>GetX</code>的依赖注入，就需要用它的路由管理，否则注入的对象一直在内存中无法释放。</strong></p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><code>GetX</code>的路由管理，实际上也就是在最顶层通过<code>GetMaterialApp</code>来替代<code>MaterialApp</code>，看起来是<code>GetX</code>实现的，但当我们点到内部逻辑的时候，就发现它其实就是对<code>MaterialApp</code>做了一层包装：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetMaterialApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) =&gt; GetBuilder&lt;GetMaterialController&gt;(<br>        ...<br>        builder: (_) =&gt; routerDelegate != <span class="hljs-keyword">null</span><br>            ? MaterialApp.router( <span class="hljs-comment">// 实际上还是用了MaterialApp</span><br>                ...<br>            : MaterialApp( <span class="hljs-comment">// 实际上还是用了MaterialApp</span><br>                ...<br>                navigatorObservers: (navigatorObservers == <span class="hljs-keyword">null</span><br>                    ? &lt;NavigatorObserver&gt;[<br>                        <span class="hljs-comment">// 添加了一个GetObserver</span><br>                        GetObserver(routingCallback, Get.routing)<br>                      ]<br>                    : &lt;NavigatorObserver&gt;[<br>                        GetObserver(routingCallback, Get.routing)<br>                      ]<br>                  ..addAll(navigatorObservers!))<br>              ),<br>              ...<br> &#125;<br></code></pre></td></tr></table></figure><p>可以看到，最终做路由的还是<code>MaterialApp</code>，只是<code>GetX</code>对他做了一些封装而已。而关于生命周期部分的，实际就在<code>GetObserver</code>中。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NavigatorObserver</span> </span>&#123;<br>  ...<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> didPop(Route route, Route? previousRoute) &#123;<br>    <span class="hljs-keyword">super</span>.didPop(route, previousRoute);<br>    ...<br>    <span class="hljs-comment">// 将当前route改为上一个界面</span><br>    <span class="hljs-keyword">if</span> (previousRoute != <span class="hljs-keyword">null</span>) &#123;<br>      RouterReportManager.reportCurrentRoute(previousRoute);<br>    &#125;<br>    ...<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> didPush(Route route, Route? previousRoute) &#123;<br>    <span class="hljs-keyword">super</span>.didPush(route, previousRoute);<br>    <span class="hljs-comment">// 将当前route改为新的界面</span><br>    RouterReportManager.reportCurrentRoute(route);<br>    ...<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> didRemove(Route route, Route? previousRoute) &#123;<br>    <span class="hljs-keyword">super</span>.didRemove(route, previousRoute);<br>    ...<br>    <span class="hljs-comment">// 界面被移除</span><br>    <span class="hljs-keyword">if</span> (route <span class="hljs-keyword">is</span> GetPageRoute) &#123;<br>      RouterReportManager.reportRouteWillDispose(route);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> didReplace(&#123;Route? newRoute, Route? oldRoute&#125;) &#123;<br>    <span class="hljs-keyword">super</span>.didReplace(newRoute: newRoute, oldRoute: oldRoute);<br>    ...<br>    <span class="hljs-comment">// 设置当前路由为新路由</span><br>    <span class="hljs-keyword">if</span> (newRoute != <span class="hljs-keyword">null</span>) &#123;<br>      RouterReportManager.reportCurrentRoute(newRoute);<br>    &#125;<br>    <span class="hljs-comment">// 老界面被移除</span><br>    <span class="hljs-keyword">if</span> (oldRoute <span class="hljs-keyword">is</span> GetPageRoute) &#123;<br>      RouterReportManager.reportRouteWillDispose(oldRoute);<br>    &#125;<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键的就是这几个路由的回调方法，对应了路由的生命周期。主要就是在路由界面切换时，设置<code>RouterReportManager</code>中的<code>current</code>为新路由，当界面移除时，通过<code>reportRouteWillDispose</code>来通知做回收操作。那么回到<code>RouterReportManager</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouterReportManager</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 存储在当前路由中find的依赖对象的key</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;Route?, <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt; _routesKey = &#123;&#125;;<br>  <span class="hljs-comment">// 存储在当前路由中find的Controller类型的依赖对象的onDelete方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;Route?, HashSet&lt;<span class="hljs-built_in">Function</span>&gt;&gt; _routesByCreate = &#123;&#125;;<br>    <br>  <span class="hljs-comment">// 设置当前路由，在界面发生变化时会调用  </span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> reportCurrentRoute(Route newRoute) &#123;<br>    _current = newRoute;<br>  &#125;<br>    <br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> reportRouteWillDispose(Route disposed) &#123;<br>    <span class="hljs-comment">// 将被移除路由中的key添加到集合中</span><br>    <span class="hljs-keyword">final</span> keysToRemove = &lt;<span class="hljs-built_in">String</span>&gt;[];<br>    _routesKey[disposed]?.forEach(keysToRemove.add);<br><br>    <span class="hljs-comment">// 遍历路由中的controller的onDelete方法，并执行</span><br>    <span class="hljs-keyword">if</span> (_routesByCreate.containsKey(disposed)) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> onClose <span class="hljs-keyword">in</span> _routesByCreate[disposed]!) &#123;<br>        onClose();<br>      &#125;<br>      <span class="hljs-comment">// 清空数据</span><br>      _routesByCreate[disposed]!.clear();<br>      _routesByCreate.remove(disposed);<br>    &#125;<br>    <span class="hljs-comment">// 将key对应的Factory标记为dirty</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> element <span class="hljs-keyword">in</span> keysToRemove) &#123;<br>      GetInstance().markAsDirty(key: element);<br>      <span class="hljs-comment">// 这里应该移除的，但是并没有移除，而是注释掉了</span><br>      <span class="hljs-comment">//_routesKey.remove(element);</span><br>    &#125;<br>    keysToRemove.clear();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它内部有三个静态变量，一个是<code>current</code>指向当前路由，一个是<code>_routesKey</code>内部存储的是每个路由中所使用的依赖对象的<code>key</code>（<code>find</code>）的时候加入的，一个是<code>_routesByCreate</code>存放的是每个路由中的所使用的<code>Controller</code>的<code>onDelete</code>方法。</p><p>当界面被移除时，就会通过<code>reportRouteWillDispose</code>方法来触发<code>onDelete</code>和移除依赖。<strong>这里并没有直接移除，而只是将其标记为dirty</strong>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetInstance</span> </span>&#123;<br>  <span class="hljs-keyword">void</span> markAsDirty&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag, <span class="hljs-built_in">String?</span> key&#125;) &#123;<br>    <span class="hljs-keyword">final</span> newKey = key ?? _getKey(S, tag);<br>    <span class="hljs-keyword">if</span> (_singl.containsKey(newKey)) &#123;<br>      <span class="hljs-keyword">final</span> dep = _singl[newKey];<br>      <span class="hljs-comment">// 只有未标记为permanent的才会标记为dirty</span><br>      <span class="hljs-keyword">if</span> (dep != <span class="hljs-keyword">null</span> &amp;&amp; !dep.permanent) &#123;<br>        dep.isDirty = <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>真正移除的逻辑实际上是否发生在<code>PageRoute</code>的回调中：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetPageRoute</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PageRoute</span>&lt;<span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">GetPageRouteTransitionMixin</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">PageRouteReportMixin</span> </span>&#123;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">mixin</span> PageRouteReportMixin&lt;T&gt; <span class="hljs-keyword">on</span> Route&lt;T&gt; &#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> install() &#123;<br>    <span class="hljs-keyword">super</span>.install();<br>    <span class="hljs-comment">// 设置当前路由</span><br>    RouterReportManager.reportCurrentRoute(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">super</span>.dispose();<br>    <span class="hljs-comment">// 路由dispose时的回调</span><br>    RouterReportManager.reportRouteDispose(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>GetPageRoute</code>中混入了一个<code>PageRouteReportMixin</code>类，然后在其对应的声明周期中做了一些处理，主要是在<code>dispose</code>的时候调用了<code>reportRouteDispose</code>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouterReportManager</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 这是在GetObserver中调用的，注意有个will</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> reportRouteWillDispose(Route disposed) &#123;<br>    ...<br>  &#125;<br>  <span class="hljs-comment">// 这是在GetPageRoute中调用的，真正dispose的时候 </span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> reportRouteDispose(Route disposed) &#123;<br>    <span class="hljs-keyword">if</span> (Get.smartManagement != SmartManagement.onlyBuilder) &#123;<br>      _removeDependencyByRoute(disposed);<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _removeDependencyByRoute(Route routeName) &#123;<br>    <span class="hljs-keyword">final</span> keysToRemove = &lt;<span class="hljs-built_in">String</span>&gt;[];<br>    <span class="hljs-comment">// 将待移除的路由对应的key添加到集合中</span><br>    _routesKey[routeName]?.forEach(keysToRemove.add);<br><br>    <span class="hljs-comment">// 调用非单例的controller的onDelete</span><br>    <span class="hljs-keyword">if</span> (_routesByCreate.containsKey(routeName)) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> onClose <span class="hljs-keyword">in</span> _routesByCreate[routeName]!) &#123;<br>        onClose();<br>      &#125;<br>      _routesByCreate[routeName]!.clear();<br>      _routesByCreate.remove(routeName);<br>    &#125;<br>    <span class="hljs-comment">// 遍历key</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> element <span class="hljs-keyword">in</span> keysToRemove) &#123;<br>      <span class="hljs-comment">// 删除值</span><br>      <span class="hljs-keyword">final</span> value = GetInstance().delete(key: element);<br>      <span class="hljs-keyword">if</span> (value) &#123;<br>        <span class="hljs-comment">// 删除之后再从路由对应的集合中移除掉这个key</span><br>        _routesKey[routeName]?.remove(element);<br>      &#125;<br>    &#125;<br>    keysToRemove.clear();<br>  &#125;<br></code></pre></td></tr></table></figure><p>从这里也就可以看出，想要实现依赖的生命周期管理，即当路由移除时，同时销毁该路由上使用的依赖对象，是要依赖<code>GetX</code>的路由管理的，也就是需要有对应的<code>GetObserver</code>和<code>GetPageRoute</code>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetInstance</span> </span>&#123;<br><br>  <span class="hljs-built_in">bool</span> delete&lt;S&gt;(&#123;<span class="hljs-built_in">String?</span> tag, <span class="hljs-built_in">String?</span> key, <span class="hljs-built_in">bool</span> force = <span class="hljs-keyword">false</span>&#125;) &#123;<br>    <span class="hljs-keyword">final</span> newKey = key ?? _getKey(S, tag);<br>    <span class="hljs-comment">// 获取到对应的factory</span><br>    <span class="hljs-keyword">final</span> dep = _singl[newKey];<br><br>    <span class="hljs-keyword">final</span> _InstanceBuilderFactory builder;<br>    <span class="hljs-comment">// 其实在删除之前，已经被标记为dirty了</span><br>    <span class="hljs-keyword">if</span> (dep.isDirty) &#123;<br>      <span class="hljs-comment">// 如果在标记为dirty之后，再去put的时候，就会</span><br>      <span class="hljs-comment">// 新创建一个factory，然后它的lateRemove指向老的factory</span><br>      builder = dep.lateRemove ?? dep;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      builder = dep;<br>    &#125;<br>    <span class="hljs-comment">// 标记为permanent，是不会被删除的，除非强制删除</span><br>    <span class="hljs-keyword">if</span> (builder.permanent &amp;&amp; !force) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取依赖的实例</span><br>    <span class="hljs-keyword">final</span> i = builder.dependency;<br>    <span class="hljs-comment">// GetxServier也不会被删除</span><br>    <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">is</span> GetxServiceMixin &amp;&amp; !force) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// GetController的onDelete又被调用一次</span><br>    <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">is</span> GetLifeCycleBase) &#123;<br>      i.onDelete();<br>    &#125;<br>    <span class="hljs-comment">// 如果标记为finix，则清除依赖，恢复到初始状态，并不会直接移除掉</span><br>    <span class="hljs-keyword">if</span> (builder.fenix) &#123;<br>      builder.dependency = <span class="hljs-keyword">null</span>;<br>      builder.isInit = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 在willDispose的时候被标记为dirty，随后又put了一次，就会出现这种情况</span><br>      <span class="hljs-keyword">if</span> (dep.lateRemove != <span class="hljs-keyword">null</span>) &#123;<br>        dep.lateRemove = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 真正的移除</span><br>        _singl.remove(newKey);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面说过，如果要使用依赖注入，就需要同时使用它的路由管理，这是为了能让他正常处理生命周期问题。当然了，如果确实是不想使用它的依赖管理，我们也可以自己定义一个<code>NavigatorObserver</code>，然后在这里面手动处理<code>RouterReportManager</code>。</p><p>总结下：<code>put</code>时构建<code>_InstanceBuilderFactory</code>，插入到<code>GetInstance()</code>中的<code>map</code>集合中。然后初次使用时，会将已使用的依赖的<code>key</code>加入到与当前路由相关的集合中，然后如果依赖是<code>Controller</code>也会调用它的<code>onStart</code>，然后当路由销毁时，会遍历<code>key</code>然后将其对应的<code>_InstanceBuilderFactory</code>从<code>GetInstance</code>中移除掉，并且会同步调用<code>Controller</code>的<code>onDelete</code>，从而实现了生命周期的管理。</p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>状态管理方面也是基本上利用的观察者模式，由顶层提供状态，子组件注册监听，当状态发生变换时刷新子组件以响应状态。当然，这里状态并不是由顶层提供的，而是直接利用了它的依赖注入功能，将持有状态的控制器注入到<code>GetInstance</code>中，这样子组件都能通过<code>GetInstance</code>获取了。并且，界面的控制器还能跟随界面进行变化，当界面销毁时同时会删除对应的控制器，非常方便。</p><p>状态管理有两种类型，一种是直接通过<code>GetController</code>，一种是通过<code>obs</code>拓展。</p><h4 id="GetxController"><a href="#GetxController" class="headerlink" title="GetxController"></a>GetxController</h4><p>提供状态的控制器可以使用<code>GetxController</code>，当然本质上使用任何对象都是可以的，使用<code>GetxController</code>是因为它本身有实现了<code>GetLifeCycleBase</code>，能够响应组件的生命周期变化，从而可以在合适的位置执行合适的操作。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetxController</span> </span>&#123;<br>  Color _color = Colors.red;<br><br>  Color <span class="hljs-keyword">get</span> color =&gt; _color;<br>  <span class="hljs-keyword">set</span> color(Color value) &#123;<br>    _color = value;<br>    <span class="hljs-comment">// 通过update通知使用的子组件进行刷新</span><br>    update();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>GetxController</code>的实现也是基于<code>Listenable</code>的，也是允许别的组件注册监听，当状态变化后，需要手动触发监听者的回调。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetxController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DisposableInterface</span></span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">ListenableMixin</span>, <span class="hljs-title">ListNotifierMixin</span> </span>&#123;<br><br>  <span class="hljs-keyword">void</span> update([<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt;? ids, <span class="hljs-built_in">bool</span> condition = <span class="hljs-keyword">true</span>]) &#123;<br>    <span class="hljs-keyword">if</span> (!condition) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果未指定id，则全部刷新</span><br>    <span class="hljs-keyword">if</span> (ids == <span class="hljs-keyword">null</span>) &#123;<br>      refresh();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 否则只刷新对应的id</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> id <span class="hljs-keyword">in</span> ids) &#123;<br>        refreshGroup(id);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通知对应的观察者时，应该直接调用<code>update</code>方法，而不是其他的<code>refresh</code>方法（虽然也是可以的）。从这个方法我们可以看出。<code>GetxController</code>将注册的监听分为了两类，一类是普通的监听者，一类是带<code>id</code>的监听者。</p><p>然后看下它的继承类以及混入类：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 处理生命周期相关部分</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisposableInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetLifeCycle</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-meta">@mustCallSuper</span><br>  <span class="hljs-keyword">void</span> onInit() &#123;<br>    <span class="hljs-keyword">super</span>.onInit();<br>    Get.engine.addPostFrameCallback((_) =&gt; onReady());<br>  &#125;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> onReady() &#123;<br>    <span class="hljs-keyword">super</span>.onReady();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> onClose() &#123;<br>    <span class="hljs-keyword">super</span>.onClose();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 混入了Listenable，可以让我们addListener和removeListener</span><br><span class="hljs-keyword">mixin</span> ListenableMixin <span class="hljs-keyword">implements</span> Listenable &#123;&#125;<br><br><span class="hljs-comment">// 在ListenableMixin的基础上做了别的操作</span><br><span class="hljs-keyword">mixin</span> ListNotifierMixin <span class="hljs-keyword">on</span> ListenableMixin &#123;<br>  <br>  <span class="hljs-comment">// 存储普通的监听者</span><br>  <span class="hljs-built_in">List</span>&lt;GetStateUpdate?&gt;? _updaters = &lt;GetStateUpdate?&gt;[];<br><br>  <span class="hljs-comment">// 存储带id的监听者，key是id，value是一个集合，这个集合内部存的是监听者</span><br>  HashMap&lt;<span class="hljs-built_in">Object?</span>, <span class="hljs-built_in">List</span>&lt;GetStateUpdate&gt;&gt;? _updatersGroupIds =<br>      HashMap&lt;<span class="hljs-built_in">Object?</span>, <span class="hljs-built_in">List</span>&lt;GetStateUpdate&gt;&gt;();<br><br>  <span class="hljs-comment">// 对外暴露的刷新方法</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> refresh() &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    _notifyUpdate();<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> _notifyUpdate() &#123;<br>    <span class="hljs-comment">// 遍历所有的普通监听者，然后进行调用，从而通知他们</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> _updaters!) &#123;<br>      element!();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 通知指定id的监听者</span><br>  <span class="hljs-keyword">void</span> _notifyIdUpdate(<span class="hljs-built_in">Object</span> id) &#123;<br>    <span class="hljs-comment">// 从带id的监听者集合中获取所有的监听者，然后触发通知</span><br>    <span class="hljs-keyword">if</span> (_updatersGroupIds!.containsKey(id)) &#123;<br>      <span class="hljs-keyword">final</span> listGroup = _updatersGroupIds![id]!;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> listGroup) &#123;<br>        item();<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 对外暴露的指定id的刷新方法</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> refreshGroup(<span class="hljs-built_in">Object</span> id) &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    _notifyIdUpdate(id);<br>  &#125;<br><br>  <br><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> notifyChildrens() &#123;<br>    TaskManager.instance.notify(_updaters);<br>  &#125;<br><br>  <br>  <span class="hljs-comment">// 移除</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> removeListener(VoidCallback listener) &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    _updaters!.remove(listener);<br>  &#125;<br><br>  <span class="hljs-comment">// 移除</span><br>  <span class="hljs-keyword">void</span> removeListenerId(<span class="hljs-built_in">Object</span> id, VoidCallback listener) &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    <span class="hljs-keyword">if</span> (_updatersGroupIds!.containsKey(id)) &#123;<br>      _updatersGroupIds![id]!.remove(listener);<br>    &#125;<br>    _updaters!.remove(listener);<br>  &#125;<br><br>  <span class="hljs-comment">// dispose</span><br>  <span class="hljs-meta">@mustCallSuper</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    _updaters = <span class="hljs-keyword">null</span>;<br>    _updatersGroupIds = <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 添加</span><br>  <span class="hljs-meta">@override</span><br>  Disposer addListener(GetStateUpdate listener) &#123;<br>    <span class="hljs-keyword">assert</span>(_debugAssertNotDisposed());<br>    _updaters!.add(listener);<br>    <span class="hljs-keyword">return</span> () =&gt; _updaters!.remove(listener);<br>  &#125;<br><br>  <span class="hljs-comment">// 添加</span><br>  Disposer addListenerId(<span class="hljs-built_in">Object?</span> key, GetStateUpdate listener) &#123;<br>    _updatersGroupIds![key] ??= &lt;GetStateUpdate&gt;[];<br>    _updatersGroupIds![key]!.add(listener);<br>    <span class="hljs-keyword">return</span> () =&gt; _updatersGroupIds![key]!.remove(listener);<br>  &#125;<br><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">void</span> disposeId(<span class="hljs-built_in">Object</span> id) &#123;<br>    _updatersGroupIds!.remove(id);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是<code>GetxController</code>将注册的观察者分为了两类，一种是普通的观察者，一种是带id的观察者。这样，当状态发生变化时，可以直接通过<code>update()</code>通知到所有的普通观察者状态发生了变化，也可以通过<code>update([id1, id2])</code>通知指定<code>id</code>的通知者进行刷新。</p><p>这对于局部刷新还是比较实用的，例如在<code>controller</code>中有两个状态<code>A</code>和<code>B</code>，然后组件<code>WidgetA</code>使用状态<code>A</code>，组件<code>WidgetB</code>使用状态<code>B</code>，这样这两个组件在注册监听的时候，就可以指定不同的<code>id</code>进行注册，当状态<code>A</code>发生变化时，就可以只通知A对应的<code>id</code>的观察者。</p><p>状态提供上就直接继承自<code>GetxController</code>即可，使用上在组件中可以通过<code>GetBuilder</code>来注册监听：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 通过泛型指定引用的controller，使用前必须要先put</span><br>GetBuilder&lt;CircleController&gt;(<br>  <span class="hljs-comment">// 必填参数builder构建组件</span><br>  builder: (controller) =&gt; Container(<br>    <span class="hljs-comment">// 使用控制器中的状态</span><br>    width: controller.size,<br>    height: controller.size,<br>    color: controller.color,<br>    child: Center(<br>      child: ElevatedButton(<br>        onPressed: ()  &#123;&#125;,<br>        child: Text(<span class="hljs-string">&#x27;Hello&#x27;</span>),<br>      ),<br>    ),<br>  ),<br>);<br></code></pre></td></tr></table></figure><p>使用上也比较简单，直接通过<code>GetBuilder</code>包裹住需要使用状态的组件即可，当状态发生变化时（触发了<code>update</code>方法），就会通知到这里来进行刷新。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">const</span> GetBuilder(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">this</span>.init,<span class="hljs-comment">// 初始值，默认null</span><br>    <span class="hljs-keyword">this</span>.global = <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-keyword">this</span>.autoRemove = <span class="hljs-keyword">true</span>,<span class="hljs-comment">// 自动移除依赖对象</span><br>    <span class="hljs-keyword">this</span>.assignId = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.initState, <span class="hljs-comment">// 生命周期回调</span><br>    <span class="hljs-keyword">this</span>.filter,<span class="hljs-comment">// 过滤器，用于过滤状态的</span><br>    <span class="hljs-keyword">this</span>.tag,<br>    <span class="hljs-keyword">this</span>.dispose, <span class="hljs-comment">// 生命周期回调</span><br>    <span class="hljs-keyword">this</span>.id,<span class="hljs-comment">// 分组的id</span><br>    <span class="hljs-keyword">this</span>.didChangeDependencies, <span class="hljs-comment">// 生命周期回调</span><br>    <span class="hljs-keyword">this</span>.didUpdateWidget, <span class="hljs-comment">// 生命周期回调</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>构造方法参数较多，必选参数是<code>builder</code>，用于构建组件树的。此外，如果需要感应生命周期的变化，可以传入对应的生命周期的回调，另外<code>filter</code>也是比较重要的。一般情况下，我们会传入<code>builder</code>和<code>filter</code>两个参数。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetBuilder</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetxController</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  ...<br>  <span class="hljs-meta">@override</span><br>  GetBuilderState&lt;T&gt; createState() =&gt; GetBuilderState&lt;T&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上各个状态管理的库原理都是一样的，将依赖状态的组件通过<code>StatefulWidget</code>包裹，然后通过观察者模式观测状态的变化，当状态发生变化时，通过<code>setState</code>触发重建。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetBuilderState</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetxController</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">GetBuilder</span>&lt;<span class="hljs-title">T</span>&gt;&gt;</span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">GetStateUpdaterMixin</span> </span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// 参数回调</span><br>    widget.initState?.call(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 是否有put过这个控制器</span><br>    <span class="hljs-keyword">var</span> isRegistered = GetInstance().isRegistered&lt;T&gt;(tag: widget.tag);<br>    <span class="hljs-comment">// 是否是全局控制器，默认是true</span><br>    <span class="hljs-keyword">if</span> (widget.global) &#123;<br>      <span class="hljs-keyword">if</span> (isRegistered) &#123;<br>        <span class="hljs-comment">// 是否初始化过对象，即put时的参数`_singleton`是否为false</span><br>        <span class="hljs-comment">// 即这个对象是否是GetBuilder创建出来的</span><br>        <span class="hljs-keyword">if</span> (GetInstance().isPrepared&lt;T&gt;(tag: widget.tag)) &#123;<br>          _isCreator = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          _isCreator = <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 查询控制器</span><br>        controller = GetInstance().find&lt;T&gt;(tag: widget.tag);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 未put的话，使用init提供的依赖对象，然后注入到依赖注入中</span><br>        controller = widget.init;<br>        _isCreator = <span class="hljs-keyword">true</span>;<br>        GetInstance().put&lt;T&gt;(controller!, tag: widget.tag);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 非全局对象直接使用参数init，并且不通过依赖注入进行管理</span><br>      controller = widget.init;<br>      _isCreator = <span class="hljs-keyword">true</span>;<br>      controller?.onStart();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (widget.filter != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// 通过filter，对controller进行计算，从而得出一个值</span><br>      <span class="hljs-comment">// 当controller中的状态发生变化时，可以通过对比前后的filter是否</span><br>      <span class="hljs-comment">// 一致来决定是否刷新，类似于Provider中的select</span><br>      _filter = widget.filter!(controller!);<br>    &#125;<br>   <span class="hljs-comment">// 注册监听</span><br>    _subscribeToController();<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> _subscribeToController() &#123;<br>    _remove?.call();<br>    _remove = (widget.id == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 无id，直接注册listener</span><br>        ? controller?.addListener(<br>            <span class="hljs-comment">// 回调方法是`filterUpdate`或者`getUpdate`</span><br>            _filter != <span class="hljs-keyword">null</span> ? _filterUpdate : getUpdate,<br>          )<br>        <span class="hljs-comment">// 有id，注册带id的listener</span><br>        : controller?.addListenerId(<br>            widget.id,<br>            _filter != <span class="hljs-keyword">null</span> ? _filterUpdate : getUpdate,<br>          );<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> _filterUpdate() &#123;<br>    <span class="hljs-comment">// 根据新的controller计算filter值</span><br>    <span class="hljs-keyword">var</span> newFilter = widget.filter!(controller!);<br>    <span class="hljs-comment">// 只有不一致才会刷新</span><br>    <span class="hljs-keyword">if</span> (newFilter != _filter) &#123;<br>      _filter = newFilter;<br>      getUpdate();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">super</span>.dispose();<br>    <span class="hljs-comment">// 回调生命周期</span><br>    widget.dispose?.call(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 如果通过create创建的对象需要删除，put时singleton为false</span><br>    <span class="hljs-keyword">if</span> (_isCreator! || widget.assignId) &#123;<br>      <span class="hljs-keyword">if</span> (widget.autoRemove &amp;&amp; GetInstance().isRegistered&lt;T&gt;(tag: widget.tag)) &#123;<br>        GetInstance().delete&lt;T&gt;(tag: widget.tag);<br>      &#125;<br>    &#125;<br>   <span class="hljs-comment">// 移除监听</span><br>    _remove?.call();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> didChangeDependencies() &#123;<br>    <span class="hljs-keyword">super</span>.didChangeDependencies();<br>    <span class="hljs-comment">// 回调生命周期</span><br>    widget.didChangeDependencies?.call(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> didUpdateWidget(GetBuilder oldWidget) &#123;<br>    <span class="hljs-keyword">super</span>.didUpdateWidget(oldWidget <span class="hljs-keyword">as</span> GetBuilder&lt;T&gt;);<br>    <span class="hljs-comment">// id不一致了则重新注册监听</span><br>    <span class="hljs-keyword">if</span> (oldWidget.id != widget.id) &#123;<br>      _subscribeToController();<br>    &#125;<br>    <span class="hljs-comment">// 回调生命周期</span><br>    widget.didUpdateWidget?.call(oldWidget, <span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> widget.builder(controller!);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>GetBuilderState</code>中，主要做了生命周期的回调，以及在<code>initState</code>的时候向<code>Controller</code>中注册监听，并且在<code>dispose</code>的时候移除监听。然后就是依赖注入，它会在<code>initState</code>的时候主动帮我们查询到对应的依赖对象，并且在<code>dispose</code>的时候删除依赖对象（只有非单例对象才会删除，因为说明这个对象是在<code>GetBuilder</code>中<code>find</code>时新创建的，所以需要删除掉）。</p><p>当传入了<code>filter</code>后，刷新是通过<code>_filterUpdate</code>方法触发的，它会根据<code>filter</code>来计算<code>controller</code>，只有计算后的结果与之前不一致，说明<code>controller</code>中有我们关注的字段发生了变化，此时才会触发刷新。刷新方式是通过<code>getUpdate</code>进行刷新的，我们看下实现：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">mixin</span> GetStateUpdaterMixin&lt;T <span class="hljs-keyword">extends</span> StatefulWidget&gt; <span class="hljs-keyword">on</span> State&lt;T&gt; &#123;<br>  <span class="hljs-keyword">void</span> getUpdate() &#123;<br>    <span class="hljs-keyword">if</span> (mounted) setState(() &#123;&#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理还是非常简单，直接通过<code>setState</code>进行刷新。实际上在<code>GetxController</code>中，也可以通过指定<code>id</code>的注册监听器的方式实现局部刷新，这样在状态变化时就能只通知对应的id的观察者即可，这种性能比通过<code>filter</code>实现更高一些，因为它是从源头上控制的，而<code>filter</code>是在已经触发的回调中控制的。</p><h4 id="obs、obx"><a href="#obs、obx" class="headerlink" title="obs、obx"></a>obs、obx</h4><p>对于需要更加精准的控制状态的场景下，使用<code>obs</code>拓展，将状态本身封装成一个可观察的数据类型。这样子组件就不需要直接对<code>GetxController</code>进行监听，而是可以更加精准的对状态本身进行监听。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetxController</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> txt = <span class="hljs-string">&#x27;Hello&#x27;</span>.obs;<br>&#125;<br><br>ElevatedButton(<br>   onPressed: () &#123;<br>      controller.txt.value = <span class="hljs-string">&#x27;newTxt&#x27;</span>;<br>   &#125;,<br>   child: Obx(() =&gt; Text(controller.txt.value)),<br>)<br></code></pre></td></tr></table></figure><p>可以看到，使用方式上更加简便了。直接声明的对象通过<code>obs</code>拓展，使用的组件用<code>Obx</code>进行包裹即可，唯一的缺陷可能就是需要我们自己去<code>find</code>对应的控制器了（也可以使用<code>GetView</code>来帮我们获取）。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 对任意类型进行拓展</span><br><span class="hljs-keyword">extension</span> RxT&lt;T&gt; <span class="hljs-keyword">on</span> T &#123;<br>  Rx&lt;T&gt; <span class="hljs-keyword">get</span> obs =&gt; Rx&lt;T&gt;(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，在前面还有很对<code>RxInt</code>和<code>RxBool</code>等拓展，是针对于基本属性的，使得我们可以不通过<code>.value</code>获取值，而是可以直接使用。这里我们看下对于通用的数据类型的拓展，实际就是将对象包装在了<code>Rx</code>中。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rx</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">_RxImpl</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  Rx(T initial) : <span class="hljs-keyword">super</span>(initial);<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">dynamic</span> toJson() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> (value <span class="hljs-keyword">as</span> <span class="hljs-built_in">dynamic</span>)?.toJson();<br>    &#125; <span class="hljs-keyword">on</span> Exception <span class="hljs-keyword">catch</span> (_) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;<span class="hljs-subst">$T</span> has not method [toJson]&#x27;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里没啥看的，就重写了<code>toJson</code>的方法，具体就不在细看了，总之就是在<code>_RxImpl</code>也是实现了一套基于观察者模式的代码，使得可以注册和移除监听。然后就是使用方面，直接通过<code>Obx</code>将用到状态的部分进行包裹即可。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obx</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ObxWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> WidgetCallback builder;<br>  <span class="hljs-keyword">const</span> Obx(<span class="hljs-keyword">this</span>.builder, &#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br>  <span class="hljs-meta">@override</span><br>  Widget build() =&gt; builder();<br>&#125;<br><br><span class="hljs-comment">// 可以看到，本质上还是一个StatefulWidget</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObxWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> ObxWidget(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  ObxState createState() =&gt; ObxState();<br><br>  <span class="hljs-meta">@protected</span><br>  Widget build();<br>&#125;<br><br><span class="hljs-comment">// 状态管理</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObxState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">ObxWidget</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 观察者</span><br>  <span class="hljs-keyword">final</span> _observer = RxNotifier();<br>  <span class="hljs-keyword">late</span> StreamSubscription subs;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// 注册监听</span><br>    subs = _observer.listen(_updateTree, cancelOnError: <span class="hljs-keyword">false</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 触发刷新，还是通过setState完成的</span><br>  <span class="hljs-keyword">void</span> _updateTree(_) &#123;<br>    <span class="hljs-keyword">if</span> (mounted) &#123;<br>      setState(() &#123;&#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    subs.cancel();<br>    _observer.close();<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) =&gt;<br>      RxInterface.notifyChildren(_observer, widget.build);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Obx</code>本质上就是一个有状态组件<code>StatefulWidget</code>，然后它在内部创建了一个观察者并设置了对应的回调方法，当触发回调时，会通过<code>setState</code>来触发刷新。到这里并没有发现与我们创建的<code>Rx</code>对象有什么关联，因为它的关联是发生在<code>build</code>的时候，<code>RxInterface.notifyChildren</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RxInterface</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// _observer</span><br>  <span class="hljs-keyword">static</span> RxInterface? proxy;<br><br>  <span class="hljs-keyword">static</span> T notifyChildren&lt;T&gt;(RxNotifier observer, ValueGetter&lt;T&gt; builder) &#123;<br>    <span class="hljs-keyword">final</span> oldObserver = RxInterface.proxy;<br>    <span class="hljs-comment">// 进行赋值</span><br>    RxInterface.proxy = observer;<br>    <span class="hljs-comment">// result实际是一个widget</span><br>    <span class="hljs-keyword">final</span> result = builder();<br>    <span class="hljs-comment">// 如果不能更新，直接抛异常</span><br>    <span class="hljs-keyword">if</span> (!observer.canUpdate) &#123;<br>      RxInterface.proxy = oldObserver;<br>      <span class="hljs-keyword">throw</span> ...;<br>    &#125;<br>    <span class="hljs-comment">// 替换回来</span><br>    RxInterface.proxy = oldObserver;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到，在构建的组件的时候，会先通过<code>RxInterface</code>将它的静态属性<code>proxy</code>替换成我们的<code>Obx</code>中创建的<code>_observer</code>，然后执行<code>build</code>进行构建，然后在判断是否能够更新（是否用到了<code>Rx</code>对象），最后再将<code>proxy</code>替换回来。</p><p>也就是说实际上到这里我们还是没有将<code>_observer</code>与<code>Rx</code>对象进行关联的，但是在<code>notifyChildren</code>这个方法中的流程：替换<code>proxy</code>-&gt;<code>build</code>-&gt;检测是否可更新-&gt;替换回老的<code>proxy</code>，其实就说明了关联的过程肯定是在<code>build</code>中的，不然不会再执行完<code>build</code>后就去检测是否能更新的。</p><p>而<code>build</code>是我们构建<code>Obx</code>的时候传入的用于构建<code>widget</code>的一个函数，本身也没做什么处于，唯一和<code>Rx</code>相关的就是用到了<code>Rx</code>的值，<code>Obx(() =&gt; Text(controller.txt.value)),</code>也就是它的<code>value</code>属性。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// Rx的实现类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_RxImpl</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">RxNotifier</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">with</span> <span class="hljs-title">RxObjectMixin</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  ...<br>&#125;<br><br><span class="hljs-comment">// 混入了NotifyManager</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RxNotifier</span>&lt;<span class="hljs-title">T</span>&gt; = <span class="hljs-title">RxInterface</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">with</span> <span class="hljs-title">NotifyManager</span>&lt;<span class="hljs-title">T</span>&gt;;</span><br><span class="hljs-class"></span><br><span class="hljs-class">// 实际用于观察者模式的<span class="hljs-title">GetStream</span>在这里</span><br><span class="hljs-class"><span class="hljs-title">mixin</span> <span class="hljs-title">NotifyManager</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  GetStream&lt;T&gt; subject = GetStream&lt;T&gt;();<br>  ...<br>&#125;<br><br><span class="hljs-comment">// value是在这个混入类中引入的</span><br><span class="hljs-keyword">mixin</span> RxObjectMixin&lt;T&gt; <span class="hljs-keyword">on</span> NotifyManager&lt;T&gt; &#123;<br>  <span class="hljs-comment">// value值</span><br>  <span class="hljs-keyword">late</span> T _value;<br>  <span class="hljs-comment">// 对应的get方法  </span><br>  T <span class="hljs-keyword">get</span> value &#123;<br>    <span class="hljs-comment">// 此时的proxy正是我们Obx中的_observer</span><br>    RxInterface.proxy?.addListener(subject);<br>    <span class="hljs-keyword">return</span> _value;<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是当我们构建<code>Obx</code>组件的时候，会先临时将<code>RxInterface</code>的静态属性<code>proxy</code>替换成<code>Obx</code>内部的<code>_observer</code>，然后在构建时会用到<code>Rx.value</code>，而在<code>get value</code>时会将当前的<code>Rx</code>对象的<code>subject</code>与静态的<code>proxy</code>进行关联，从而实现了它们之间的监听关系。</p><p>因此在构建完成之后，就可以检测是否能够更新（是否与<code>Rx</code>建立了联系），不能更新直接抛异常，也就是说<code>Obx</code>组件必须要在内部用到<code>Rx</code>属性。</p><p>总结：绕的比较多，不过整体来说两种方式的原理都是一样的。首先将使用状态的组件用<code>StatelessWidget</code>包一层，然后与状态进行关联，当状态发生变化时，直接<code>setState</code>触发局部组件的刷新。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>Getx</code>使用它的依赖注入功能提供状态，子组件通过<code>StatelessWidget</code>包裹住使用状态的组件，然后向状态注册监听，当监听到变化后使用<code>setState</code>触发刷新。（<code>Provider</code>使用<code>InheritedWidget</code>提供状态并监听状态，状态变化后通知到依赖的子组件进行更新，并不是子组件直接监听状态）。</li><li><code>Getx</code>依赖注入需要依赖它的路由管理，否则无法及时移除不需要的注入对象。当然也可以自定义<code>NavigatorObserver</code>来手动感知界面生命周期，从而处理不需要的注入对象。</li></ol></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Fri Dec 20 2024 19:37:03 GMT+0800");let n="Fri Dec 20 2024 19:37:03 GMT+0800";n="2025-11-08 18:25:34 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Flutter/" class="post-footer-category">#&nbsp;Flutter</a> <a href="/tags/Flutter/" class="post-footer-tag">#&nbsp;Flutter</a></div><div class="nav"><div class="nav-item-prev"><a href="/2025/01/01/flutter-animation/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">Flutter动画</div></div></a></div><div class="nav-item-next"><a href="/2024/11/15/flutter-provider-source/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Provider原理分析</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" class="toc-link"><span class="toc-text">依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E6%B3%A8%E5%85%A5" class="toc-link"><span class="toc-text">注入</span></a></li><li class="toc-item toc-level-4"><a href="#%E8%8E%B7%E5%8F%96" class="toc-link"><span class="toc-text">获取</span></a></li><li class="toc-item toc-level-4"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="toc-link"><span class="toc-text">生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86" class="toc-link"><span class="toc-text">状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#GetxController" class="toc-link"><span class="toc-text">GetxController</span></a></li><li class="toc-item toc-level-4"><a href="#obs%E3%80%81obx" class="toc-link"><span class="toc-text">obs、obx</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2025-01-01</div><a href="/2025/01/01/flutter-animation/"><div class="recent-posts-item-content">Flutter动画</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-09-10</div><a href="/2024/09/10/flutter-state/"><div class="recent-posts-item-content">Flutter状态管理</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-08-16</div><a href="/2024/08/16/flutter-canvas/"><div class="recent-posts-item-content">Flutter自定义绘制CustomPaint</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2025-01-01</div><a href="/2025/01/01/flutter-animation/"><div class="recent-posts-item-content">Flutter动画</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-12-20</div><a href="/2024/12/20/flutter-getx-source/"><div class="recent-posts-item-content">GetX原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>