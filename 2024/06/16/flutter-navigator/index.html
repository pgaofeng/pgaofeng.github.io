<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Flutter界面跳转-Navigator</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.0.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>39</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>15.19</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E8%B7%AF%E7%94%B1" class="toc-link"><span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E5%8C%BF%E5%90%8D%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC" class="toc-link"><span class="toc-text">匿名路由跳转</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%AE%9E%E5%90%8D%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC" class="toc-link"><span class="toc-text">实名路由跳转</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Flutter界面跳转-Navigator thumbnail" class="image lozad" src="/img/cover/cover-flutter-navigator.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Flutter界面跳转-Navigator</h1></header><div class="post-meta post-show-meta"><time datetime="2024-06-16T13:47:02.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2024-06-16</span> </time><span class="dot"></span> <a href="/categories/Flutter/" class="post-meta-link">Flutter </a><span class="dot"></span> <span>约2k 字</span></div><div class="post-content" id="section"><p><code>Flutter</code>中通过<code>Navigator</code>实现的页面跳转和控制，实现像安卓中的<code>Activity</code>跳转一样的功能。对于学习<code>Flutter</code>而言，必须要先掌握这些跳转的基础知识，而后才能继续往后学习。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>和大多数导航路由工具一样，<code>Navigator</code>也是使用的栈的数据结构来管理路由表的。在安卓中，每个界面被称为一个<code>Activity</code>，而在<code>Flutter</code>中每个界面就是一个路由<code>PageRoute</code>，对路由的管理即是对界面的管理。</p><p><code>Navigator</code>将路由分为匿名路由和实名路由，匿名路由就是一个单独的<code>Route</code>，路由内部通过<code>builder</code>去构建界面的<code>widget</code>树，想要跳转到哪个界面，只需要将<code>Route</code>添加到路由栈中即可。</p><p>实名路由则是给每个<code>Route</code>起一个独一无二的名字，然后通过路由表将名字和路由进行映射，后续跳转时只需要传入路由名字，<code>Navigator</code>会自动从路由表中找到对应的路由进行入栈操作。</p><h4 id="匿名路由跳转"><a href="#匿名路由跳转" class="headerlink" title="匿名路由跳转"></a>匿名路由跳转</h4><p>路由跳转即是路由的入栈和出栈，对应的方法也是我们非常熟悉的<code>push</code>和<code>pop</code>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">static</span> Future&lt;T?&gt; push&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(BuildContext context, Route&lt;T&gt; route) &#123;<br>    <span class="hljs-keyword">return</span> Navigator.of(context).push(route);<br>  &#125;<br></code></pre></td></tr></table></figure><p>使用方式非常简单，直接通过<code>Navigator.push</code>调用即可，第二个参数即是界面路由<code>Route</code>，注意这里的<code>Route</code>是一个抽象类，实际中可以传入各种路由，如<code>PageRoute</code>、<code>DialogRoute</code>、<code>PopRoute</code>等等，根据实际进行选择。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> Page1(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      body: Container(<br>        color: Colors.blue,<br>        child: Center(child: Text(<span class="hljs-string">&quot;Page1&quot;</span>)),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上我们有一个<code>Page1</code>的界面，如果我们想要从其他界面界面跳转，只需要将<code>Page1</code>包裹成<code>PageRoute</code>，然后通过<code>Navigator.push</code>跳转即可。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs">child: TextButton(<br>  onPressed: () =&gt; Navigator.push(<br>    context,<br>    MaterialPageRoute(<br>      builder: (_) =&gt; <span class="hljs-keyword">const</span> Page1()<br>    ),<br>  ),<br>  child: Text(<span class="hljs-string">&quot;首页&quot;</span>),<br>)<br></code></pre></td></tr></table></figure><p>例如上面这个例子，在首页中有一个按钮，当按下按钮时就会通过<code>push</code>跳转到<code>Page1</code>界面。这里用的<code>PageRoute</code>是<code>MaterialPageRoute</code>，也可以换成<code>iOS</code>风格的<code>CupertinoPageRoute</code>它们的区别就是跳转动效不同。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="dart hljs">MaterialPageRoute(&#123;<br>    <span class="hljs-comment">// 构建widget树</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-comment">// 路由设置，可以设置名称和参数</span><br>    <span class="hljs-keyword">super</span>.settings,<br>&#125;)<br></code></pre></td></tr></table></figure><p>在<code>settings</code>中，可以设置路由的名字和参数，作为匿名路由，我们不需要设置名字，但是可能需要设置参数，用于界面间的数据交互。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteSettings</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> RouteSettings(&#123;<span class="hljs-keyword">this</span>.name, <span class="hljs-keyword">this</span>.arguments&#125;);<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String?</span> name;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object?</span> arguments;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数<code>arguments</code>是一个<code>Object</code>类型的数据，数据在子界面中通过<code>ModalRoute</code>获取。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> Page1(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      body: Container(<br>        color: Colors.blue,<br>        child: Center(child: Text(<br>           <span class="hljs-comment">// ModalRoute.of获取实例，从而通过settings拿到参数</span><br>           ModalRoute.of(context)!.settings.arguments.toString()<br>        )),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是匿名路由的跳转方式，总结下来就是构建一个<code>MaterialPageRoute</code>，然后通过<code>Mavigator.push</code>进行跳转，参数传递则是放在了<code>PageRoute</code>的<code>settings</code>参数中。而返回也是非常简单，正常返回可以直接按返回键或者通过手势返回，也可以通过<code>pop</code>方法进行返回。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs">TextButton(<br>  onPressed: () =&gt; Navigator.pop(context),<br>  child: Text(<span class="hljs-string">&quot;返回&quot;</span>),<br>),<br></code></pre></td></tr></table></figure><p>很简单，直接调用<code>pop</code>方法即可，如果想要给上一个界面传递参数的话，则通过<code>pop</code>的第二个参数传递即可。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> pop&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(BuildContext context, [T? result]) &#123;<br>    Navigator.of(context).pop&lt;T&gt;(result);<br>&#125;<br></code></pre></td></tr></table></figure><p>例如我们点击按钮时，给上一个界面返回一个<code>hello</code>的字串：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 子界面中点击按钮返回上一个界面</span><br>TextButton(<br>  onPressed: () =&gt; Navigator.pop(context, <span class="hljs-string">&quot;hello&quot;</span>),<br>  child: Text(<span class="hljs-string">&quot;返回&quot;</span>),<br>),<br><br><span class="hljs-comment">// 上一个界面通过await获取返回值</span><br>TextButton(<br>  onPressed: () <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-comment">// 在跳转出等待返回值</span><br>    <span class="hljs-keyword">final</span> params = <span class="hljs-keyword">await</span> Navigator.push(...);<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;params=<span class="hljs-subst">$params</span>&quot;</span>);<br>  &#125;,<br>  child: Text(<span class="hljs-string">&quot;首页&quot;</span>),<br>),<br></code></pre></td></tr></table></figure><p>以上就是匿名路由的跳转和返回的方法，以及跳转参数传递和返回参数回传的方式。实际上还有几个跳转方式也是比较常用的，例如<code>pushAndRemoveUntil</code>方法。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">static</span> Future&lt;T?&gt; pushAndRemoveUntil&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(<br>    BuildContext context,<br>    Route&lt;T&gt; newRoute,<br>    RoutePredicate predicate,<br>)<br></code></pre></td></tr></table></figure><p>它相对于普通的跳转，多了一个<code>predicate</code>参数。该跳转方式是跳到新的路由中，然后清除路由栈中已存在的路由，直到<code>predicate</code>返回<code>true</code>为止。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="dart hljs">Navigator.pushAndRemoveUntil(<br>   context,<br>   MaterialPageRoute(<br>     builder: (_) =&gt; <span class="hljs-keyword">const</span> Page3(),<br>   ),<br>   (route) =&gt; route.settings.name == <span class="hljs-string">&#x27;home&#x27;</span>,<br>)<br></code></pre></td></tr></table></figure><p>如上例，就是当跳转到<code>Page3</code>界面时，移除栈内已有的名称为<code>home</code>的路由之上的所有路由，不包括<code>home</code>，当然，对于这种判定名称来决定是否移除的场景，可以直接使用<code>ModalRoute.withName</code>来构建<code>predicate</code>。</p><p>同理，对于界面返回时也是有一个相同类型的方法的，<code>popUntil</code>也是比普通的<code>pop</code>多一个参数，用来判断需要移除多少个界面。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> popUntil(BuildContext context, RoutePredicate predicate) &#123;<br>    Navigator.of(context).popUntil(predicate);<br>&#125;<br></code></pre></td></tr></table></figure><p>当需要返回时，可以通过该方法进行返回，它会一直将栈顶界面移除，直到<code>predicate</code>返回<code>true</code>。</p><h4 id="实名路由跳转"><a href="#实名路由跳转" class="headerlink" title="实名路由跳转"></a>实名路由跳转</h4><p>以上看的都是匿名路由的跳转方式，实际上匿名路由的使用场景是非常少的，大部分都会采用实名路由来实现路由管理。实名路由是给每个路由设置一个名字，并且将其存放在路由表中进行管理，后续跳转时直接传入路由名称，而不需要传入路由实体即可。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="dart hljs">MaterialApp(<br>  theme: ThemeData(<br>    colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),<br>  ),<br>  initialRoute: <span class="hljs-string">&#x27;/&#x27;</span>,<br>  routes: &#123;<br>    <span class="hljs-string">&quot;/&quot;</span>: (context) =&gt; <span class="hljs-keyword">const</span> HomePage(),<br>    <span class="hljs-string">&quot;page1&quot;</span>: (_) =&gt; <span class="hljs-keyword">const</span> Page1(),<br>    <span class="hljs-string">&quot;page2&quot;</span>: (_) =&gt; <span class="hljs-keyword">const</span> Page2(),<br>    <span class="hljs-string">&quot;page3&quot;</span>: (_) =&gt; <span class="hljs-keyword">const</span> Page3()<br>  &#125;,<br>);<br></code></pre></td></tr></table></figure><p>路由表的设置是在应用的最顶层的<code>MaterialApp</code>中设置的，主要设置两个参数，一个是<code>initialRoute</code>表示初始路由，一个是<code>routes</code>的集合存放的是各种路由。在路由的<code>map</code>集合中，路由名称是可以随便定义的，类型是字符串类型，注意，<strong>通常情况下，将<code>/</code>定义为首页</strong>，如果路由表中存在<code>/</code>路由的话，初始化路由<code>initialRoute</code>可以省略不写。</p><p>路由跳转使用的是<code>pushNamed</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">static</span> Future&lt;T?&gt; pushNamed&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(<br>    BuildContext context,<br>    <span class="hljs-built_in">String</span> routeName, &#123;<br>    <span class="hljs-built_in">Object?</span> arguments,<br>&#125;)<br></code></pre></td></tr></table></figure><p>和<code>push</code>相比， 参数从<code>route</code>变成了<code>routeName</code>，也就是说不需要我们手动去创建<code>Route</code>了，因而也无法设置<code>settings</code>来传递参数了，所以这个方法额外提供了一个参数<code>arguments</code>用来传递参数。</p><p>在下一个界面中获取传递的参数方式还是一样的<code>ModalRoute.of(context)!.settings.arguments</code>。</p><p>和匿名路由相对应的，还有一个<code>pushNamedAndRemoveUntil</code>，也是跳转一个新的路由界面时，移除已存在的路由，直到<code>predicate</code>返回<code>true</code>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">static</span> Future&lt;T?&gt; pushNamedAndRemoveUntil&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(<br>    BuildContext context,<br>    <span class="hljs-built_in">String</span> newRouteName,<br>    RoutePredicate predicate, &#123;<br>    <span class="hljs-built_in">Object?</span> arguments,<br>&#125;) <br></code></pre></td></tr></table></figure><p>界面返回的方法是共用的，<code>pop</code>和<code>popUntil</code>两种返回，但是多了一个<code>popAndPushNamed</code>，该方法是移除当前界面时，加入一个新的界面，类似于替换。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">static</span> Future&lt;T?&gt; popAndPushNamed&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>, TO <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(<br>    BuildContext context,<br>    <span class="hljs-built_in">String</span> routeName, &#123;<br>    <span class="hljs-comment">// pop的老路由的返回值</span><br>    TO? result,<br>    <span class="hljs-comment">// 新路由的参数</span><br>    <span class="hljs-built_in">Object?</span> arguments,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>默认的路由导航<code>Navigator</code>比较简单，主要的就是路由的跳转和返回，以及跳转时的参数携带。这里又分为了实名路由和匿名路由，匿名路由直接通过<code>Navigator</code>进行跳转即可，直接传入对应的路由即可，但是这种方式对路由的管理比较混乱，因此实际中用的也比较少。</p><p>实名路由是通过路由表进行管理的，路由表定义在<code>MaterialApp</code>中，以<code>Map</code>的数据结构进行管理，<code>key</code>是路由名称，对应的是字符串类型，<code>value</code>是一个函数类型，用于构建界面的<code>Widget</code>树。跳转是通过名称进行跳转，而不用传入实际的路由，项目中基本都使用实名路由的方式进行管理。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Sun Jun 16 2024 21:47:02 GMT+0800");let n="Sun Jun 16 2024 21:47:02 GMT+0800";n="2025-09-26 15:20:22 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Flutter/" class="post-footer-category">#&nbsp;Flutter</a> <a href="/tags/Flutter/" class="post-footer-tag">#&nbsp;Flutter</a></div><div class="nav"><div class="nav-item-prev"><a href="/2024/07/23/flutter-getx/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">Flutter强大脚手架-GetX</div></div></a></div><div class="nav-item-next"><a href="/2024/05/02/flutter-dart/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Flutter基础语言Dart</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E8%B7%AF%E7%94%B1" class="toc-link"><span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E5%8C%BF%E5%90%8D%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC" class="toc-link"><span class="toc-text">匿名路由跳转</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%AE%9E%E5%90%8D%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC" class="toc-link"><span class="toc-text">实名路由跳转</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-07-23</div><a href="/2024/07/23/flutter-getx/"><div class="recent-posts-item-content">Flutter强大脚手架-GetX</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-05-02</div><a href="/2024/05/02/flutter-dart/"><div class="recent-posts-item-content">Flutter基础语言Dart</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-04-17</div><a href="/2024/04/17/flutter-widget/"><div class="recent-posts-item-content">Flutter基础组件</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-07-23</div><a href="/2024/07/23/flutter-getx/"><div class="recent-posts-item-content">Flutter强大脚手架-GetX</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-06-16</div><a href="/2024/06/16/flutter-navigator/"><div class="recent-posts-item-content">Flutter界面跳转-Navigator</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-05-02</div><a href="/2024/05/02/flutter-dart/"><div class="recent-posts-item-content">Flutter基础语言Dart</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-04-17</div><a href="/2024/04/17/flutter-widget/"><div class="recent-posts-item-content">Flutter基础组件</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>