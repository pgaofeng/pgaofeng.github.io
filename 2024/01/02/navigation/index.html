<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>在Compose中使用Navigation</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>34</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>5</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>16</span> <span>标签</span> </a><a class="author-word-count"><span>13.08</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#%E5%BC%95%E5%85%A5Navigation" class="toc-link"><span class="toc-text">引入Navigation</span></a></li><li class="toc-item toc-level-2"><a href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8" class="toc-link"><span class="toc-text">简单使用</span></a></li><li class="toc-item toc-level-2"><a href="#NavHost" class="toc-link"><span class="toc-text">NavHost</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#navigation" class="toc-link"><span class="toc-text">navigation</span></a></li><li class="toc-item toc-level-3"><a href="#composable" class="toc-link"><span class="toc-text">composable</span></a></li><li class="toc-item toc-level-3"><a href="#arguments" class="toc-link"><span class="toc-text">arguments</span></a></li><li class="toc-item toc-level-3"><a href="#deepLinks" class="toc-link"><span class="toc-text">deepLinks</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#NavController" class="toc-link"><span class="toc-text">NavController</span></a></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">1</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="在Compose中使用Navigation thumbnail" class="image lozad" src="/img/cover/cover-navigation.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">在Compose中使用Navigation</h1></header><div class="post-meta post-show-meta"><time datetime="2024-01-02T08:11:03.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2024-01-02</span> </time><span class="dot"></span> <a href="/categories/Third-Libraries/" class="post-meta-link">Third Libraries </a><span class="dot"></span> <span>约3.9k 字</span></div><div class="post-content" id="section"><p><code>Navigation</code>是<code>Jetpack</code>组件中的一个成员，主要作用是用于页面间的导航跳转。在很早之前谷歌就在推单<code>Activity</code>多<code>Fragment</code>架构，而<code>Navigation</code>就是用于管理<code>Fragment</code>的跳转的，当时是使用<code>xml</code>来声明导航图进行导航的，再加上没有必要对项目进行太大的改造，就一直没有去学习其使用的方式。而随着<code>Coompose</code>的逐渐完善，谷歌也对<code>Navigation</code>进行了适应性开发，使其也能支持<code>Compose</code>中的页面跳转，因此<code>Navigation</code>就成了必须要学习的了。</p><h2 id="引入Navigation"><a href="#引入Navigation" class="headerlink" title="引入Navigation"></a>引入Navigation</h2><p>引入<code>Navigation</code>比较简单，直接添加依赖就行，注意要添加对应的<code>Compose</code>版本。截止到最新，已经是2.9.0版本了，使用该版本对<code>CompileVersion</code>和<code>APG</code>版本都有要求，引入时可以直接进行同步编译，然后根据错误提示升级对应的其他插件的版本。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="kotlin hljs">dependencies &#123;<br>    ...<br>    <span class="hljs-keyword">val</span> nav_version = <span class="hljs-string">&quot;2.9.0&quot;</span><br>    implementation(<span class="hljs-string">&quot;androidx.navigation:navigation-compose:<span class="hljs-variable">$nav_version</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>使用起来和其他导航组件是一样的，都是先定义导航图，然后根据<code>key</code>去进行跳转。这里导航图是通过<code>NavHost</code>进行创建的，跳转是通过<code>NavController</code>去实现的。因此，我们需要在可组合函数的最顶层中定义出这两个成员，然后将<code>NavController</code>传递给每一个界面，这些界面就通过它来进行跳转。</p><p>首先要定义不同的导航路径，该路径就是每个页面的路径，就类似于<code>Key</code>的作用，用来标识每个界面。可以使用一个具体的类名来标识，也可以使用一个字符串来标识。一般我们使用字符串进行标识，因为使用类的话，需要为每个界面单独创建一个类，太过于浪费资源了。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">object</span> Graph &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> HOME = <span class="hljs-string">&quot;home&quot;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ME = <span class="hljs-string">&quot;me&quot;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> DETAIL = <span class="hljs-string">&quot;detail&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>导航图通过<code>NavHost</code>创建，即将对应的路径与页面进行关联。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">ComponentActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        enableEdgeToEdge()<br>        setContent &#123;<br>            <span class="hljs-comment">// 创建的navController用于控制页面跳转，需要将其传递给每个页面</span><br>            <span class="hljs-keyword">val</span> navController = rememberNavController()<br>            <span class="hljs-comment">// 创建导航图，表明开始路径</span><br>            NavHost(navController, startDestination = Graph.HOME) &#123;<br>                <span class="hljs-comment">// 每个路径对应的页面</span><br>                composable(route = Graph.HOME) &#123;<br>                    HomeScreen(navController)<br>                &#125;<br>                <span class="hljs-comment">// 每个路径对应的页面</span><br>                composable(route = Graph.ME) &#123;<br>                    MeScreen(navController)<br>                &#125;<br>                <span class="hljs-comment">// 每个路径对应的页面</span><br>                composable(route = Graph.DETAIL) &#123;<br>                    DetailScreen(navController)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是定义导航图的方式，用起来还是比较简单的，后续只需要关注这几个界面即可，并且由于<code>startDestination</code>是<code>Home</code>，因此当我们启动这个<code>MainActivity</code>时，显示的界面就是<code>HomeScreen</code>界面。如果我们要跳转，可以通过<code>navigation</code>方法进行跳转，如下：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">HomeScreen</span><span class="hljs-params">(navController: <span class="hljs-type">NavController</span>)</span></span> &#123;<br>    Text(<br>        text = <span class="hljs-string">&quot;首页&quot;</span>,<br>        modifier = Modifier<br>            .fillMaxSize()<br>            .padding(<span class="hljs-number">20.</span>dp)<br>            .clickable(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 点击时跳转到ME界面</span><br>                navController.navigate(Graph.ME)<br>            &#125;,<br>        color = Color.Blue,<br>        fontSize = <span class="hljs-number">20.</span>sp,<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>跳转通过<code>navController.navigate</code>跳到指定的界面，然后通过<code>navController.navigateUp</code>返回。当然，按下返回键实际上也相当于执行了<code>navigateUp</code>，会进行返回。</p><p>到这里，我们其实已经掌握了最简单的使用方式了，即定义导航图，然后进行跳转和返回。但实际中我们肯定不会这么简单的，因为会涉及到参数的传递、<code>ViewModel</code>的使用、界面跳转的动销等等，接下来我们继续看下详细的功能。</p><h2 id="NavHost"><a href="#NavHost" class="headerlink" title="NavHost"></a>NavHost</h2><p><code>NavHost</code>是用来创建导航图的，它本质上是个接口类，当然我们并不需要关注它的类型，我们直接使用对应的方法即可。在<code>NavHost.kt</code>中，提供了一个方法来创建导航图，与接口类的名称是一样的，方法名也是<code>NavHost</code>。我们需要关注的是它的方法参数。</p><ul><li><code>navController</code> 导航控制器，与当前<code>NavHost</code>关联的控制器，当前<code>host</code>中定义的界面就是通过该控制器进行跳转返回等操作。</li><li><code>startDestination</code>起始的导航页，注意这里类型在不同的函数重载中可以为<code>String</code>也可以为<code>KClass</code>类型，具体要根据自己的定义导航的方式。</li><li><code>modifier</code>页面参数修改器，该修改器影响的是路由的整个界面。</li><li><code>contentAlignment</code> 注释说是<code>AnimatedContent</code>的对其方式，但是<code>AnimatedContent</code>自己已经有这个参数了，它为啥还要用你提供的呢？</li><li><code>route</code>暂未发现有什么用，网上说是用于多个<code>NavHost</code>之间跳转，实测不行。</li><li><code>enterTransition</code>进入界面的切换动画、<code>exitTransition</code>原界面的消失动画、<code>popEnterTransition</code>返回时进入界面的动画、<code>popExitTransition</code>返回时原界面的消失动画。如果不指定的话，<code>popEnter</code>和<code>enter</code>的动画是一致的，<code>popExit</code>和<code>exit</code>的动画是一致的。举个例子：A界面跳转到B界面，此时A界面执行<code>exit</code>动画，B界面执行<code>enter</code>动画；然后从B界面返回到A界面时，B界面执行<code>popExit</code>动画，A界面执行<code>popEnter</code>动画。</li><li><code>sizeTransform</code>动画过程中的控制</li><li><code>builder</code>创建对应的界面</li></ul><p>以上就是创建<code>NavHost</code>的参数，我们重点关注的就是起始页以及四个动效，从而控制我们页面的跳转动画。在最后一个参数<code>builder</code>中，我们需要创建对应的界面，通常我们使用<code>composable</code>方法来声明一个普通界面，通过<code>dialog</code>声明一个对话框界面。</p><h3 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h3><p>在<code>NavHost</code>中，我们还可以使用<code>navigation</code>将一组<code>composable</code>整合起来，这样做可以方便我们进行模块划分。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="kotlin hljs">NavHost(...) &#123;<br>        <span class="hljs-comment">// 单独的界面</span><br>        composable(route = Graph.HOME) &#123;<br>            ...<br>        &#125;<br>        composable(route = Graph.ME) &#123;<br>            ...<br>        &#125;<br><br>        <span class="hljs-comment">//组合起来的界面</span><br>        navigation(<br>            route = <span class="hljs-string">&quot;Main&quot;</span>,<br>            <span class="hljs-comment">// 内部的起始界面</span><br>            startDestination = <span class="hljs-string">&quot;pageA&quot;</span><br>        ) &#123;<br>            composable(route = <span class="hljs-string">&quot;pageA&quot;</span>) &#123;<br>                ...<br>            &#125;<br>            composable(route = <span class="hljs-string">&quot;pageB&quot;</span>) &#123;<br>                ...<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，在<code>NavHost</code>除了普通的<code>composable</code>界面外，还使用<code>navigation</code>将一组界面包含在了一块，即嵌套界面。注意我们可以从外层的界面跳转到嵌套内部的界面，但是不能从内部的界面跳到外部的界面。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 跳转到内部的界面，此时是pageA界面</span><br>navController.navigate(<span class="hljs-string">&quot;Main&quot;</span>)<br></code></pre></td></tr></table></figure><p>这种模式适合对某个特定功能封装的情况，即某个功能模块的界面都封装在一块。</p><h3 id="composable"><a href="#composable" class="headerlink" title="composable"></a>composable</h3><p>在<code>NavHost</code>定义界面时，使用<code>composable</code>方法定义一个界面，使用<code>dialog</code>方法定义一个对话框界面，实际上我们甚至可以在<code>composable</code>中不去定义对应的界面，而是直接跳转到其他的<code>Activity</code>，当然我们一般不这样用。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> NavGraphBuilder.<span class="hljs-title">composable</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    route: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    arguments: <span class="hljs-type">List</span>&lt;<span class="hljs-type">NamedNavArgument</span>&gt; = emptyList()</span></span>,<br>    deepLinks: List&lt;NavDeepLink&gt; = emptyList(),<br>    enterTransition:.. = <span class="hljs-literal">null</span>,<br>    exitTransition:.. = <span class="hljs-literal">null</span>,<br>    popEnterTransition:.. = enterTransition,<br>    popExitTransition:.. = exitTransition,<br>    sizeTransform:.. = <span class="hljs-literal">null</span>,<br>    content: <span class="hljs-meta">@Composable</span> AnimatedContentScope.(NavBackStackEntry) -&gt; <span class="hljs-built_in">Unit</span><br>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>稍微简化下可以看到它的定义中，有我们前面了解的那四个动画以及一个<code>sizeTransfrom</code>，前面在<code>NavHost</code>中定义的动画属于全局动画，也就是它所有的界面都会应用这四个动画，但如果想要与众不同的话，则需要在<code>composable</code>中设置单属于自己这个界面的动画。</p><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>除了这五个参数外，我们需要关注的就是<code>route</code>，这是当前界面的路由地址，通过该<code>route</code>就可以跳转到这个界面。然后另一个参数就是<code>arguments</code>，正常我们跳转界面都会携带参数，在<code>Activity</code>中我们使用<code>Intent</code>传递参数，在这里肯定不能直接使用<code>Intent</code>了，而是使用<code>route</code>+<code>arguments</code>来传递参数。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="kotlin hljs">NavHost(...) &#123;<br>    <span class="hljs-comment">// 定义一个界面，界面路由为Graph.ME常量字符串</span><br>	composable(<br>        route = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;Graph.ME&#125;</span>/&#123;uid&#125;/&#123;uname&#125;?sex=&#123;sex1&#125;&amp;age=&#123;age&#125;&quot;</span>,<br>        arguments = listOf(<br>            <span class="hljs-comment">// uid的参数描述，注意名字和占位符保持一致</span><br>            navArgument(<span class="hljs-string">&quot;uid&quot;</span>) &#123;<br>                type = NavType.IntType<br>            &#125;,<br>            <span class="hljs-comment">// 注意名字是占位符内的sex1，而不是前面的sex，当然如果保持一致也是可以的</span><br>            navArgument(<span class="hljs-string">&quot;sex1&quot;</span>) &#123;<br>                type = NavType.StringType<br>                nullable = <span class="hljs-literal">true</span><br>                defaultValue = <span class="hljs-string">&quot;未知&quot;</span><br>            &#125;<br>        )<br>	) &#123; entry-&gt;<br>       <span class="hljs-comment">// 获取到传递的参数</span><br>       Log.d(TAG, entry.arguments?.getInt(<span class="hljs-string">&quot;uid&quot;</span>))<br>       Log.d(TAG, entry.arguments?.getString(<span class="hljs-string">&quot;uname&quot;</span>))<br>       <span class="hljs-comment">// 注意！！查询的key不是sex，而是占位符sex1</span><br>       Log.d(TAG, entry.arguments?.getString(<span class="hljs-string">&quot;sex1&quot;</span>))<br>       <span class="hljs-comment">//</span><br>       MyScreen(）<br>    &#125;<br>&#125;<br>                <br><span class="hljs-comment">// 其他地方跳转到该界面</span><br>navController.navigate(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;Graph.ME&#125;</span>/100/张三?sex=男&amp;age=20&quot;</span>)<br></code></pre></td></tr></table></figure><p>可以看到在传递参数时，参数列表是已经定义在<code>composable</code>中的，主要集中在<code>route</code>中，表现形式类似于<code>URL</code>。其中可以将参数跟在主<code>route</code>后面，使用<code>/</code>的形式，然后参数使用占位符<code>&#123;&#125;</code>描述，如上面例子中的<code>uid</code>和<code>uname</code>。还有一种形式的参数是通过<code>?</code>后面进行拼接的参数，如<code>sex1</code>和<code>age</code>。</p><p>定义完占位符后，需要在<code>arguments</code>数组中描述占位符的类型，可以通过<code>navArgument</code>方法快速定义。然后描述类型使用<code>type</code>表示类型，<code>nullable</code>表示参数是否可空，<code>defaultValue</code>表示默认值。</p><p>需要注意一点的是：对于路径占位符（即跟随在<code>/</code>后的占位符），不论是否可空，在跳转时都是不可省略的，因此不需要声明默认值<code>defaultValue</code>。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 例如有一个graph为pageA/name，并且在描述中将name设置为可空的</span><br><span class="hljs-comment">// 1.跳转必须带该参数</span><br>navController.navigate(<span class="hljs-string">&quot;pageA/张三&quot;</span>)<br><span class="hljs-comment">// 2.参数即使为空也要添加</span><br><span class="hljs-keyword">val</span> nm = <span class="hljs-literal">null</span><br>navController.navigate(<span class="hljs-string">&quot;pageA/<span class="hljs-variable">$nm</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>而对于 查询占位符（<code>?</code>后的占位符），如果将其设置为了可空的，则需要设置默认值，并且在跳转时参数可以省略不写。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 例如有一个graph为pageB?name=$&#123;name&#125;，并且在描述中设置为可空的</span><br><span class="hljs-comment">// 1.正常跳转</span><br>navController.navigate(<span class="hljs-string">&quot;pageB?name=张三&quot;</span>)<br><span class="hljs-comment">// 2.参数可以为空，查询到的也是null</span><br><span class="hljs-keyword">val</span> nm = <span class="hljs-literal">null</span><br>navController.navigate(<span class="hljs-string">&quot;pageB?name=<span class="hljs-variable">$nm</span>&quot;</span>)<br><span class="hljs-comment">// 3.直接忽略不写，查询到的是默认值</span><br>navController.navigate(<span class="hljs-string">&quot;pageB&quot;</span>)<br></code></pre></td></tr></table></figure><p><em><strong>当参数名和占位符不一致时，查询需要查占位符</strong></em>，例如<code>route=pageC?name=&#123;other&#125;</code>，此时查询时需要以<code>other</code>为<code>key</code>来获取参数值。</p><p>另外注意的就是占位符描述可以不加，即我在<code>route</code>中有定义占位符，但是我在<code>arguments</code>中不去声明这个占位符的类型等信息也是可以的。</p><h3 id="deepLinks"><a href="#deepLinks" class="headerlink" title="deepLinks"></a>deepLinks</h3><p><code>deepLinks</code>定义的是<code>url</code>类型的匹配符，即从网页端直接跳转到当前界面来。用法和原来的<code>Activity</code>一样，只是原来是从外部跳转到对应的<code>Activity</code>，而现在只有一个<code>Activity</code>了，就会跳到当前的<code>Activity</code>后，再由<code>Navigation</code>拦截并跳转到对应的界面而已。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="kotlin hljs">composable(<br>   ...<br>   deepLinks = listOf(<br>        navDeepLink &#123;<br>            uriPattern = <span class="hljs-string">&quot;test://mypage/&#123;name&#125;?age=&#123;age&#125;&quot;</span><br>        &#125;<br>   )<br>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中参数的传递仍然是以占位符的形式进行传递的，接下来就是在<code>AndroidManifest</code>中添加对应的<code>filter</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">...</span></span><br><span class="hljs-tag">    &lt;<span class="hljs-attr">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.BROWSABLE&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">android:host</span>=<span class="hljs-string">&quot;mypage&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后就可以响应外部的界面了，我们可以在其他<code>html</code>界面中嵌入<code>&lt;a href=&quot;test://mypage/wang?age=20&quot;&gt;点击跳转&lt;/a&gt;</code>超链接，当点击超链接的时候就可以跳转到我们对应的界面了。或者测试用<code>adb</code>命令也是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell am start -a android.intent.action.VIEW -d <span class="hljs-string">&quot;test://mypage/wang?age=20&quot;</span> com.example.myapplication/.MainActivity<br></code></pre></td></tr></table></figure><p>到这里<code>NavHost</code>相关的基本上都已经了解了，接下来我们继续看<code>navController</code>。</p><h2 id="NavController"><a href="#NavController" class="headerlink" title="NavController"></a>NavController</h2><p><code>NavController</code>是用来控制跳转的，在创建<code>NavHost</code>的时候第一个参数就是它，后续需要把它传递到每个界面中，然后在对应的界面中通过它来跳转。同样的，我们也可以通过它来获取到<code>Context</code>以及对应的<code>Activity</code>。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 直接跳转</span><br>navController.navigate(Graph.ME)<br><span class="hljs-comment">// 返回</span><br>navController.navigateUp()<br></code></pre></td></tr></table></figure><p>最简单的用法就是上面这种方法，注意在<code>Navigation</code>中也是存在任务栈的，和<code>Activity</code>的任务栈一样，当通过<code>navigate()</code>方法跳转时，会把跳转的界面入栈，此时栈内就有两个界面，一个是原来的界面，栈顶是新跳转的界面。如果要返回，可以通过<code>navigateUp()</code>方法出栈，或者直接按手机上的返回按钮，也是一样的逻辑。</p><p>也就是说，使用了<code>Navigation</code>后，每个<code>composable</code>界面和原来的<code>Activity</code>对应，界面的出栈入栈对应<code>Activity</code>的出栈入栈。而同样的，在每个<code>composable</code>获取的<code>ViewModel</code>也是一样会跟随界面的销毁而销毁。在<code>composable</code>界面中，通过方法<code>viewModel()</code>获取<code>ViewModel</code>实例。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">PageA</span><span class="hljs-params">(navController: <span class="hljs-type">NavController</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> viewmodel:PageViewModel = viewModel()<br>    Button(onClick = &#123;<br>        <span class="hljs-comment">// 点击按钮跳转到详情界面</span><br>        navController.navigate(Graph.DETAIL)<br>    &#125;) &#123;<br>        Text(text = viewModel.buttonString)<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Composable</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">PageDetail</span><span class="hljs-params">(navController: <span class="hljs-type">NavController</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> viewmodel:DetailViewModel = viewModel()<br>    Button(onClick = &#123;<br>        <span class="hljs-comment">// 点击按钮返回到上一级页面</span><br>        navController.navigateUp()<br>    &#125;) &#123;<br>        Text(text = <span class="hljs-string">&quot;详情界面&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上述实例的两个界面，每个界面都有他们自己对应的<code>ViewModel</code>，当从<code>PageA</code>跳转到<code>PageDetail</code>的时候，<code>PageA</code>实际上还是在任务栈中没有销毁的，因此<code>PageViewModel</code>并不会销毁。而从<code>PageDetail</code>返回到<code>PageA</code>的时候，由于<code>PageDetail</code>界面被销毁了，因此它对应的<code>DetailViewModel</code>也会被销毁掉，和<code>Activity</code>的表现是一致的。</p><p>另外，我们可以使用<code>popBackStack()</code>来弹出多个界面。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 弹出当前界面</span><br>navController.popBackStack()<br><span class="hljs-comment">// 弹出多个界面，直到目标界面</span><br>navController.popBackStack(Graph.ME, <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>对于带参数的<code>popBackStack</code>，第一个参数是目标界面，第二参数是否包含自己。例如当前的任务栈有由以下几个界面组成<code>A-&gt;B-&gt;C-&gt;D</code>，如果我们在<code>D</code>界面通过<code>popBackStack(B, true)</code>，则会将<code>DCB</code>全部弹出，此时回到<code>A</code>界面，如果第二参数设置为<code>false</code>，表明不包含<code>B</code>，则只会弹出<code>DC</code>，此时回到<code>B</code>界面。</p><p>这是返回的操作退出任务栈，如果我们想在跳转的时候清除任务栈，例如登录成功后跳转到首页，此时就需要在跳转时就将登录界面弹出。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 跳转到首页</span><br>navController.navigate(Graph.HOME) &#123;<br>    <span class="hljs-comment">// 跳转前弹出界面到LOGIN界面</span><br>    popUpTo(Graph.LOGIN) &#123; <br>    	<span class="hljs-comment">// 是否包含LOGIN界面</span><br>        inclusive = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们可以轻易弹出界面，所以我们也可以来实现<code>Activity</code>的四种启动模式了。对于标准启动模式，我们什么都不需要做，默认就是标准启动模式。</p><p>对于<code>singleTop</code>模式，也是默认支持的，只需要我们在跳转时设置为<code>singleTop</code>即可。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="kotlin hljs">navController.navigate(Graph.HOME) &#123;<br>    launchSingleTop = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>singleTask</code>模式，我们需要手动弹出其他界面。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs">navController.navigate(Graph.ME) &#123;<br>    <span class="hljs-comment">// 弹出Graph.ME上面的所有界面</span><br>    popUpTo(Graph.ME) &#123; inclusive = <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-comment">// 设置为此次singleTop模式</span><br>    launchSingleTop = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是对于<code>singleInstance</code>模式，似乎就无法完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，基本上已经了解了<code>Navigation</code>的使用方式了。实际上，在<code>Compose</code>中，<code>Navigation</code>是非常非常适合用来做路由的一个库，通过它我们可以以原来的<code>Activity</code>开发思想来进行设计，降低我们的学习曲线。关于<code>Navigation</code>的功能，总结下就是跳转返回、参数传递、任务栈管理。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Tue Jan 02 2024 16:11:03 GMT+0800");let n="Tue Jan 02 2024 16:11:03 GMT+0800";n="2025-05-14 17:47:45 +0800";var a=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-a)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Third-Libraries/" class="post-footer-category">#&nbsp;Third Libraries</a> <a href="/tags/Jetpack/" class="post-footer-tag">#&nbsp;Jetpack</a></div><div class="nav"><div class="nav-item-prev"><a href="/2024/02/20/generics/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">Java泛型</div></div></a></div><div class="nav-item-next"><a href="/2023/12/20/ffmpeg4/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">FFmpeg解码视频YUV</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#%E5%BC%95%E5%85%A5Navigation" class="toc-link"><span class="toc-text">引入Navigation</span></a></li><li class="toc-item toc-level-2"><a href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8" class="toc-link"><span class="toc-text">简单使用</span></a></li><li class="toc-item toc-level-2"><a href="#NavHost" class="toc-link"><span class="toc-text">NavHost</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#navigation" class="toc-link"><span class="toc-text">navigation</span></a></li><li class="toc-item toc-level-3"><a href="#composable" class="toc-link"><span class="toc-text">composable</span></a></li><li class="toc-item toc-level-3"><a href="#arguments" class="toc-link"><span class="toc-text">arguments</span></a></li><li class="toc-item toc-level-3"><a href="#deepLinks" class="toc-link"><span class="toc-text">deepLinks</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#NavController" class="toc-link"><span class="toc-text">NavController</span></a></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2021-08-05</div><a href="/2021/08/05/database-room/"><div class="recent-posts-item-content">将Room的使用方式塞到脑子里</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-06-06</div><a href="/2021/06/06/di-hilt/"><div class="recent-posts-item-content">好用的依赖注入框架-Hilt</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-10-05</div><a href="/2023/10/05/ffmpeg2/"><div class="recent-posts-item-content">FFmpeg解封装与重封装</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-02-20</div><a href="/2024/02/20/generics/"><div class="recent-posts-item-content">Java泛型</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-01-02</div><a href="/2024/01/02/navigation/"><div class="recent-posts-item-content">在Compose中使用Navigation</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>