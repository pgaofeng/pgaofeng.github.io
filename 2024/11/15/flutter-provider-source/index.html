<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Provider原理分析</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.1.1" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>43</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>17.31</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92" class="toc-link"><span class="toc-text">数据传递</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96" class="toc-link"><span class="toc-text">数据获取</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">8</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Provider原理分析 thumbnail" class="lozad image" src="/img/cover/cover-flutter-provider-source.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Provider原理分析</h1></header><div class="post-meta post-show-meta"><time datetime="2024-11-15T13:14:33.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2024-11-15</span> </time><span class="dot"></span> <a href="/categories/Flutter/" class="post-meta-link">Flutter </a><span class="dot"></span> <span>约3.5k 字</span></div><div class="post-content" id="section"><p><code>Provider</code>是<code>Flutter</code>中的一个状态管理框架，也算是入侵性非常小的一个状态管理库。这里说的入侵性小，指的是它并没有引入什么新的概念，完全就是基于<code>Flutter</code>内部一些功能所做的封装。</p><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>状态管理的一个基础就是数据共享，而数据共享指的是多个子组件间可以共享状态，也就是进行状态提升。<code>Provider</code>用于提供状态的方式有很多，主要用于提供不同的状态类型，他们都是以<code>Provider</code>结尾的类。</p><p>例如下面通过<code>Provider</code>提供一个数据：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs">Provider&lt;CircleController&gt;(<br>  create: (context) =&gt; CircleController(),<br>  child: MyChildWidget(),<br>)<br></code></pre></td></tr></table></figure><p>例如上述代码，通过<code>Provider</code>提供一个<code>CircleController</code>对象，这样在它的子组件<code>MyChildWidget</code>，以及更深层级的子组件中都能够获取到<code>CircleController</code>，从而使用它内部的状态，或者说它本身也可以是一个状态。</p><p>实际上我们是知道在<code>Flutter</code>中，想向子组件传递数据，要么通过构造方法层层传入，要么构建一个独立于组件的对象来进行共享，要么就是通过<code>InheritedWidget</code>进行传递，<code>Provider</code>使用的就是最后一种方式。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedProvider</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  Provider(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> Create&lt;T&gt; create,<br>    Dispose&lt;T&gt;? dispose,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>  &#125;) : <span class="hljs-keyword">super</span>(<br>          key: key,<br>          lazy: lazy,<br>          builder: builder,<br>          create: create,<br>          dispose: dispose,<br>          debugCheckInvalidValueType: kReleaseMode<br>              ? <span class="hljs-keyword">null</span><br>              : (T value) =&gt;<br>                  Provider.debugCheckInvalidValueType?.call&lt;T&gt;(value),<br>          child: child,<br>        );<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在剔除掉一些静态方法后，可以看到<code>Provider</code>类实际上就是对<code>InheritedProvider</code>的一个包装，基本上没有做什么操作，再继续跟踪<code>InheritedProvider</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritedProvider</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">SingleChildStatelessWidget</span> </span>&#123;<br><br>  InheritedProvider(&#123;<br>    Key? key,<br>    Create&lt;T&gt;? create,<br>    T <span class="hljs-built_in">Function</span>(BuildContext context, T? value)? update,<br>    UpdateShouldNotify&lt;T&gt;? updateShouldNotify,<br>    <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>(T value)? debugCheckInvalidValueType,<br>    StartListening&lt;T&gt;? startListening,<br>    Dispose&lt;T&gt;? dispose,<br>    <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    Widget? child,<br>  &#125;)  : _lazy = lazy,<br>        <span class="hljs-comment">// 创建了一个代理对象，基本上所有的参数都被代理对象持有</span><br>        _delegate = _CreateInheritedProvider(<br>          create: create,<br>          update: update,<br>          updateShouldNotify: updateShouldNotify,<br>          debugCheckInvalidValueType: debugCheckInvalidValueType,<br>          startListening: startListening,<br>          dispose: dispose,<br>        ),<br>        <span class="hljs-keyword">super</span>(key: key, child: child);<br><br>  <span class="hljs-keyword">final</span> _Delegate&lt;T&gt; _delegate;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool?</span> _lazy;<br>  <span class="hljs-keyword">final</span> TransitionBuilder? builder;<br><br>  <span class="hljs-meta">@override</span><br>  _InheritedProviderElement&lt;T&gt; createElement() &#123;<br>    <span class="hljs-keyword">return</span> _InheritedProviderElement&lt;T&gt;(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 构建子组件</span><br>  <span class="hljs-meta">@override</span><br>  Widget buildWithChild(BuildContext context, Widget? child) =&gt;<br>      _buildWithChild(child);<br><br>  Widget _buildWithChild(Widget? child, &#123;Key? key&#125;) &#123;<br>    <span class="hljs-comment">// 又包了一层_InheritedProviderScope</span><br>    <span class="hljs-keyword">return</span> _InheritedProviderScope&lt;T?&gt;(<br>      owner: <span class="hljs-keyword">this</span>,<br>      key: key,<br>      debugType: kDebugMode ? <span class="hljs-string">&#x27;<span class="hljs-subst">$runtimeType</span>&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>,<br>      <span class="hljs-comment">// 默认使用builder构建</span><br>      child: builder != <span class="hljs-keyword">null</span><br>          ? Builder(<br>              builder: (context) =&gt; builder!(context, child),<br>            )<br>          <span class="hljs-comment">// 如果没传builder，则直接使用child</span><br>          : child!,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>InheritedProvider</code>在构造方法中提供了一系列的参数，参数实际上是在不同类型的<code>Provider</code>中使用的，这里先不去关注，因为它将这些参数统一打包在了一个代理对象中<code>_CreateInheritedProvider</code>，后续如果需要使用，就直接从代理对象中获取。</p><p>然后就是<code>buildWithChild</code>方法，这是构建布局的一个方法，在<code>InheritedProvider</code>中可以看到，它实际上调用的是构造方法传入的<code>builder</code>来完成布局的，并且在这个布局外面又套了一层<code>_InheritedProviderScope</code>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 继承自InheritedWidget</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_InheritedProviderScope</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>&#123;<br>  _InheritedProviderScope(&#123;<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.owner,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.debugType,<br>    <span class="hljs-keyword">required</span> Widget child,<br>    Key? key,<br>  &#125;)  : <span class="hljs-keyword">assert</span>(<span class="hljs-keyword">null</span> <span class="hljs-keyword">is</span> T),<br>        <span class="hljs-keyword">super</span>(<br>          key: key,<br>          child: child,<br>        );<br><br>  <span class="hljs-keyword">final</span> InheritedProvider&lt;T&gt; owner;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> debugType;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> updateShouldNotify(InheritedWidget oldWidget) &#123;<br>    <span class="hljs-comment">// 直接return false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  _InheritedProviderScopeElement&lt;T&gt; createElement() &#123;<br>    <span class="hljs-keyword">return</span> _InheritedProviderScopeElement&lt;T&gt;(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>_InheritedProviderScope</code>就是继承自<code>InheritedWidget</code>的，并且它持有了外部的<code>InheritedProvider</code>，也就是间接拿到了构造方法中传入的各种参数。注意在<code>updateShouldNotify</code>时，直接返回<code>false</code>。因此，但状态发生变化时，它是不会通知依赖的子组件进行更新的。</p><p>再回到最初的示例：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs">Provider&lt;CircleController&gt;(<br>  create: (context) =&gt; CircleController(),<br>  child: MyChildWidget(),<br>)<br></code></pre></td></tr></table></figure><p>此时组件树是如下所示的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Provider -&gt; _InheritedProviderScope -&gt; MyChildWidget<br></code></pre></td></tr></table></figure><p>其中<code>_InheritedProviderScope</code>是<code>InheritedWidget</code>类型，因此它的子组件就能通过<code>context</code>获取到<code>_InheritedProviderScope</code>，从而可以拿到它提供的状态。</p><p>继承关系如下：</p><p><img alt="继承关系" class="lozad post-image" src="/img/img-flutter-provider-extends.webp" data-src="/img/img-flutter-provider-extends.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><p>对于普通的<code>Provider</code>提供状态，我们看到了实际上就是包了一层<code>InheritedWidget</code>来提供状态，并且它提供的状态变化时，还不会通知到子组件进行重建，因此我们使用它来提供状态是非常有限的，我们常用的是<code>ChangeNotifier</code>，而它是继承自<code>ListenableProvider</code>。那把上面的例子替换成<code>ListenableProvider</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs">ListenableProvider&lt;CircleController&gt;(<br>  create: (context) =&gt; CircleController(),<br>  child: MyChildWidget(),<br>)<br></code></pre></td></tr></table></figure><p>用法上和<code>Provider</code>是一致的，包括参数列表也是一样的：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 泛型给了限定为Listenable</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListenableProvider</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Listenable</span>?&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedProvider</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>  ListenableProvider(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> Create&lt;T&gt; create,<br>    Dispose&lt;T&gt;? dispose,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>  &#125;) : <span class="hljs-keyword">super</span>(<br>          key: key,<br>          <span class="hljs-comment">// 传入了startLitening的方法</span><br>          startListening: _startListening,<br>          create: create,<br>          dispose: dispose,<br>          lazy: lazy,<br>          builder: builder,<br>          child: child,<br>        );<br><br>  <span class="hljs-comment">// 开始监听的方法</span><br>  <span class="hljs-keyword">static</span> VoidCallback _startListening(<br>    InheritedContext&lt;Listenable?&gt; e,<br>    Listenable? value,<br>  ) &#123;<br>    <span class="hljs-comment">// 添加监听者，回调函数是需要通知依赖组件进行更新</span><br>    value?.addListener(e.markNeedsNotifyDependents);<br>    <span class="hljs-comment">// 返回值是一个callback，内部是移除监听者</span><br>    <span class="hljs-keyword">return</span> () =&gt; value?.removeListener(e.markNeedsNotifyDependents);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ListenableProvider</code>也是继承自<code>InheritedProvider</code>，它比<code>Provider</code>多的一点就是它额外传递了一个<code>startListening</code>参数，该参数的内部逻辑是向<code>Listenable</code>参数添加监听，并返回一个移除监听的回调，当监听到内容变化后，会通知依赖的子组件进行刷新。</p><p>还有<code>ChangeNotifierProvider</code>:</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeNotifierProvider</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChangeNotifier</span>?&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">ListenableProvider</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>  ChangeNotifierProvider(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> Create&lt;T&gt; create,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>  &#125;) : <span class="hljs-keyword">super</span>(<br>          key: key,<br>          create: create,<br>          <span class="hljs-comment">// 传入了_dispose</span><br>          dispose: _dispose,<br>          lazy: lazy,<br>          builder: builder,<br>          child: child,<br>        );<br><br>  <span class="hljs-comment">// 组件移除时的监听</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _dispose(BuildContext context, ChangeNotifier? notifier) &#123;<br>    notifier?.dispose();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过上述三个<code>Provider</code>的分析，我们看到他们实际上都是对<code>InheritedProvider</code>的包装，主要的区别就是传入的参数不同。其中<code>Provider</code>只传入了必要的参数，<code>ListenableProvider</code>额外提供了<code>startLintening</code>参数，而<code>ChangeNotifierProvider</code>又多了一个<code>_dispose</code>参数。并且值得注意的是，这些参数并没有直接使用，而是包装在了<code>_delegate</code>中。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Delegate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 创建一个代理State</span><br>  _DelegateState&lt;T, _Delegate&lt;T&gt;&gt; createState();<br><br>  <span class="hljs-keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 代理类的状态</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_DelegateState</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">_Delegate</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// _InheritedProviderScope所对应的element</span><br>  _InheritedProviderScopeElement&lt;T?&gt;? element;<br>  <span class="hljs-comment">// Provider提供的值</span><br>  T <span class="hljs-keyword">get</span> value;<br>  <span class="hljs-comment">// 获取到当前的_delegate对象</span><br>  D <span class="hljs-keyword">get</span> delegate =&gt; element!.widget.owner._delegate <span class="hljs-keyword">as</span> D;<br>  <span class="hljs-comment">// 是否有值</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> hasValue;<br><br>  <span class="hljs-built_in">bool</span> debugSetInheritedLock(<span class="hljs-built_in">bool</span> value) &#123;<br>    <span class="hljs-keyword">return</span> element!._debugSetInheritedLock(value);<br>  &#125;<br>  <span class="hljs-comment">// 是否需要更新代理对象</span><br>  <span class="hljs-built_in">bool</span> willUpdateDelegate(D newDelegate) =&gt; <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">// 移除时的回调</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;&#125;<br><br>  <span class="hljs-keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;&#125;<br>  <span class="hljs-comment">// 构建时调用</span><br>  <span class="hljs-keyword">void</span> build(&#123;<span class="hljs-keyword">required</span> <span class="hljs-built_in">bool</span> isBuildFromExternalSources&#125;) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理对象<code>_delegate</code>实际是一个<code>_Dalegate</code>类型，它内部有个方法用于创建<code>_DelegateState</code>，这个<code>State</code>类主要作用就是存储需要提供的数据以及响应组件的生命周期，在<code>InheritedProvider</code>中它的实现类是<code>_CreateInheritedProvider</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 构建Provider时传入的数据和方法都在delegate中</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_CreateInheritedProvider</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">_Delegate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  _CreateInheritedProvider(&#123;<br>    <span class="hljs-keyword">this</span>.create,<br>    <span class="hljs-keyword">this</span>.update,<br>    UpdateShouldNotify&lt;T&gt;? updateShouldNotify,<br>    <span class="hljs-keyword">this</span>.debugCheckInvalidValueType,<br>    <span class="hljs-keyword">this</span>.startListening,<br>    <span class="hljs-keyword">this</span>.dispose,<br>  &#125;)  : <span class="hljs-keyword">assert</span>(create != <span class="hljs-keyword">null</span> || update != <span class="hljs-keyword">null</span>),<br>        _updateShouldNotify = updateShouldNotify;<br>  <span class="hljs-comment">// 构建状态的代码块</span><br>  <span class="hljs-keyword">final</span> Create&lt;T&gt;? create;<br>  <span class="hljs-comment">// 更新状态的代码块</span><br>  <span class="hljs-keyword">final</span> T <span class="hljs-built_in">Function</span>(BuildContext context, T? value)? update;<br>  <span class="hljs-comment">// 判断是否需要通知依赖的子组件刷新</span><br>  <span class="hljs-keyword">final</span> UpdateShouldNotify&lt;T&gt;? _updateShouldNotify;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>(T value)? debugCheckInvalidValueType;<br>  <span class="hljs-comment">// 开始监听的代码块</span><br>  <span class="hljs-keyword">final</span> StartListening&lt;T&gt;? startListening;<br>  <span class="hljs-comment">// 移除时的回调</span><br>  <span class="hljs-keyword">final</span> Dispose&lt;T&gt;? dispose;<br><br>  <span class="hljs-meta">@override</span><br>  _CreateInheritedProviderState&lt;T&gt; createState() =&gt;<br>      _CreateInheritedProviderState();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是<code>_DelegateState</code>的实现类，这里对应的是<code>_CreateInheritedProviderState</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_CreateInheritedProviderState</span>&lt;<span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">_DelegateState</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">_CreateInheritedProvider</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// 移除监听的回调</span><br>  VoidCallback? _removeListener;<br>  <span class="hljs-comment">// 是否初始化值</span><br>  <span class="hljs-built_in">bool</span> _didInitValue = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">// 提供的值</span><br>  T? _value;<br>  _CreateInheritedProvider&lt;T&gt;? _previousWidget;<br>  FlutterErrorDetails? _initError;<br><br>  <span class="hljs-meta">@override</span><br>  T <span class="hljs-keyword">get</span> value &#123;<br>    <span class="hljs-comment">// 构建值的时候发生了异常</span><br>    <span class="hljs-keyword">if</span> (_didInitValue &amp;&amp; _initError != <span class="hljs-keyword">null</span>) &#123;<br>      ...<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">if</span> (!_didInitValue) &#123;<br>      _didInitValue = <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">if</span> (delegate.create != <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-comment">// 通过create创建值，并赋值给_value</span><br>          _value = delegate.create!(element!);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (delegate.update != <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-comment">// 触发update</span><br>          _value = delegate.update!(element!, _value);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 调用startListening,实际上就是添加了监听者</span><br>    _removeListener ??= delegate.startListening?.call(element!, _value <span class="hljs-keyword">as</span> T);<br>    <span class="hljs-keyword">return</span> _value <span class="hljs-keyword">as</span> T;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">super</span>.dispose();<br>    <span class="hljs-comment">// 移除监听</span><br>    _removeListener?.call();<br>    <span class="hljs-keyword">if</span> (_didInitValue) &#123;<br>      <span class="hljs-comment">// 触发dispose</span><br>      delegate.dispose?.call(element!, _value <span class="hljs-keyword">as</span> T);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 组件构建时触发</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> build(&#123;<span class="hljs-keyword">required</span> <span class="hljs-built_in">bool</span> isBuildFromExternalSources&#125;) &#123;<br>    <span class="hljs-keyword">var</span> shouldNotify = <span class="hljs-keyword">false</span>;<br>   <br>    <span class="hljs-keyword">if</span> (isBuildFromExternalSources &amp;&amp;<br>        _didInitValue &amp;&amp;<br>        delegate.update != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">final</span> previousValue = _value;<br>      <span class="hljs-comment">// 触发更新</span><br>      _value = delegate.update!(element!, _value <span class="hljs-keyword">as</span> T);<br>      <span class="hljs-comment">// 如果传入了更新的方法，则调用来决定是否通知子组件更新</span><br>      <span class="hljs-keyword">if</span> (delegate._updateShouldNotify != <span class="hljs-keyword">null</span>) &#123;<br>        shouldNotify = delegate._updateShouldNotify!(<br>          previousValue <span class="hljs-keyword">as</span> T,<br>          _value <span class="hljs-keyword">as</span> T,<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则默认就比较二者的值是否一致</span><br>        shouldNotify = _value != previousValue;<br>      &#125;<br>      <span class="hljs-comment">// 如果需要通知依赖子组件更新</span><br>      <span class="hljs-keyword">if</span> (shouldNotify) &#123;<br>        <span class="hljs-keyword">if</span> (_removeListener != <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-comment">// 移除监听</span><br>          _removeListener!();<br>          _removeListener = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 并且dispose掉</span><br>        _previousWidget?.dispose?.call(element!, previousValue <span class="hljs-keyword">as</span> T);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 标记需要进行通知依赖子组件更新</span><br>    <span class="hljs-keyword">if</span> (shouldNotify) &#123;<br>      element!._shouldNotifyDependents = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    _previousWidget = delegate;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.build(isBuildFromExternalSources: isBuildFromExternalSources);<br>  &#125;<br>  <span class="hljs-comment">// 是否已经初始化值</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> hasValue =&gt; _didInitValue;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>_DelegateState</code>控制了整个组件的状态逻辑，首先就是在获取值时，使用的是懒加载模式，也就是只有第一次获取值的时候才会触发<code>ceate</code>来创建值，并且创建完之后会立即触发一次<code>update</code>，然后建立监听。然后就是在<code>dispose</code>的时候移除监听并且触发参数传入的<code>Dispose</code>。最后是<code>build</code>方法，也就是界面构建的时候会再次触发<code>update</code>，并且触发<code>updateShouldNotify</code>来决定是否需要通知子组件刷新，如果依赖子组件需要刷新，就会先移除掉监听并且<code>dispose</code>掉。</p><p>也就是说几乎所有的逻辑都发生在<code>_CreateInheritedProviderState</code>中，而<code>_CreateInheritedProviderState</code>又是发生在<code>_InheritedProviderScopeElement</code>中进行关联的：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_InheritedProviderScope</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">// 构建widget对应的element</span><br>  <span class="hljs-meta">@override</span><br>  _InheritedProviderScopeElement&lt;T&gt; createElement() &#123;<br>    <span class="hljs-keyword">return</span> _InheritedProviderScopeElement&lt;T&gt;(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// _InheritedProviderScope对应的Element</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_InheritedProviderScopeElement</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedElement</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">InheritedContext</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">// 构建了_DelegateState，并持有了当前element</span><br>  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> _DelegateState&lt;T, _Delegate&lt;T&gt;&gt; _delegateState =<br>      widget.owner._delegate.createState()..element = <span class="hljs-keyword">this</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> update(_InheritedProviderScope&lt;T&gt; newWidget) &#123;<br>    <span class="hljs-comment">// 更新时触发_delegateState的更新</span><br>    _updatedShouldNotify =<br>        _delegateState.willUpdateDelegate(newWidget.owner._delegate);<br>    <span class="hljs-keyword">super</span>.update(newWidget);<br>    _updatedShouldNotify = <span class="hljs-keyword">false</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build() &#123;<br>    <span class="hljs-comment">// 如果设置了不懒加载，则直接获取值来触发创建状态对象</span><br>    <span class="hljs-keyword">if</span> (widget.owner._lazy == <span class="hljs-keyword">false</span>) &#123;<br>      value;<br>    &#125;<br>    <span class="hljs-comment">// 触发代理类中的build方法</span><br>    _delegateState.build(<br>      isBuildFromExternalSources: _isBuildFromExternalSources,<br>    );<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.build();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> unmount() &#123;<br>    <span class="hljs-comment">// dispose</span><br>    _delegateState.dispose();<br>    <span class="hljs-keyword">super</span>.unmount();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> hasValue =&gt; _delegateState.hasValue;<br>  <br>  <span class="hljs-comment">// 获取代理类中的值</span><br>  <span class="hljs-meta">@override</span><br>  T <span class="hljs-keyword">get</span> value =&gt; _delegateState.value;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里基本上所有的逻辑都看完了，<code>_delegateState</code>是<code>_InheritedProviderScopeElement</code>触发的，如果指定懒加载为<code>false</code>，则会在<code>build</code>前通过访问代理类中的值来触发加载数据；否则只有在第一次访问值时才会触发<code>create</code>来创建数据。</p><p>时序图如下：</p><p><img alt="时序图" class="lozad post-image" src="/img/img-flutter-provider-sequence.webp" data-src="/img/img-flutter-provider-sequence.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><p>主要逻辑发生在<code>_InheritedProviderScopeElement</code>中，然后触发<code>_CreateInheritedProviderState</code>进行更新。</p><ol><li>首先就是获取依赖值<code>value</code>，只有获取值的时候才会调用<code>create</code>来创建值，即实现的懒加载场景，并且同时触发一次<code>update</code>。其次就是获取值的时候，如果没有加入监听，则会<code>startListening</code>来监听值的变化，当值变化时候回调函数会通知依赖的子组件刷新。</li><li><code>_InheritedProviderScopeElement#build</code>的时候，如果是非懒加载情况，会直接访问一次<code>value</code>来触发创建依赖值。然后调用代理类的<code>build</code>，然后调用<code>update</code>一次，然后再根据<code>_updateShouldNotify</code>来决定是否通知依赖子组件进行更新，如果需要更新就移除监听<code>removeListener</code>并<code>dispose</code>。</li><li><code>_InheritedProviderScopeElement#unmount</code>的时候会触发<code>dispose</code>和<code>removeListener</code>。</li></ol><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>数据获取方式有几种，基本上没啥太大的区别，主要就是是否需要进行依赖而已。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="dart hljs">T watch&lt;T&gt;() &#123;<br>  <span class="hljs-keyword">return</span> Provider.of&lt;T&gt;(<span class="hljs-keyword">this</span>);<br>&#125;<br><br>T read&lt;T&gt;() &#123;<br>  <span class="hljs-keyword">return</span> Provider.of&lt;T&gt;(<span class="hljs-keyword">this</span>, listen: <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>状态的获取有<code>read</code>和<code>watch</code>两种方式，他们都是定义的<code>BuildContext</code>的拓展方法，实际走的逻辑还是<code>Provider</code>中的<code>of</code>静态方法。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">static</span> T of&lt;T&gt;(BuildContext context, &#123;<span class="hljs-built_in">bool</span> listen = <span class="hljs-keyword">true</span>&#125;) &#123;<br>    <span class="hljs-comment">// 根据泛型，获取到_InheritedProviderScope</span><br>    <span class="hljs-keyword">final</span> inheritedElement = _inheritedElementOf&lt;T&gt;(context);<br><br>    <span class="hljs-keyword">if</span> (listen) &#123;<br>      <span class="hljs-comment">// 如果需要监听变化的话，通过dependsOn获取</span><br>      context.dependOnInheritedWidgetOfExactType&lt;_InheritedProviderScope&lt;T?&gt;&gt;();<br>    &#125;<br>    <span class="hljs-comment">// 拿到的是_delegate中的数据</span><br>    <span class="hljs-keyword">final</span> value = inheritedElement?.value;<br><br>    <span class="hljs-keyword">if</span> (_isSoundMode) &#123;<br>      <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">is</span>! T) &#123;<br>        <span class="hljs-keyword">throw</span> ProviderNullException(T, context.widget.runtimeType);<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value <span class="hljs-keyword">as</span> T;<br>&#125;<br><br><span class="hljs-keyword">static</span> _InheritedProviderScopeElement&lt;T?&gt;? _inheritedElementOf&lt;T&gt;(<br>    BuildContext context,<br>  ) &#123;<br>    <span class="hljs-comment">// 获取到_InheritedProviderScope</span><br>    <span class="hljs-keyword">final</span> inheritedElement = context.getElementForInheritedWidgetOfExactType&lt;<br>        _InheritedProviderScope&lt;T?&gt;&gt;() <span class="hljs-keyword">as</span> _InheritedProviderScopeElement&lt;T?&gt;?;<br><br>    <span class="hljs-keyword">if</span> (inheritedElement == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">null</span> <span class="hljs-keyword">is</span>! T) &#123;<br>      <span class="hljs-keyword">throw</span> ProviderNotFoundException(T, context.widget.runtimeType);<br>    &#125;<br>    <span class="hljs-keyword">return</span> inheritedElement;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取方式也是我们非常熟悉的方式，注意当我们使用<code>Provider</code>时，实际上会在子布局外包裹一层<code>_InheritedProviderScope</code>，实际的数据以及回调方法都是由它来提供的，因此我们获取数据时也是通过这个类型来获取的。对于普通获取，直接通过<code>get</code>方法拿到数据，对于依赖方式获取，通过<code>dependOn</code>方式拿到数据，在通过依赖方式获取状态时，会去将<code>context</code>所指向的<code>element</code>添加到依赖列表中，这样当<code>_InheritedProviderScope</code>发生变化时就能通知到我们进行重建。</p><p>还有一个有区别的方法就是<code>select</code>，它能够选择性能依赖某几个字段，当固定的字段发生变化时，才会触发重建：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="dart hljs">R select&lt;T, R&gt;(R <span class="hljs-built_in">Function</span>(T value) selector) &#123;<br>    <span class="hljs-comment">// get方式获取到_InheritedProviderScopeElement</span><br>    <span class="hljs-keyword">final</span> inheritedElement = Provider._inheritedElementOf&lt;T&gt;(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 拿到值</span><br>      <span class="hljs-keyword">final</span> value = inheritedElement?.value;<br>      <span class="hljs-comment">// 将值通过参数selector计算出另一个值</span><br>      <span class="hljs-keyword">final</span> selected = selector(value);<br><br>      <span class="hljs-keyword">if</span> (inheritedElement != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 建立依赖关系</span><br>        dependOnInheritedElement(<br>          inheritedElement,<br>          aspect: (T? newValue) &#123;<br>            <span class="hljs-comment">// 当发生变化时，通过selector计算新值是否与旧值一致，只有不一致时才会通知</span><br>            <span class="hljs-keyword">return</span> !<span class="hljs-keyword">const</span> DeepCollectionEquality()<br>                .equals(selector(newValue), selected);<br>          &#125;,<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        dependOnInheritedWidgetOfExactType&lt;_InheritedProviderScope&lt;T?&gt;&gt;();<br>      &#125;<br>      <span class="hljs-comment">// 返回计算后的值</span><br>      <span class="hljs-keyword">return</span> selected;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>select</code>实际上是将变化的值进行筛选，或者说是做一下<code>map</code>的操作，将状态值转换成别的值并返回，后续也是当状态发生变化时，再进行转换，如果转换后的值不一致，则再去进行通知，从而可以避免其他状态值的影响。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Fri Nov 15 2024 21:14:33 GMT+0800");let n="Fri Nov 15 2024 21:14:33 GMT+0800";n="2025-11-06 19:15:16 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Flutter/" class="post-footer-category">#&nbsp;Flutter</a> <a href="/tags/Flutter/" class="post-footer-tag">#&nbsp;Flutter</a></div><div class="nav"><div class="nav-item-prev"></div><div class="nav-item-next"><a href="/2024/10/05/flutter-provider/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Flutter状态管理框架Provider</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92" class="toc-link"><span class="toc-text">数据传递</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96" class="toc-link"><span class="toc-text">数据获取</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-09-10</div><a href="/2024/09/10/flutter-state/"><div class="recent-posts-item-content">Flutter状态管理</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-08-16</div><a href="/2024/08/16/flutter-canvas/"><div class="recent-posts-item-content">Flutter自定义绘制CustomPaint</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-07-23</div><a href="/2024/07/23/flutter-getx/"><div class="recent-posts-item-content">Flutter强大脚手架-GetX</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-06-16</div><a href="/2024/06/16/flutter-navigator/"><div class="recent-posts-item-content">Flutter界面跳转-Navigator</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-09-10</div><a href="/2024/09/10/flutter-state/"><div class="recent-posts-item-content">Flutter状态管理</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-08-16</div><a href="/2024/08/16/flutter-canvas/"><div class="recent-posts-item-content">Flutter自定义绘制CustomPaint</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>