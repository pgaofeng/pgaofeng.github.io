<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Flutter基础语言Dart</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.1.1" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>45</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>18.72</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#Dart" class="toc-link"><span class="toc-text">Dart</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E" class="toc-link"><span class="toc-text">属性声明</span></a></li><li class="toc-item toc-level-4"><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F" class="toc-link"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" class="toc-link"><span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-4"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" class="toc-link"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a href="#getter-setter" class="toc-link"><span class="toc-text">getter&#x2F;setter</span></a></li><li class="toc-item toc-level-4"><a href="#%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95" class="toc-link"><span class="toc-text">拓展方法</span></a></li><li class="toc-item toc-level-4"><a href="#implements" class="toc-link"><span class="toc-text">implements</span></a></li><li class="toc-item toc-level-4"><a href="#%E6%B7%B7%E5%85%A5" class="toc-link"><span class="toc-text">混入</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">10</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Flutter基础语言Dart thumbnail" class="image lozad" src="/img/cover/cover-flutter-dart.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Flutter基础语言Dart</h1></header><div class="post-meta post-show-meta"><time datetime="2024-05-02T08:47:29.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2024-05-02</span> </time><span class="dot"></span> <a href="/categories/Flutter/" class="post-meta-link">Flutter </a><span class="dot"></span> <span>约2.6k 字</span></div><div class="post-content" id="section"><p><code>Flutter</code>是一套跨平台方案，使用<code>Dart</code>语言设计。当已经掌握了一门开发语言之后，再去学习别的语言就是非常快的，因为基础语法基本上所有的语言都是一样的，因此只需要进行对比一下差异点就行。</p><h3 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h3><p><code>Dart</code>作为强类型语言，和<code>Java</code>的语法基本上是一致的，然后又和<code>Kotlin</code>也差不多，感觉类似于二者的混合。</p><h4 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h4><p>属性声明和<code>Java</code>一样，类型在前数据名称在后，结尾带分号。但是也可以省略类型，此时会自动推断类型，和<code>Kotlin</code>一致。同时也支持空类型。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>; <br><span class="hljs-built_in">int?</span> b = <span class="hljs-number">2</span>; <span class="hljs-comment">// 可空类型，可以赋值为null</span><br><br><span class="hljs-keyword">var</span> c = <span class="hljs-string">&quot;text&quot;</span>;<span class="hljs-comment">// 类型为String</span><br><span class="hljs-keyword">final</span> d = <span class="hljs-string">&quot;text1&quot;</span>;<span class="hljs-comment">// 类型为String</span><br><span class="hljs-built_in">String</span> e = <span class="hljs-string">&quot;text2&quot;</span>;<br><br><span class="hljs-comment">// 非空的属性必须设置初始值，否则需要通过late声明延迟初始化</span><br><span class="hljs-keyword">late</span> <span class="hljs-built_in">int</span> f;<br></code></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p><code>Dart</code>中没有<code>public</code>、<code>private</code>这种访问属性，默认就是<code>public</code>的，如果想要设置为私有的，则只需要在方法名或者属性名或类名前加<code>_</code>即可。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_Test</span> </span>&#123;<br>    <span class="hljs-built_in">int</span> _number = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">void</span> _test() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上声明了一个私有类，内部有一个私有属性和私有方法，这里的私有作用域是声明类的这个文件。在同一个文件内是可以随便访问的。</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数类型分为必选参数、可选参数、命名参数。这和<code>Kotlin</code>中的函数参数差不多，<code>Kotlin</code>中函数参数不加默认值的话就属于必选参数，并且所有参数都属于命名参数。但是在<code>Dart</code>中将二者进行了区分。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">void</span> _test(<span class="hljs-built_in">int</span> number, [<span class="hljs-built_in">String</span> sex = <span class="hljs-string">&quot;男&quot;</span>] ) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>普通参数放在前面，可选参数放在后面，并使用中括号括起来，并且可选参数必须要有默认值。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">void</span> main() &#123;<br>  _test(<span class="hljs-number">10</span>);<br>  _test(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;女&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用时不传可选参数会使用默认的值。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">void</span> _test(<span class="hljs-built_in">int</span> number, &#123;<span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> sex, <span class="hljs-built_in">bool</span> child = <span class="hljs-keyword">false</span>&#125; ) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>命名参数同样放在普通参数后面，命名参数必须提供默认值，如果不提供默认值的话类型必须是可空的，此时会自动使用<code>null</code>作为默认值，如果不可空并且不提供默认值，则需要使用<code>required</code>来表明该参数是必选的。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">void</span> main() &#123;<br>  _test(<span class="hljs-number">10</span>, sex: <span class="hljs-string">&quot;女&quot;</span>);<br>  _test(<span class="hljs-number">10</span>, sex: <span class="hljs-string">&quot;女&quot;</span>, child: <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意在传命名参数时，必须要带上参数的名称，如<code>sex</code>和<code>child</code>名称，普通参数不需要带。<strong>一个函数中不能同时出现可选参数和命名参数</strong>。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> _age = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">String</span> _name = <span class="hljs-string">&#x27;&#x27;</span>;<br>  Demo(<span class="hljs-built_in">int</span> age, <span class="hljs-built_in">String</span> name) &#123;<br>    <span class="hljs-keyword">this</span>._age = age;<br>    <span class="hljs-keyword">this</span>._name = name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，普通构造函数和<code>Java</code>一样，但是只能存在一个构造函数，不能重载。像这种基础的赋值操作，可以在构造函数中进行简化。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-comment">// 这里非空属性也不需要默认值了</span><br>  <span class="hljs-built_in">int</span> _age;<br>  <span class="hljs-built_in">String</span> _name;<br>  <span class="hljs-comment">// 当调用构造函数时，会自动进行赋值</span><br>  Person(<span class="hljs-keyword">this</span>._age, <span class="hljs-keyword">this</span>._name);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过在构造方法中使用<code>this._age</code>形式，构造对象时可以直接给<code>_age</code>赋值，并且声明该非空属性的地方也不需要设置默认值了，另外，如果不需要做其他操作的话，方法体也可以直接省略了。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-built_in">int?</span> age;<br>  <span class="hljs-built_in">String?</span> name;<br>  <span class="hljs-comment">// 如果是命名参数，不能是私有的</span><br>  Person(&#123;<span class="hljs-keyword">this</span>.age, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.name&#125;) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，构造函数的参数也可以是命名参数，但是命名参数不能是私有参数，私有的只能作为普通参数存在。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-built_in">int?</span> age;<br>  <span class="hljs-built_in">String?</span> name;<br>  Person(<span class="hljs-keyword">this</span>.age, <span class="hljs-keyword">this</span>.name);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>  Man(<span class="hljs-built_in">int</span> age, <span class="hljs-built_in">String</span> name): <span class="hljs-keyword">super</span>(age, name);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于继承类，需要在构造方法后面调用<code>super</code>，而不是在方法体中调用。当然也可以继续简化。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123; <br>  Man(<span class="hljs-keyword">super</span>.age, <span class="hljs-keyword">super</span>.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>直接在构造参数中通过<code>super.age</code>的方式给父类注入参数，这样就不需要单独调用<code>super()</code>方法了。另外，如果还有额外的参数不想通过构造方法注入的话，可以直接在构造方法的后面给他赋值。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123; <br>  Stirng sex;<br>  Man(<span class="hljs-keyword">super</span>.age, <span class="hljs-keyword">super</span>.name): sex = <span class="hljs-string">&#x27;男&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意只有自己的参数才能在构造函数的后面赋值，父类的参数只能在构造方法参数中赋值或者<code>super</code>方法中赋值。</p><p>命名构造函数，可以设置多个，通过名称来进行区分需要构造什么样的对象。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-built_in">int?</span> age;<br>  <span class="hljs-built_in">String?</span> name;<br>  Person(<span class="hljs-keyword">this</span>.age, <span class="hljs-keyword">this</span>.name);<br>  <span class="hljs-comment">// 命名构造函数</span><br>  Person.adult(<span class="hljs-keyword">this</span>.name): age = <span class="hljs-number">18</span>;<br>  Person.child(<span class="hljs-keyword">this</span>.name): age = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>命名构造函数实际上就是分不同的场景去创建不同的对象，例如上述例子中的<code>Person</code>的命名构造函数中，只需要传入<code>name</code>，而<code>age</code>则根据不同的场景设置为不同的值，处理不同的初始化逻辑等。</p><p>工厂构造方法，可以控制对象的创建过程，可以说工厂构造函数更类似于<code>Java</code>中的静态方法，本身并不是对象的构造函数，而是提供对象的工厂函数。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-built_in">int?</span> age;<br>  <span class="hljs-built_in">String?</span> name;<br><br>  Person(<span class="hljs-keyword">this</span>.age, <span class="hljs-keyword">this</span>.name);<br><br>  <span class="hljs-comment">// 声明一个工厂构造方法，每次调用返回一个新的实例</span><br>  <span class="hljs-keyword">factory</span> Person.newPerson(<span class="hljs-built_in">int</span> age, <span class="hljs-built_in">String</span> name) &#123;<br>    <span class="hljs-keyword">return</span> Person(age, name);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 声明一个工厂构造方法，每次调用返回同一个实例</span><br>  <span class="hljs-keyword">static</span> Person? _instance;<br>  <span class="hljs-keyword">factory</span> Person.defaultInstance() &#123;<br>    _instance ??= Person(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;默认&#x27;</span>);<br>    <span class="hljs-keyword">return</span> _instance!;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter&#x2F;setter"></a>getter&#x2F;setter</h4><p>除了可以和<code>Java</code>一样通过编码两个普通函数实现<code>getter</code>和<code>setter</code>外，<code>Dart</code>还支持对应的关键字来实现。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-built_in">int</span> _age;<br>    Person(<span class="hljs-keyword">this</span>.age);<br>    <br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> age =&gt; _age;<br>    <span class="hljs-keyword">set</span> age(<span class="hljs-built_in">int</span> age) =&gt; _age = age;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于私有属性<code>_age</code>，通过<code>get</code>关键字声明了一个<code>age</code>访问属性，进而可以访问到<code>_age</code>的值。另外也通过<code>set</code>关键字声明了一个<code>age()</code>方法来设置值。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">void</span> main() &#123;<br>	<span class="hljs-keyword">final</span> person = Person(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;ja&quot;</span>);<br>    <span class="hljs-comment">// 通过age进行访问</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;age=<span class="hljs-subst">$&#123;person.age&#125;</span>&#x27;</span>);<br>    <span class="hljs-comment">// 通过age进行设置</span><br>    person.age = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h4><p>和<code>Kotlin</code>一样，<code>Dart</code>也允许为某一个类拓展出不同的方法和属性，通过关键字<code>extension .. on ..</code>实现。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">extension</span> PersonExt <span class="hljs-keyword">on</span> Person &#123;<br>  <span class="hljs-comment">// 给_name拓展一个name的访问属性</span><br>  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> name =&gt; _name;<br>  <span class="hljs-keyword">set</span> name(<span class="hljs-built_in">String</span> name) =&gt; _name = name;<br>  <br>  <span class="hljs-comment">// 拓展一个打印方法</span><br>  <span class="hljs-keyword">void</span> printPerson() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;age=<span class="hljs-subst">$_age</span>, name=<span class="hljs-subst">$_name</span>&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拓展方法在使用上和普通方法是一样的，直接通过对象进行调用即可。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">final</span> person = Person(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;ja&#x27;</span>);<br>  <span class="hljs-comment">// 虽然Person定义里没有这个方法</span><br>  <span class="hljs-comment">// 但是经过拓展后还是可以调用到这个方法</span><br>  person.printPerson();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，上面的拓展方法中用到了类的私有属性，这是因为他们定义在了同一个文件中，如果不是同一个文件的话，是无法访问到它的私有属性的。</p><h4 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h4><p><code>Dart</code>也是单继承的语言，同样也是使用的<code>extends</code>关键字。另外，它没有接口类，但它能把普通类当做接口类来<code>implements</code>，不论这个类是普通类还是抽象类，而且还支持多实现。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 普通类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> _age;<br>  <span class="hljs-built_in">String</span> _name;<br>  Person(<span class="hljs-keyword">this</span>._age, <span class="hljs-keyword">this</span>._name);<br>  <span class="hljs-keyword">void</span> test() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">void</span> say();<br>&#125;<br><br><span class="hljs-comment">// 实现普通类时，需要同时重写属性和方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span>, <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">int</span> _age = <span class="hljs-number">10</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">String</span> _name;<br>  <br>  Woman(<span class="hljs-keyword">this</span>._age, <span class="hljs-keyword">this</span>._name);<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> test() &#123;<br>  &#125;  <br>    <br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> say() &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当继承(<code>extends</code>)一个类时，能够继承它的方法属性以及对应的逻辑，而当实现(<code>implements</code>)一个或多个类时，需要重写属性和方法，相当于只保留了它们的声明，而丢弃了实现。</p><h4 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h4><p><code>Dart</code>中用<code>mixin</code>表示一个功能，该功能可以混入到类中，也就是将某个具体方法逻辑的实现抽取出来，作为一个<code>mixin</code>，然后添加给想要该功能的类。</p><p>有点像<code>kotlin</code>的代理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// kotlin中描述某个功能的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fly</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// 对该功能实现的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyImpl</span> : <span class="hljs-type">Fly</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span> &#123;<br>        print(<span class="hljs-string">&quot;fly&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过by代理，可以使该类具有Fly接口的功能，而不用在</span><br><span class="hljs-comment">// 类中重新实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Birds</span>: <span class="hljs-type">Fly</span> <span class="hljs-title">by</span> <span class="hljs-title">FlyImpl</span>() &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>而在<code>Dart</code>中则是通过混入实现的：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// Dart中描述某个功能的混入类</span><br><span class="hljs-keyword">mixin</span> Fly &#123;<br>  <span class="hljs-keyword">void</span> fly() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;fly&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过with，是该类具有Fly的功能，而不用</span><br><span class="hljs-comment">// 在该类中重新实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Birds</span> <span class="hljs-title">with</span> <span class="hljs-title">Fly</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>通过<code>with</code>关键字，在声明类时将<code>Fly</code>混入类给加入到<code>Birds</code>中，这样就不需要在该类中重新写一遍具体的实现了。</p><p>而混入类比<code>Kotlin</code>代理更强的一点是，它可以指定在某个类上混入，从而可以访问这个类的属性和方法。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 普通的基类Person</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> age;<br>  <span class="hljs-built_in">String</span> name;<br>  Person(<span class="hljs-keyword">this</span>.age, <span class="hljs-keyword">this</span>.name);<br>&#125;<br><br><span class="hljs-comment">// 混入类通过on关键字，指明该混入只</span><br><span class="hljs-comment">// 能用在Person的子类上</span><br><span class="hljs-keyword">mixin</span> Speak <span class="hljs-keyword">on</span> Person &#123;<br>  <span class="hljs-keyword">void</span> speak() &#123;<br>    <span class="hljs-comment">// 可以访问到Person的属性</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;my name is <span class="hljs-subst">$name</span>, age is <span class="hljs-subst">$age</span>&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 也可以混入一个属性</span><br>  <span class="hljs-built_in">String</span> language = <span class="hljs-string">&quot;chinese&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// Person的子类可以混入Speak</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-title">with</span> <span class="hljs-title">Speak</span> </span>&#123;<br>  Man(<span class="hljs-keyword">super</span>.age, <span class="hljs-keyword">super</span>.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>即在声明混入类时，通过<code>on</code>关键字指明该混入类只能作用在具体的类的子类上，这样其他类就无法应用该混入类了，与此同时该混入类中也能访问到类的属性和方法了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了一门编程语言基础后，再去学另一门语言是非常快的，因为大部分语言都是相通的，只需要关注一下它们的不同之处即可。就像在已经掌握了<code>Java</code>和<code>Kotlin</code>之后，再去学<code>Dart</code>就发现非常容易，因为<code>Dart</code>中的概念在<code>Java</code>和<code>Kotlin</code>中都有，无非就是实现方式不一样而已。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Thu May 02 2024 16:47:29 GMT+0800");let n="Thu May 02 2024 16:47:29 GMT+0800";n="2025-09-26 15:20:22 +0800";var a=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-a)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Flutter/" class="post-footer-category">#&nbsp;Flutter</a> <a href="/tags/Flutter/" class="post-footer-tag">#&nbsp;Flutter</a></div><div class="nav"><div class="nav-item-prev"><a href="/2024/06/16/flutter-navigator/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">Flutter界面跳转-Navigator</div></div></a></div><div class="nav-item-next"><a href="/2024/04/17/flutter-widget/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Flutter基础组件</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#Dart" class="toc-link"><span class="toc-text">Dart</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E" class="toc-link"><span class="toc-text">属性声明</span></a></li><li class="toc-item toc-level-4"><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F" class="toc-link"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" class="toc-link"><span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-4"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" class="toc-link"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a href="#getter-setter" class="toc-link"><span class="toc-text">getter&#x2F;setter</span></a></li><li class="toc-item toc-level-4"><a href="#%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95" class="toc-link"><span class="toc-text">拓展方法</span></a></li><li class="toc-item toc-level-4"><a href="#implements" class="toc-link"><span class="toc-text">implements</span></a></li><li class="toc-item toc-level-4"><a href="#%E6%B7%B7%E5%85%A5" class="toc-link"><span class="toc-text">混入</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2025-01-01</div><a href="/2025/01/01/flutter-animation/"><div class="recent-posts-item-content">Flutter动画</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-12-20</div><a href="/2024/12/20/flutter-getx-source/"><div class="recent-posts-item-content">GetX原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-09-10</div><a href="/2024/09/10/flutter-state/"><div class="recent-posts-item-content">Flutter状态管理</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2025-01-01</div><a href="/2025/01/01/flutter-animation/"><div class="recent-posts-item-content">Flutter动画</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-12-20</div><a href="/2024/12/20/flutter-getx-source/"><div class="recent-posts-item-content">GetX原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>