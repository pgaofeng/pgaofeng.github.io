<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Flutter自定义绘制CustomPaint</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.1.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>40</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>15.54</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#CustomPaint" class="toc-link"><span class="toc-text">CustomPaint</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#CustomPainter" class="toc-link"><span class="toc-text">CustomPainter</span></a></li><li class="toc-item toc-level-4"><a href="#Paint" class="toc-link"><span class="toc-text">Paint</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#blendMode" class="toc-link"><span class="toc-text">blendMode</span></a></li><li class="toc-item toc-level-5"><a href="#shader" class="toc-link"><span class="toc-text">shader</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#Canvas" class="toc-link"><span class="toc-text">Canvas</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">5</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Flutter自定义绘制CustomPaint thumbnail" class="lozad image" src="/img/cover/cover-flutter-canvas.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Flutter自定义绘制CustomPaint</h1></header><div class="post-meta post-show-meta"><time datetime="2024-08-16T13:02:35.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2024-08-16</span> </time><span class="dot"></span> <a href="/categories/Flutter/" class="post-meta-link">Flutter </a><span class="dot"></span> <span>约3.6k 字</span></div><div class="post-content" id="section"><p><code>Flutter</code>内置了很多的组件，我们可以使用一个有状态或者无状态组件来将这些内置的基础组件进行组合，从而实现我们的布局。但是在实际项目中，这些内置的组件肯定是无法完全满足我们的要求的，因此需要我们自定义组件，一点点绘制出我们想要的结果。</p><h3 id="CustomPaint"><a href="#CustomPaint" class="headerlink" title="CustomPaint"></a>CustomPaint</h3><p>在<code>Android</code>中自定义<code>View</code>通常是继承自一些内置的基础组件或者最顶层的<code>View\ViewGroup</code>，然后根据需求实现它的测量布局绘制三个方法。在<code>Flutter</code>中稍微有一点不同，就是我们并不是直接继承各种<code>Widget</code>，而是通过一个布局容器<code>CustomPaint</code>，我们直接在这个容器内进行绘制。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">const</span> CustomPaint(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-keyword">this</span>.painter,<br>    <span class="hljs-keyword">this</span>.foregroundPainter,<br>    <span class="hljs-keyword">this</span>.size = Size.zero,<br>    <span class="hljs-keyword">this</span>.isComplex = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">this</span>.willChange = <span class="hljs-keyword">false</span>,<br>    <span class="hljs-keyword">super</span>.child,<br>&#125;)<br></code></pre></td></tr></table></figure><p>这个<code>Widget</code>本身并没有内容，而是提供了<code>painter</code>和<code>foregroundPainter</code>来供我们自定义绘制。我们一般会在<code>painter</code>中进行绘制，如果该组件有其他子组件，即<code>child</code>不为空的时候，我们还可以在<code>foregroundPainter</code>中绘制前景。</p><p>正常就是先在图层上显示<code>painter</code>绘制的内容，然后在这些内容上覆盖<code>child</code>中的组件内容，最后绘制<code>foregroundPainter</code>内容。</p><p>其他属性也比较简单，<code>size</code>是该组件的大小，<code>isComplex</code>表示是否是复杂组件从而决定是否需要加入到缓存中从而避免多次绘制，如果不设置的话则由内置的组合器中的逻辑来决定是否缓存，<code>willChange</code>表示下一帧是否会变化，如果设置了则不会进行缓存。</p><p>可以看到还是和<code>Android</code>中的自定义区别挺大的，在<code>Flutter</code>中，直接通过<code>CustomPaint</code>组件进行自定义，我们不需要关注组件是如何实现的，如何布局的，只需要实现抽象出来的两个<code>painter</code>即可。</p><h4 id="CustomPainter"><a href="#CustomPainter" class="headerlink" title="CustomPainter"></a>CustomPainter</h4><p>注意，<code>CustomPaint</code>是一个组件<code>Widget</code>，而<code>CustomPainter</code>则是一个绘制器，用于在<code>CustomPaint</code>中进行布局绘制的。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomPainter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Listenable</span> </span>&#123;<br>    <span class="hljs-keyword">void</span> paint(Canvas canvas, Size size);<br>    <span class="hljs-built_in">bool</span> shouldRepaint(<span class="hljs-keyword">covariant</span> CustomPainter oldDelegate);<br>&#125;<br></code></pre></td></tr></table></figure><p>本身是一个抽象类，一共需要我们实现两个抽象方法，<code>paint</code>决定如何绘制，<code>shouldRepaint</code>表示是否需要重绘。</p><p>在<code>paint</code>方法中，参数<code>canvas</code>表示画布，和<code>Android</code>中的画布一样，这里也是通过<code>canvas</code>进行各种绘制工作。例如下面，我们绘制五行的表格：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPainter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CustomPainter</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Paint _paint = Paint()<br>      ..color = Colors.black87<br>      ..isAntiAlias = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> paint(Canvas canvas, Size size) &#123;<br>    <span class="hljs-comment">// 纵向绘制</span><br>    <span class="hljs-keyword">final</span> perWidth = size.width / <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">double</span> i = <span class="hljs-number">0</span>; i &lt;= size.width; i += perWidth) &#123;<br>      canvas.drawLine(Offset(i, <span class="hljs-number">0</span>), Offset(i, size.height), _paint);<br>    &#125;<br>    <span class="hljs-comment">// 横向绘制</span><br>    <span class="hljs-keyword">final</span> perHeight = size.height / <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">double</span> i = <span class="hljs-number">0</span>; i &lt;= size.height; i += perHeight) &#123;<br>      canvas.drawLine(Offset(<span class="hljs-number">0</span>, i), Offset(size.width, i), _paint);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> shouldRepaint(<span class="hljs-keyword">covariant</span> CustomPainter oldDelegate) =&gt; <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接在需要该组件的地方声明即可：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="dart hljs">CustomPaint(size: Size(<span class="hljs-number">300</span>, <span class="hljs-number">200</span>), painter: MyPainter()),<br></code></pre></td></tr></table></figure><p>也就是说，对于普通的自定义组件，我们直接使用<code>CustomPaint</code>即可实现我们的需求，当然，这仅限于我们的组件只有自身，而没有子组件。虽然<code>CustomPaint</code>给我们提供了一个<code>child</code>属性，但实际使用中却是与我们预想的不符。例如前面的例子中，我们绘制了一个5*5的表格，然后有一个需求需要在表格的最中间添加一个文本，按照正常思路：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="dart hljs">CustomPaint(<br>    size: Size(<span class="hljs-number">300</span>, <span class="hljs-number">200</span>),<br>    painter: MyPainter(),<br>    child: Center(child: Text(<span class="hljs-string">&#x27;Hello&#x27;</span>)),<br>),<br></code></pre></td></tr></table></figure><p>但实际上效果却不是如我们想的那样，此时<code>size</code>失效了，表格的宽度占了整个屏幕，高度为<code>Text</code>的高度。如果想要实现我们想要的结果，就不能直接将<code>Text</code>放在<code>CustomPaint</code>的<code>child</code>属性中，而是需要将其提取到外部，使用<code>Stack</code>包裹。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs">Stack(<br>  alignment: Alignment.center,<br>  children: [<br>    CustomPaint(<br>      size: Size(<span class="hljs-number">300</span>, <span class="hljs-number">200</span>),<br>      painter: MyPainter(),<br>    ),<br>    Center(child: Text(<span class="hljs-string">&#x27;Hello&#x27;</span>)),<br>  ],<br>)<br></code></pre></td></tr></table></figure><h4 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h4><p>绘制方法和安卓中是一致的，需要一个画布<code>Canvas</code>和一个画笔<code>Paint</code>，来实现绘制。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">final</span> Paint _paint = Paint()<br>    <span class="hljs-comment">// 画笔类型，默认填充fill，注意只有绘制一个封闭图形时才生效，</span><br>    <span class="hljs-comment">// 绘制横线时是无效的</span><br>    ..style = PaintingStyle.stroke<br>    ..color = Colors.black87 <span class="hljs-comment">// 画笔颜色</span><br>    ..isAntiAlias = <span class="hljs-keyword">true</span> <span class="hljs-comment">// 抗锯齿</span><br>    ..strokeWidth = <span class="hljs-number">5</span> <span class="hljs-comment">// 线宽</span><br>    <span class="hljs-comment">// 端点形状，默认是butt, 普通矩形。</span><br>    <span class="hljs-comment">// 可选round圆形，会凸出来一个半圆，半径是线宽的一半</span><br>    <span class="hljs-comment">// 可选square矩形，会凸出来半个矩形，宽度是线宽的一半</span><br>    ..strokeCap = StrokeCap.square<br>    <span class="hljs-comment">// 线段交互的角的形状，默认miter是一个尖角</span><br>    <span class="hljs-comment">// 可选round，过渡为平滑的圆角</span><br>    <span class="hljs-comment">// 可选bevel，是一个平角，类似于将miter切掉</span><br>    <span class="hljs-comment">// 仅对于一体的绘制生效，如path和矩形等</span><br>    ..strokeJoin = StrokeJoin.bevel<br>    <span class="hljs-comment">// 尖角的长度限制，超过长度后会自动变成bevel平角</span><br>    ..strokeMiterLimit = <span class="hljs-number">5</span><br>    <span class="hljs-comment">// 反转颜色</span><br>    ..invertColors = <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><p>以上是画笔的一些设置，主要就是设置画笔粗细、颜色、圆角等属性。</p><h5 id="blendMode"><a href="#blendMode" class="headerlink" title="blendMode"></a>blendMode</h5><p>同时也有一些比较复杂的属性可以设置，如<code>blendMode</code>设置的混入模式，实际上和安卓也是一样的。注意混入模式必须要在图层上进行混入。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPainter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CustomPainter</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> _index;<br>  MyPainter(<span class="hljs-keyword">this</span>._index);<br><br>  <span class="hljs-keyword">void</span> paint(Canvas canvas, Size size) &#123;<br>    Paint paint = Paint()..isAntiAlias = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-built_in">double</span> quarter = size.width / <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 新建图层，并绘制一个蓝色的矩形，该图层作为dst</span><br>    canvas.saveLayer(Offset.zero &amp; size, paint);<br>    canvas.drawRect(Rect.fromLTRB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, quarter * <span class="hljs-number">3</span>, quarter * <span class="hljs-number">3</span>), paint..color = Colors.blue);<br>    <span class="hljs-comment">// 新建图层，并绘制一个红色的矩形，该图层作为src。注意该图层设置了blendMode</span><br>    canvas.saveLayer(<br>      Offset.zero &amp; size,<br>      Paint()..blendMode = BlendMode.values[_index],<br>    );<br>    canvas.drawRect(Rect.fromLTRB(quarter, quarter, size.width, size.height), paint..color = Colors.red);<br>    <span class="hljs-comment">// 恢复图层</span><br>    canvas.restoreToCount(<span class="hljs-number">2</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> shouldRepaint(<span class="hljs-keyword">covariant</span> CustomPainter oldDelegate) =&gt; oldDelegate != <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，通过<code>saveLayer</code>创建了两个图层，第一个图层中在左上角绘制了四分之三大小的矩形，第二个图层在右下角绘制了四分之三的图层。当调用<code>restore</code>恢复图层时，就会应用<code>saveLayer</code>时传入的那个<code>paint</code>的混入模式，此时当前图层作为<code>src</code>，前一个图层作为<code>dst</code>。</p><p>这里我们将所有的混入模式都输出一下看看：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-meta">@override</span><br>Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      body: SafeArea(<br>        child: GridView.builder(<br>          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(<br>            crossAxisCount: <span class="hljs-number">10</span>,<br>          ),<br>          itemBuilder: (_, index) &#123;<br>            <span class="hljs-keyword">return</span> Container(<br>              decoration: BoxDecoration(border: Border.all(width: <span class="hljs-number">1</span>)),<br>              child: CustomPaint(<br>                painter: MyPainter(index),<br>                child: Text(BlendMode.values[index].name),<br>              ),<br>            );<br>          &#125;,<br>          itemCount: BlendMode.values.length,<br>          padding: EdgeInsets.all(<span class="hljs-number">15</span>),<br>        ),<br>      ),<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码运行后在手机上跑起来是如下图所示的，可以看到每种的混入模式的效果：</p><p><img alt="blendmode" class="lozad post-image" src="/img/cover/cover-flutter-canvas.webp" data-src="/img/cover/cover-flutter-canvas.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><ul><li><code>clear</code>：清除<code>src</code>和<code>dst</code>的内容，表现下来就是什么都没有。</li><li><code>src</code>：只显示<code>src</code>图层上的内容</li><li><code>dst</code>：只显示<code>dst</code>图层上的内容</li><li><code>srcOver</code>：都显示，但是<code>src</code>图层显示在上面</li><li><code>dstOver</code>：都显示，但是<code>dst</code>图层显示在上面</li><li><code>srcIn</code>：只显示两个图层相交的部分，并且显示的是相交部分的<code>src</code>内容</li><li><code>dstIn</code>：只显示两个图层相交的部分，并且显示的是相交部分的<code>dst</code>内容</li><li><code>srcOut</code>：显示<code>src</code>图层的内容，但是需要抠出相交的部分</li><li><code>dstOut</code>：显示<code>dst</code>图层的内容，但是需要抠出相交的部分</li><li><code>srcATop</code>：显示<code>dst</code>图层的内容，但是相交部分显示<code>src</code>图层的内容</li><li><code>dstATop</code>：显示<code>src</code>图层的内容，但是相交部分显示<code>dst</code>图层的内容</li><li><code>xor</code>：两个图层都显示，但是需要抠出相交部分</li><li><code>plus</code>：两个图层都显示，相交部分的颜色进行相加，做图像的渐变时可以使用</li><li><code>modulate</code>：只显示两个图层相交的部分，相交部分的颜色分量进行相乘，只会产生更深的颜色</li><li><code>screen</code>：两个图层都显示，相交部分的颜色分量反转后进行相乘，再将结果反转，只会产生更浅的颜色</li><li><code>overlay</code>：两个图层都显示，相交部分的颜色分量进行相乘，如果<code>dst</code>的值较小，则直接相乘；否则反转两个分量的值后进行相乘，再将结果反转。</li><li><code>darken</code>：两个图层都显示，相交部分从每个颜色的通道中选最小的值进行合成</li><li><code>lighten</code>：两个图层都显示，相交部分从每个颜色的通道中选最大的值进行合成</li><li><code>colorDodge</code>：两个图层都显示，相交部分用<code>dst</code>的颜色除以反转后的<code>src</code></li><li><code>colorBurn</code>：两个图层都显示，相交部分用反转后的<code>dst</code>除以<code>src</code>，然后再将结果反转</li><li><code>hardLight</code>：两个图层都显示，相交部分的颜色分量进行相乘，如果<code>dst</code>的值较小，则反转两个值后再进行相乘，然后再将结果反转；否则直接相乘（和<code>overlay</code>相反）</li><li><code>softLight</code>：两个图层都显示，相交部分中对低于0.5的值使用<code>colorDodge</code>模式，高于0.5的值使用<code>colorBurn</code>模式</li><li><code>difference</code>：两个图层都显示，相交部分用每个颜色通道值中较大的减去较小的</li><li><code>exclusion</code>：两个图层都显示，相交部分用两个颜色的和减去两个颜色的积的二倍</li><li><code>multiply</code>：两个图层都显示，相交部分的颜色分量进行相乘，也包含了<code>alpha</code>通道，只会产生更深的颜色（比<code>modulate</code>多一个<code>alpha</code>通道）</li><li><code>hue</code>：两个图层都显示，相交部分显示<code>src</code>的色调，但是显示<code>dst</code>的饱和度和亮度，能看出来覆盖的阴影效果</li><li><code>saturation</code>：两个图层都显示，相交部分显示<code>dst</code>的色调，但是显示<code>src</code>的饱和度和亮度，能看出来覆盖的阴影效果</li><li><code>color</code>：两个图层都显示，相交部分显示<code>src</code>的色调和饱和度，但是显示<code>dst</code>的亮度</li><li><code>luminosity</code>：两个图层都显示，相交部分显示<code>dst</code>的色度和饱和度，但是显示<code>src</code>的亮度</li></ul><h5 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h5><p>图像着色器，用于进行着色，主要是绘制一些封闭图形时填充色，可以是一个图像也可以是一个颜色。如果设置了<code>shader</code>，则<code>color</code>属性会失效。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 水平渐变</span><br>Gradient.linear(<br>    Offset from,<span class="hljs-comment">// 起始位置</span><br>    Offset to, <span class="hljs-comment">// 结束位置</span><br>    <span class="hljs-built_in">List</span>&lt;Color&gt; colors, [ <span class="hljs-comment">// 渐变的几种颜色</span><br>    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">double</span>&gt;? colorStops,<span class="hljs-comment">// 每种颜色开始的位置，取值0~1之间，表示的是进度</span><br>    <span class="hljs-comment">// clamp: 终点颜色延伸</span><br>    <span class="hljs-comment">// repeated：再次应用渐变</span><br>    <span class="hljs-comment">// mirror：镜像渐变</span><br>    <span class="hljs-comment">// decal: 不着色</span><br>    TileMode tileMode = TileMode.clamp,<span class="hljs-comment">// 超出渐变范围的模式</span><br>    Float64List? matrix4,<br>])<br><br><span class="hljs-comment">// 雷达样式渐变，从中心往外渐变</span><br>Gradient.radial(<br>    Offset center,<span class="hljs-comment">// 中心坐标</span><br>    <span class="hljs-built_in">double</span> radius,<span class="hljs-comment">// 渐变的半径</span><br>    <span class="hljs-built_in">List</span>&lt;Color&gt; colors, [ <br>    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">double</span>&gt;? colorStops,<br>    TileMode tileMode = TileMode.clamp,<br>    Float64List? matrix4,<br>    Offset? focal,<br>    <span class="hljs-built_in">double</span> focalRadius = <span class="hljs-number">0.0</span>,<br>])<br>  <span class="hljs-comment">// 扫描样式渐变</span><br>  Gradient.sweep(<br>    Offset center,<br>    <span class="hljs-built_in">List</span>&lt;Color&gt; colors, [ <br>    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">double</span>&gt;? colorStops,<br>    TileMode tileMode = TileMode.clamp,<br>    <span class="hljs-built_in">double</span> startAngle = <span class="hljs-number">0.0</span>,<span class="hljs-comment">// 起始角度</span><br>    <span class="hljs-built_in">double</span> endAngle = math.pi * <span class="hljs-number">2</span>, <span class="hljs-comment">// 终止角度</span><br>    Float64List? matrix4,<br>])<br></code></pre></td></tr></table></figure><p>对于渐变着色器，有三种可以选择，分别是水平渐变、雷达渐变、扫描渐变，这些都是一致的，注意在使用的时候它的名字和<code>material</code>包中的渐变的名字是一样的，因此使用时需要加上别名。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 需要起个别名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:ui&#x27;</span> <span class="hljs-keyword">as</span> ui;<br><br>Paint paint = Paint()<br>  ..isAntiAlias = <span class="hljs-keyword">true</span><br>  ..shader = ui.Gradient.linear(Offset(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), Offset(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>), [<br>    Colors.blue,<br>    Colors.green,<br>  ]);<br></code></pre></td></tr></table></figure><p>基本上<code>Paint</code>就以上这些属性，通过设置对应的属性来实现不同的效果，当然，如果要想进行绘制还需要有<code>Canvas</code>画布的配合。</p><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><p><code>Canvas</code>作为画布是与<code>Paint</code>互相配合的，画笔设置的是各种绘制颜色线条粗细等等，而画布则是实际进行绘制的，它提供了大量的方法，基本上都是<code>draw</code>开头的。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 绘制颜色，通常是绘制背景。注意需要先saveLayer，否则会将整个屏幕都绘制颜色</span><br><span class="hljs-keyword">void</span> drawColor(Color color, BlendMode blendMode);<br><span class="hljs-comment">// 绘制颜色，和drawColor效果一样，也需要先saveLayer</span><br><span class="hljs-keyword">void</span> drawPaint(Paint paint);<br><span class="hljs-comment">// 绘制横线，起始点和终止点确定直线</span><br><span class="hljs-keyword">void</span> drawLine(Offset p1, Offset p2, Paint paint);<br><span class="hljs-comment">// 绘制矩形</span><br><span class="hljs-keyword">void</span> drawRect(Rect rect, Paint paint);<br><span class="hljs-comment">// 绘制圆角矩形</span><br><span class="hljs-keyword">void</span> drawRRect(RRect rrect, Paint paint);<br><span class="hljs-comment">// 绘制同心圆角矩形</span><br><span class="hljs-keyword">void</span> drawDRRect(RRect outer, RRect inner, Paint paint);<br><span class="hljs-comment">// 绘制一个椭圆，实际上和绘制圆角矩形差不多</span><br><span class="hljs-keyword">void</span> drawRSuperellipse(RSuperellipse rsuperellipse, Paint paint);<br><span class="hljs-comment">// 绘制椭圆</span><br><span class="hljs-keyword">void</span> drawOval(Rect rect, Paint paint);<br><span class="hljs-comment">// 绘制圆形，给定中心点和半径</span><br><span class="hljs-keyword">void</span> drawCircle(Offset c, <span class="hljs-built_in">double</span> radius, Paint paint);<br><span class="hljs-comment">// 绘制圆弧</span><br><span class="hljs-keyword">void</span> drawArc(Rect rect, <span class="hljs-built_in">double</span> startAngle, <span class="hljs-built_in">double</span> sweepAngle, <span class="hljs-built_in">bool</span> useCenter, Paint paint);<br><span class="hljs-comment">// 绘制路径</span><br><span class="hljs-keyword">void</span> drawPath(Path path, Paint paint);<br><span class="hljs-comment">// 绘制图片</span><br><span class="hljs-keyword">void</span> drawImage(Image image, Offset offset, Paint paint);<br><span class="hljs-keyword">void</span> drawImageRect(Image image, Rect src, Rect dst, Paint paint);<br><span class="hljs-keyword">void</span> drawPicture(Picture picture);<br><span class="hljs-comment">// 绘制文字段落</span><br><span class="hljs-keyword">void</span> drawParagraph(Paragraph paragraph, Offset offset);<br></code></pre></td></tr></table></figure><p>大体上就是上述的一些绘制内容，有一点不同的就是绘制文字的方法，并没有传入<code>Paint</code>方法，而是直接传入的<code>Paragraph</code>对象即可。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="dart hljs">ui.ParagraphBuilder builder = ui.ParagraphBuilder(ui.ParagraphStyle());<br></code></pre></td></tr></table></figure><p>首先需要通过<code>ParagraphBuilder</code>构建文字段落，构造方法需要传入<code>ParagraphStyle</code>样式，主要控制文字的字体、大小、对其方式等等。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="dart hljs">ParagraphStyle(&#123;<br>    TextAlign? textAlign,<span class="hljs-comment">// 对齐方式</span><br>    TextDirection? textDirection, <span class="hljs-comment">// RTL or LTR</span><br>    <span class="hljs-built_in">int?</span> maxLines,<span class="hljs-comment">// 最大行数</span><br>    <span class="hljs-built_in">String?</span> fontFamily,<span class="hljs-comment">// 字体</span><br>    <span class="hljs-built_in">double?</span> fontSize,<span class="hljs-comment">// 字体大小</span><br>    <span class="hljs-built_in">double?</span> height,<span class="hljs-comment">// 高度</span><br>    TextHeightBehavior? textHeightBehavior,<span class="hljs-comment">// 控制高度如何显示</span><br>    FontWeight? fontWeight,<span class="hljs-comment">// 字重</span><br>    FontStyle? fontStyle,<span class="hljs-comment">//斜体</span><br>    StrutStyle? strutStyle,<span class="hljs-comment">// .</span><br>    <span class="hljs-built_in">String?</span> ellipsis,<span class="hljs-comment">// 超出限制的占位符，通常是...</span><br>    Locale? locale,<span class="hljs-comment">// 语言</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>当创建了<code>ParagraphBuilder</code>后，就可以往里面添加文案了，通过<code>addText</code>进行添加。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 入栈文本样式</span><br><span class="hljs-keyword">void</span> pushStyle(TextStyle style);<br><span class="hljs-comment">// 出栈文本样式</span><br><span class="hljs-keyword">void</span> pop();<br><span class="hljs-comment">// 添加文本，文本的样式由栈顶的TextStyle控制</span><br><span class="hljs-keyword">void</span> addText(<span class="hljs-built_in">String</span> text);<br></code></pre></td></tr></table></figure><p>并且在输出之前，必须要先进行<code>layout</code>，完整的绘制文本的逻辑如下：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 构建builder</span><br>ui.ParagraphBuilder builder = ui.ParagraphBuilder(ui.ParagraphStyle(<br>  textAlign: TextAlign.left,<br>  fontSize: <span class="hljs-number">30</span><br>));<br><br><span class="hljs-comment">// 添加文本样式</span><br>builder.pushStyle(ui.TextStyle(color: Colors.red));<br><span class="hljs-comment">// 添加文本</span><br>builder.addText(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-comment">// 构建Paragraph</span><br>ui.Paragraph paragraph =  builder.build();<br><span class="hljs-comment">// 绘制前需要layout布局</span><br>paragraph.layout(ui.ParagraphConstraints(width: size.width));<br><span class="hljs-comment">// 最后才能进行绘制</span><br>canvas.drawParagraph(paragraph, Offset.zero);<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本上，绘制方面就是这些。其实就是直接使用的<code>CustomPaint</code>，然后在需要提供的<code>CustomPainter</code>中，使用画笔和画布进行绘制。实际上我们并没有实现自定义组件，而只是实现了自定绘制部分，我们无法控制整个组件的布局操作和测量操作，只能完成绘制部分。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Fri Aug 16 2024 21:02:35 GMT+0800");let n="Fri Aug 16 2024 21:02:35 GMT+0800";n="2025-10-31 16:31:47 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Flutter/" class="post-footer-category">#&nbsp;Flutter</a> <a href="/tags/Flutter/" class="post-footer-tag">#&nbsp;Flutter</a></div><div class="nav"><div class="nav-item-prev"></div><div class="nav-item-next"><a href="/2024/07/23/flutter-getx/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Flutter强大脚手架-GetX</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#CustomPaint" class="toc-link"><span class="toc-text">CustomPaint</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#CustomPainter" class="toc-link"><span class="toc-text">CustomPainter</span></a></li><li class="toc-item toc-level-4"><a href="#Paint" class="toc-link"><span class="toc-text">Paint</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#blendMode" class="toc-link"><span class="toc-text">blendMode</span></a></li><li class="toc-item toc-level-5"><a href="#shader" class="toc-link"><span class="toc-text">shader</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#Canvas" class="toc-link"><span class="toc-text">Canvas</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-07-23</div><a href="/2024/07/23/flutter-getx/"><div class="recent-posts-item-content">Flutter强大脚手架-GetX</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-06-16</div><a href="/2024/06/16/flutter-navigator/"><div class="recent-posts-item-content">Flutter界面跳转-Navigator</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-05-02</div><a href="/2024/05/02/flutter-dart/"><div class="recent-posts-item-content">Flutter基础语言Dart</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-04-17</div><a href="/2024/04/17/flutter-widget/"><div class="recent-posts-item-content">Flutter基础组件</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-08-16</div><a href="/2024/08/16/flutter-canvas/"><div class="recent-posts-item-content">Flutter自定义绘制CustomPaint</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-07-23</div><a href="/2024/07/23/flutter-getx/"><div class="recent-posts-item-content">Flutter强大脚手架-GetX</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-06-16</div><a href="/2024/06/16/flutter-navigator/"><div class="recent-posts-item-content">Flutter界面跳转-Navigator</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-05-02</div><a href="/2024/05/02/flutter-dart/"><div class="recent-posts-item-content">Flutter基础语言Dart</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>