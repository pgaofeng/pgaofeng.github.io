<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Flutter状态管理框架Provider</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.1.1" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>43</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>17.31</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Provider" class="toc-link"><span class="toc-text">Provider</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%BC%95%E5%85%A5" class="toc-link"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%8F%90%E4%BE%9B%E7%8A%B6%E6%80%81" class="toc-link"><span class="toc-text">提供状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#Provider-1" class="toc-link"><span class="toc-text">Provider</span></a></li><li class="toc-item toc-level-4"><a href="#ChangeNotifierProvider" class="toc-link"><span class="toc-text">ChangeNotifierProvider</span></a></li><li class="toc-item toc-level-4"><a href="#ListenableProvider" class="toc-link"><span class="toc-text">ListenableProvider</span></a></li><li class="toc-item toc-level-4"><a href="#ValueListenableProvider" class="toc-link"><span class="toc-text">ValueListenableProvider</span></a></li><li class="toc-item toc-level-4"><a href="#FutureProvider" class="toc-link"><span class="toc-text">FutureProvider</span></a></li><li class="toc-item toc-level-4"><a href="#StreamProvider" class="toc-link"><span class="toc-text">StreamProvider</span></a></li><li class="toc-item toc-level-4"><a href="#ProxyProvider" class="toc-link"><span class="toc-text">ProxyProvider</span></a></li><li class="toc-item toc-level-4"><a href="#ListenableProxyProvider" class="toc-link"><span class="toc-text">ListenableProxyProvider</span></a></li><li class="toc-item toc-level-4"><a href="#ChangeNotifierProxyProvider" class="toc-link"><span class="toc-text">ChangeNotifierProxyProvider</span></a></li><li class="toc-item toc-level-4"><a href="#MultiProvider" class="toc-link"><span class="toc-text">MultiProvider</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81" class="toc-link"><span class="toc-text">使用状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#context-watch" class="toc-link"><span class="toc-text">context#watch</span></a></li><li class="toc-item toc-level-4"><a href="#context-read" class="toc-link"><span class="toc-text">context#read</span></a></li><li class="toc-item toc-level-4"><a href="#context-select" class="toc-link"><span class="toc-text">context#select</span></a></li><li class="toc-item toc-level-4"><a href="#Provider-of" class="toc-link"><span class="toc-text">Provider#of</span></a></li><li class="toc-item toc-level-4"><a href="#Consumer" class="toc-link"><span class="toc-text">Consumer</span></a></li><li class="toc-item toc-level-4"><a href="#Selector" class="toc-link"><span class="toc-text">Selector</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">8</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Flutter状态管理框架Provider thumbnail" class="image lozad" src="/img/cover/cover-flutter-provider.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Flutter状态管理框架Provider</h1></header><div class="post-meta post-show-meta"><time datetime="2024-10-05T07:01:28.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2024-10-05</span> </time><span class="dot"></span> <a href="/categories/Flutter/" class="post-meta-link">Flutter </a><span class="dot"></span> <span>约5.6k 字</span></div><div class="post-content" id="section"><p><code>Flutter</code>中最值得关注的也就是状态管理了，其根本目的在于状态提升，达到的效果是方便管理状态以及子组件中共享状态。</p><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>前面<a href="https://pgaofeng.github.io/2024/09/10/flutter-state/" rel="noopener" target="_blank">Flutter状态管理</a>我们也有探索过直接将状态提升到最顶层，但是会引起状态多层传递，散落到各个组件中，并且状态变化时会导致整个界面全部刷新，为了解决这个问题，我们可以使用<code>InheritedWidget</code>保存状态，在使用的地方通过<code>ListenableBuilder</code>+<code>ChangeNotifier</code>实现局部刷新。当然，使用起来可能会稍微复杂一些，于是我们将其封装成了一个<code>MyProvider</code>以供简化使用。</p><p>现在有这么一个三方库，它就是利用这一套逻辑进行封装，方便我们管理状态的，就是<code>Provider</code>。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>地址：<a href="https://pub.dev/packages/provider" rel="noopener" target="_blank">https://pub.dev/packages/provider</a></p><p>直接在<code>pubspec.yaml</code>中引入最新版本的即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">^6.1.5+1</span><br></code></pre></td></tr></table></figure><h3 id="提供状态"><a href="#提供状态" class="headerlink" title="提供状态"></a>提供状态</h3><p>提供状态，实际上也就是保存状态，以方便子组件获取状态。<code>Provider</code>提供多种方式提供状态，同时它本身也会对状态进行管理，在合适的时候创建和销毁，以及状态变化时将状态分发给使用的子组件。</p><h4 id="Provider-1"><a href="#Provider-1" class="headerlink" title="Provider"></a>Provider</h4><p>最简单也是最基础的提供一个状态值，通过<code>Provider</code>构造函数进行声明。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="dart hljs">Provider(&#123;<br>    Key? key,<br>    <span class="hljs-comment">// 构建新的值</span><br>    <span class="hljs-keyword">required</span> Create&lt;T&gt; create,<br>    <span class="hljs-comment">// 组件被移除时调用</span><br>    Dispose&lt;T&gt;? dispose,<br>    <span class="hljs-comment">// 是否懒加载，默认懒加载</span><br>    <span class="hljs-built_in">bool?</span> lazy,<br>    <span class="hljs-comment">// 构建子组件的代码块，主要是提供了context</span><br>    TransitionBuilder? builder,<br>    <span class="hljs-comment">// 子组件，当设置了builder后，界面默认不会使用child，需要在构建时加入</span><br>    Widget? child,<br>&#125;)<br><br><span class="hljs-comment">// 对外提供的值是一个已有的值</span><br>Provider.value(&#123;<br>    Key? key,<br>    <span class="hljs-comment">// 已有的值</span><br>    <span class="hljs-keyword">required</span> T value,<br>    <span class="hljs-comment">// 当值变化时是否需要通知子组件更新</span><br>    UpdateShouldNotify&lt;T&gt;? updateShouldNotify,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;)<br></code></pre></td></tr></table></figure><p>状态创建的代码块是必选的，其他参数都是可选的，使用起来也是非常简单，直接将其放置在顶层作为父组件即可，子组件中就能查到对应的数据。一共两个方法可供选择使用，直接调用<code>Provider</code>需要在<code>create</code>中创建一个新的值，如果这个值已经存在，只是想要将其暴露出去的话，使用<code>Provider.value</code>方式。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> HomeWidget(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 使用Provider提供了一个颜色，红色</span><br>    <span class="hljs-keyword">return</span> Provider&lt;Color&gt;(<br>      create: (_) =&gt; Colors.red,<br>      child: ChildWidget(),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 子组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> ChildWidget(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      width: <span class="hljs-number">100</span>,<br>      height: <span class="hljs-number">100</span>,<br>      <span class="hljs-comment">// 子组件中可以直接获取到对应的值</span><br>      color: context.watch&lt;Color&gt;(),<br>      child: TextButton(<br>        onPressed: () &#123;&#125;,<br>        child: Center(child: Text(<span class="hljs-string">&#x27;Button&#x27;</span>)),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码主要逻辑就是通过<code>Provider</code>提供了一个颜色值，然后在它子组件中能够获取到对应的值并进行使用，其实我们没必要将它们单独拆分成两个组件，合在一起也是一样的效果：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> HomeWidget(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Provider&lt;Color&gt;(<br>      create: (_) &#123;<br>        <span class="hljs-keyword">return</span> Colors.red;<br>      &#125;,<br>      <span class="hljs-comment">// 直接将子组件合并在一块</span><br>      child: Container(<br>        width: <span class="hljs-number">100</span>,<br>        height: <span class="hljs-number">100</span>,<br>        <span class="hljs-comment">// 获取父组件Provider提供的颜色 ERROR</span><br>        color: context.watch&lt;Color&gt;(),<br>        child: TextButton(<br>          onPressed: () &#123;&#125;,<br>          child: Center(child: Text(<span class="hljs-string">&#x27;Button&#x27;</span>)),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意以上逻辑，当父组件和子组件合并在一块时，运行会直接报错，而报错原因就在于我们获取状态所用的<code>context</code>，它并不是子组件<code>Container</code>的<code>context</code>，因此无法找到对应的状态而报错。所以我们需要拿到子组件的<code>context</code>，我们可以在子组件外再包一层<code>Builder</code>或者直接使用参数<code>builder</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> HomeWidget(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Provider&lt;Color&gt;(<br>      create: (_) =&gt; Colors.red,<br>      <span class="hljs-comment">// 通过builder构建子组件，能够提供context</span><br>      builder: (context, child) =&gt; Container(<br>        width: <span class="hljs-number">100</span>,<br>        height: <span class="hljs-number">100</span>,<br>        color: context.watch&lt;Color&gt;(),<br>        child: TextButton(<br>          onPressed: () &#123;&#125;,<br>          child: Center(child: Text(<span class="hljs-string">&#x27;Button&#x27;</span>)),<br>        ),<br>      ),<br>      <span class="hljs-comment">// 或者使用Builder再包一层</span><br>     <span class="hljs-comment">// child: Builder(builder: (context) =&gt; Container(</span><br>     <span class="hljs-comment">//   width: 100,</span><br>     <span class="hljs-comment">//   height: 100,</span><br>     <span class="hljs-comment">//   color: context.watch&lt;Color&gt;(),</span><br>     <span class="hljs-comment">//  child: TextButton(</span><br>     <span class="hljs-comment">//     onPressed: () &#123;&#125;,</span><br>     <span class="hljs-comment">//     child: Center(child: Text(&#x27;Button&#x27;)),</span><br>     <span class="hljs-comment">//   )</span><br>     <span class="hljs-comment">// ),</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种提供一个单值的方式作用不大，既然是提供状态，我们的目的肯定是一个能够变化的状态值，这种提供单值的情况下无法变化状态。或许我可以传一个<code>ChangeNotifier</code>呢？传<code>ChangeNotifier</code>当然是可以的，但是我们一般也不会这样用，我们会直接使用<code>ChangeNotifierProvider</code>。</p><h4 id="ChangeNotifierProvider"><a href="#ChangeNotifierProvider" class="headerlink" title="ChangeNotifierProvider"></a>ChangeNotifierProvider</h4><p><code>ChangeNotifierProvider</code>的参数列表和<code>Provider</code>是一致的，只是它限定了传递的参数类型必须是<code>ChangeNotifier</code>的子类。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="dart hljs">ChangeNotifierProvider(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> Create&lt;T&gt; create,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;)<br>    <br>ChangeNotifierProvider.value(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> T value,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意<code>ChangeNotifierProvider</code>也是提供了两个构造方法，和<code>Provider</code>基本上时一致的，如果对外暴露的是一个新创建的<code>ChangeNotifier</code>，则使用默认构造函数声明；如果这个<code>ChangeNotifier</code>已经存在了，我们只是想要将其暴露给外面，则使用<code>value</code>的构造函数。</p><h4 id="ListenableProvider"><a href="#ListenableProvider" class="headerlink" title="ListenableProvider"></a>ListenableProvider</h4><p><code>ListenableProvider</code>和<code>ChangeNotifierProvider</code>是一样的，参数列表是一模一样的，唯一的区别就是<code>ListenableProvider</code>限定的类型是<code>Listenable</code>，比<code>ChangeNotifier</code>更灵活一些。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="dart hljs">ListenableProvider(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> Create&lt;T&gt; create,<br>    Dispose&lt;T&gt;? dispose, <span class="hljs-comment">// 多了一个dispose参数</span><br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;)<br>    <br>ListenableProvider.value(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> T value,<br>    <span class="hljs-comment">// 数据变化时是否通知依赖的子组件更新</span><br>    UpdateShouldNotify&lt;T&gt;? updateShouldNotify,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;) <br></code></pre></td></tr></table></figure><p><code>ChangeNotifierProvider</code>提供的是一个<code>ChangeNotifier</code>类型的数据，并且当该组件被移除时，会自动调用<code>ChangeNotifier#dispose</code>来情况监听者，它是继承自<code>ListenableProvider</code>的。<code>ListenableProvider</code>限定的数据类型是<code>Listenable</code>类型的，并且不会自动移除监听者，需要手动传入<code>dispose</code>参数来自己管理。</p><h4 id="ValueListenableProvider"><a href="#ValueListenableProvider" class="headerlink" title="ValueListenableProvider"></a>ValueListenableProvider</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="dart hljs">ValueListenableProvider.value(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> ValueListenable&lt;T&gt; value,<br>    UpdateShouldNotify&lt;T&gt;? updateShouldNotify,<br>    Widget? child,<br>&#125;)<br></code></pre></td></tr></table></figure><p>对外暴露一个<code>ValueListenable</code>类型的数据，注意这里只有一个<code>.value</code>的命名构造方法，也就是只能通过它来暴露一个数据，而不能直接创建一个数据。</p><h4 id="FutureProvider"><a href="#FutureProvider" class="headerlink" title="FutureProvider"></a>FutureProvider</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="dart hljs">FutureProvider(&#123;<br>    Key? key,<br>    <span class="hljs-comment">// 创建一个Future</span><br>    <span class="hljs-keyword">required</span> Create&lt;Future&lt;T&gt;?&gt; create,<br>    <span class="hljs-comment">// 初始值</span><br>    <span class="hljs-keyword">required</span> T initialData,<br>    <span class="hljs-comment">// 错误异常</span><br>    ErrorBuilder&lt;T&gt;? catchError,<br>    UpdateShouldNotify&lt;T&gt;? updateShouldNotify,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;)<br>    <br>FutureProvider.value(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> Future&lt;T&gt;? value,<br>    <span class="hljs-keyword">required</span> T initialData,<br>    ErrorBuilder&lt;T&gt;? catchError,<br>    UpdateShouldNotify&lt;T&gt;? updateShouldNotify,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>FutureProvider</code>的作用是提供一个创建可能比较耗时的对象，它先提供一个初始值供子组件使用，当执行完耗时操作后再返回出新的对象来更新子组件。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 提供一个颜色</span><br>FutureProvider&lt;Color&gt;(<br>  create: (_) <span class="hljs-keyword">async</span> &#123;<br>     <span class="hljs-comment">// 获取这个颜色比较耗时，需要3秒</span><br>     <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>));<br>     <span class="hljs-keyword">return</span> Colors.blue;<br>   &#125;,<br>   <span class="hljs-comment">// 提供一个默认的初始值红色</span><br>   initialData: Colors.red,<br>   child: Builder(<br>     builder: (context) &#123;<br>       <span class="hljs-comment">// 获取到颜色</span><br>       <span class="hljs-keyword">final</span> color = context.watch&lt;Color&gt;();<br>       <span class="hljs-keyword">return</span> Container(<br>         width: <span class="hljs-number">100</span>,<br>         height: <span class="hljs-number">100</span>,<br>         <span class="hljs-comment">// 使用颜色</span><br>         color: color,<br>         child: TextButton(<br>           onPressed: () &#123;&#125;,<br>           child: Center(child: Text(<span class="hljs-string">&#x27;Button&#x27;</span>)),<br>         ),<br>       );<br>     &#125;,<br>   ),<br>);<br></code></pre></td></tr></table></figure><p>以上的效果就是界面显示一个红色的方块，然后过了三秒后变成蓝色。</p><h4 id="StreamProvider"><a href="#StreamProvider" class="headerlink" title="StreamProvider"></a>StreamProvider</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="dart hljs">StreamProvider(&#123;<br>    Key? key,<br>    <span class="hljs-comment">// 提供一个Stream</span><br>    <span class="hljs-keyword">required</span> Create&lt;Stream&lt;T&gt;?&gt; create,<br>    <span class="hljs-comment">// 提供的初始值</span><br>    <span class="hljs-keyword">required</span> T initialData,<br>    ErrorBuilder&lt;T&gt;? catchError,<br>    UpdateShouldNotify&lt;T&gt;? updateShouldNotify,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;)<br>    <br>StreamProvider.value(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> Stream&lt;T&gt;? value,<br>    <span class="hljs-keyword">required</span> T initialData,<br>    ErrorBuilder&lt;T&gt;? catchError,<br>    UpdateShouldNotify&lt;T&gt;? updateShouldNotify,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>StreamProvider</code>和<code>FutureProvider</code>基本上是一样的，构造方法的参数列表基本上也是一样的，只不过一个是提供的<code>Future</code>类型的数据，一个是提供<code>Stream</code>类型数据。</p><h4 id="ProxyProvider"><a href="#ProxyProvider" class="headerlink" title="ProxyProvider"></a>ProxyProvider</h4><p><code>ProxyProvider</code>的作用是根据外部其他状态来提供新状态，前面我们提到的各种<code>Provider</code>都是直接创建一个新的对象或者对外暴露已有的对象，不涉及其他<code>Provider</code>。而<code>ProxyProvider</code>却是根据别的<code>Provider</code>提供的对象来提供新的对象。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="dart hljs">ProxyProvider0(&#123;<br>    Key? key,<br>    <span class="hljs-comment">// 创建一个初始值</span><br>    Create&lt;R&gt;? create,<br>    <span class="hljs-comment">// 当状态变化时调用</span><br>    <span class="hljs-keyword">required</span> R <span class="hljs-built_in">Function</span>(BuildContext context, R? value) update,<br>    UpdateShouldNotify&lt;R&gt;? updateShouldNotify,<br>    Dispose&lt;R&gt;? dispose,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>  &#125;)<br></code></pre></td></tr></table></figure><p><code>ProxyProvider0</code>接受一个参数，该参数就是它提供的类型，其中参数<code>create</code>会创建一个初始值，随后会调用<code>update</code>来进行更新，后续依赖的对象发生变化时，都会调用<code>update</code>来返回一个新的值。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="dart hljs">ProxyProvider0&lt;<span class="hljs-built_in">String</span>&gt;(<br>  update: (BuildContext context, <span class="hljs-built_in">String?</span> value) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;蓝色&#x27;</span>;<br>   &#125;,<br>   child: Builder(<br>     builder: (context) &#123;  <br>       <span class="hljs-comment">// 子组件可以获取到依赖的值</span><br>       <span class="hljs-keyword">final</span> text = context.watch&lt;<span class="hljs-built_in">String</span>&gt;();<br>       <span class="hljs-keyword">return</span> Container(<br>         width: <span class="hljs-number">100</span>,<br>         height: <span class="hljs-number">100</span>,<br>         child: TextButton(<br>            onPressed: () &#123;&#125;,<br>            child: Center(child: Text(text)),<br>         ),<br>       );<br>     &#125;,<br>  ),<br>);<br></code></pre></td></tr></table></figure><p>对于<code>ProxyProvider0</code>而言，它实际上是不需要依赖于别的<code>Provider</code>的，本身就能直接提供一个对象，类似于<code>Provider</code>。当然，如果想要依赖的话，也是可以的。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 定义了一个ChangeNotifier，并添加了一个Color属性</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleController</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>  Color _color = Colors.red;<br><br>  <span class="hljs-keyword">get</span> color =&gt; _color;<br>  <span class="hljs-keyword">set</span> color(value) &#123;<br>    _color = value;<br>    notifyListeners();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用ChangeNotifierProvider将这个参数提供出去</span><br>ChangeNotifierProvider&lt;CircleController&gt;(<br>  create: (_) =&gt; CircleController(),<br>  <span class="hljs-comment">// 子组件是一个ProxyProvider0，提供的参数是String类型</span><br>  child: ProxyProvider0&lt;<span class="hljs-built_in">String</span>&gt;(<br>      <span class="hljs-comment">// 这个参数preview是前一次的数据，对于第一次调用update时，</span><br>      <span class="hljs-comment">// 如果有create，则是create返回的初始值，否则为null，</span><br>      update: (BuildContext context, <span class="hljs-built_in">String?</span> preview) &#123;<br>      <span class="hljs-keyword">final</span> controller = context.watch&lt;CircleController&gt;();<br>      <span class="hljs-keyword">if</span> (controller.color == Colors.red) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;红色&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;蓝色&#x27;</span>;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 子组件      </span><br>    child:Container() ...<br>  ),<br>);<br></code></pre></td></tr></table></figure><p>也就是我们在<code>update</code>的时候去依赖了其他<code>Provider</code>提供的对象，然后根据这个对象将其进行转换，然后返回新的数据。为了渐变，他们还提供了已经帮我们依赖好的方法，就是<code>ProxyProvider</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="dart hljs">ProxyProvider(&#123;<br>    Key? key,<br>    Create&lt;R&gt;? create,<br>    <span class="hljs-comment">// T是依赖的类型，R是返回的类型</span><br>    <span class="hljs-keyword">required</span> ProxyProviderBuilder&lt;T, R&gt; update,<br>    UpdateShouldNotify&lt;R&gt;? updateShouldNotify,<br>    Dispose&lt;R&gt;? dispose,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;)<br>    <br><span class="hljs-comment">// 它的update类型如下</span><br><span class="hljs-keyword">typedef</span> ProxyProviderBuilder&lt;T, R&gt; = R <span class="hljs-built_in">Function</span>(<br>  BuildContext context,<br>  T value,<span class="hljs-comment">// 依赖的对象</span><br>  R? previous,<span class="hljs-comment">// 上一次的值</span><br>);<br></code></pre></td></tr></table></figure><p>也就是说，如果我们需要根据一个依赖的对象来返回另一个对象，则可以使用<code>ProxyProvider</code>，此时在<code>update</code>中就能直接通过<code>value</code>参数访问依赖的对象了，而不需要手动去<code>context.watch</code>了。</p><p>如果依赖两个或对象多个对象，则使用相应后缀的方法即可：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 不依赖对象，想要依赖的话自己在update中通过context建立依赖</span><br>ProxyProvider0&lt;R&gt;<br><span class="hljs-comment">// 依赖一个对象，在update中通过value访问</span><br>ProxyProvider&lt;T, R&gt;<br><span class="hljs-comment">// 依赖两个对象，在update中通过value和value1访问</span><br>ProxyProvider2&lt;T, T2, R&gt;<br>ProxyProvider3&lt;T, T2, T3, R&gt;<br>ProxyProvider4&lt;T, T2, T3, T4, R&gt;<br>ProxyProvider5&lt;T, T2, T3, T4, T5, R&gt;<br>ProxyProvider6&lt;T, T2, T3, T4, T5, T6, R&gt;<br></code></pre></td></tr></table></figure><p>简单来说，<code>ProxyProvider</code>更类似于一个<code>map</code>转换函数，根据依赖的对象来转换成新的数据，并将其提供出去。</p><h4 id="ListenableProxyProvider"><a href="#ListenableProxyProvider" class="headerlink" title="ListenableProxyProvider"></a>ListenableProxyProvider</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="dart hljs">ListenableProxyProvider0(&#123;<br>  Key? key,<br>  Create&lt;R&gt;? create,<br>  <span class="hljs-comment">// update参数必选，preview是前一次调用时的数据</span><br>  <span class="hljs-keyword">required</span> R <span class="hljs-built_in">Function</span>(BuildContext, R? previous) update,<br>  Dispose&lt;R&gt;? dispose,<br>  UpdateShouldNotify&lt;R&gt;? updateShouldNotify,<br>  <span class="hljs-built_in">bool?</span> lazy,<br>  TransitionBuilder? builder,<br>  Widget? child,<br>&#125;)<br></code></pre></td></tr></table></figure><p>普通的<code>ListenableProvider</code>直接创建或者暴露一个<code>Listenable</code>，不涉及其他外部参数。而<code>ListenableProxyProvider</code>虽然也是提供一个<code>Listenable</code>类型的数据，但是它在创建<code>Listenable</code>时需要依赖外部其他的对象或者说其他<code>Provider</code>提供的数据。其实就和<code>ProxyProvider</code>是一样的，也根据依赖的对象的个数创建了一系列的类：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 默认不依赖对象，如果想依赖，则可以在update中自己通过context去依赖</span><br>ListenableProxyProvider0&lt;R <span class="hljs-keyword">extends</span> Listenable?&gt;<br><span class="hljs-comment">// 依赖一个对象，在update中通过value访问</span><br>ListenableProxyProvider&lt;T, R <span class="hljs-keyword">extends</span> Listenable?&gt;<br><span class="hljs-comment">// 依赖两个对象，在update中通过value和value1访问</span><br>ListenableProxyProvider2&lt;T, T2, R <span class="hljs-keyword">extends</span> Listenable?&gt;<br>ListenableProxyProvider3&lt;T, T2, T3, R <span class="hljs-keyword">extends</span> Listenable?&gt;<br>ListenableProxyProvider4&lt;T, T2, T3, T4, R <span class="hljs-keyword">extends</span> Listenable?&gt;<br>ListenableProxyProvider5&lt;T, T2, T3, T4, T5, R <span class="hljs-keyword">extends</span> Listenable?&gt;<br>ListenableProxyProvider6&lt;T, T2, T3, T4, T5, T6, R <span class="hljs-keyword">extends</span> Listenable?&gt;<br></code></pre></td></tr></table></figure><h4 id="ChangeNotifierProxyProvider"><a href="#ChangeNotifierProxyProvider" class="headerlink" title="ChangeNotifierProxyProvider"></a>ChangeNotifierProxyProvider</h4><p>大体上都是同一样的逻辑，限定了提供对象类型为<code>ChangeNotifier</code>，但是创建<code>ChangeNotifier</code>时又需要依赖于外部其他对象，因此使用带<code>proxy</code>的方法来创建。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs">ChangeNotifierProxyProvider0(&#123;<br>    Key? key,<br>    <span class="hljs-comment">// create也是必选的</span><br>    <span class="hljs-keyword">required</span> Create&lt;R&gt; create,<br>    <span class="hljs-comment">// update也是必选的</span><br>    <span class="hljs-keyword">required</span> R <span class="hljs-built_in">Function</span>(BuildContext, R? value) update,<br>    <span class="hljs-built_in">bool?</span> lazy,<br>    TransitionBuilder? builder,<br>    Widget? child,<br>&#125;)<br></code></pre></td></tr></table></figure><p>它和前面的几个<code>Proxy</code>类型区别就是，它的<code>create</code>也是必选的用于创建初始值，后续当依赖的对象发生变化时会触发<code>update</code>，而我们在<code>update</code>中也不要直接创建一个新的<code>ChangeNotifier</code>，而是应该通过<code>getter/setter</code>方法来对其进行更新，然后再返回。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 不依赖于其他对象，如果要依赖可以在update中手动处理</span><br>ChangeNotifierProxyProvider0&lt;R <span class="hljs-keyword">extends</span> ChangeNotifier?&gt;<br><span class="hljs-comment">// 依赖一个对象，在update中通过value访问</span><br>ChangeNotifierProxyProvider&lt;T, R <span class="hljs-keyword">extends</span> ChangeNotifier?&gt;<br><span class="hljs-comment">// 依赖两个对象，在update中通过value和value1访问</span><br>ChangeNotifierProxyProvider2&lt;T, T2, R <span class="hljs-keyword">extends</span> ChangeNotifier?&gt;<br>ChangeNotifierProxyProvider3&lt;T, T2, T3, R <span class="hljs-keyword">extends</span> ChangeNotifier?&gt;<br>ChangeNotifierProxyProvider4&lt;T, T2, T3, T4, R <span class="hljs-keyword">extends</span> ChangeNotifier?&gt;<br>ChangeNotifierProxyProvider5&lt;T, T2, T3, T4, T5, R <span class="hljs-keyword">extends</span> ChangeNotifier?&gt;<br>ChangeNotifierProxyProvider6&lt;T, T2, T3, T4, T5, T6, R <span class="hljs-keyword">extends</span> ChangeNotifier?&gt;<br></code></pre></td></tr></table></figure><h4 id="MultiProvider"><a href="#MultiProvider" class="headerlink" title="MultiProvider"></a>MultiProvider</h4><p>正常一个<code>Provider</code>只能提供一个值，如果想要提供多个值的话，可以使用<code>MultiProvider</code>，它能够组合多个<code>Provider</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs">MultiProvider(&#123;<br>    Key? key,<br>    <span class="hljs-comment">// Provider集合</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-built_in">List</span>&lt;SingleChildWidget&gt; providers,<br>    <span class="hljs-comment">// 子组件</span><br>    Widget? child,<br>    <span class="hljs-comment">// 构建子组件</span><br>    TransitionBuilder? builder,<br>&#125;)<br></code></pre></td></tr></table></figure><p>当使用<code>MultiProvider</code>时，会忽略它合并的多个<code>Provider</code>的子组件，而是使用它自己的子组件。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="dart hljs">MultiProvider(<br>  providers: [<br>    Provider(create: (_) =&gt; CircleController()),<br>    ChangeNotifierProvider(create: (_)=&gt;MyChangeNotifier()),<br>  ],    <br>  <span class="hljs-comment">// 子组件</span><br>  child: <br>)<br></code></pre></td></tr></table></figure><p>子组件中，可以访问<code>providers</code>中提供的所有的数据。</p><h3 id="使用状态"><a href="#使用状态" class="headerlink" title="使用状态"></a>使用状态</h3><h4 id="context-watch"><a href="#context-watch" class="headerlink" title="context#watch"></a>context#watch</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">T watch&lt;T&gt;() &#123;<br>  return Provider.of&lt;T&gt;(this);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>Context</code>的拓展方法<code>watch</code>获取到依赖的数据，并且会建立一个依赖关系，当<code>watch</code>的数据发生变化时，会主动进行刷新。该方法只能在<code>StatelessWidget#build</code>或者<code>State#build</code>中调用。使用方式如下：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 创建一个对象，持有颜色状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleController</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>  Color _color = Colors.red;<br><br>  <span class="hljs-keyword">get</span> color =&gt; _color;<br>  <span class="hljs-keyword">set</span> color(value) &#123;<br>    _color = value;<br>    notifyListeners();<br>  &#125;<br>&#125;<br><br>ChangeNotifierProvider&lt;CircleController&gt;(<br>  create: (_) =&gt; CircleController(),<br>  child: Builder(<br>    builder: (context) &#123;<br>      <span class="hljs-comment">// 获取到依赖的对象</span><br>      <span class="hljs-keyword">final</span> controller = context.watch&lt;CircleController&gt;();<br>      <span class="hljs-keyword">return</span> Container(<br>        width: <span class="hljs-number">100</span>,<br>        height: <span class="hljs-number">100</span>,<br>        <span class="hljs-comment">// 使用颜色</span><br>        color: controller.color,<br>        child: TextButton(<br>          onPressed: () &#123;<br>            <span class="hljs-comment">//点击按钮时修改颜色</span><br>            controller.color = Colors.blue;<br>          &#125;,<br>          child: Center(child: Text(<span class="hljs-string">&#x27;Button&#x27;</span>)),<br>        ),<br>      );<br>    &#125;,<br>  ),<br>)<br></code></pre></td></tr></table></figure><p>如上示例，在子组件中通过<code>watch</code>获取到<code>CircleController</code>时，会自动建立依赖关系。当点击按钮时修改了<code>CircleController</code>的颜色属性，<code>Provider</code>就会自动通知到我们触发重建，从而响应变化。</p><h4 id="context-read"><a href="#context-read" class="headerlink" title="context#read"></a>context#read</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="dart hljs">T read&lt;T&gt;() &#123;<br>  <span class="hljs-keyword">return</span> Provider.of&lt;T&gt;(<span class="hljs-keyword">this</span>, listen: <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>read</code>也是获取依赖的数据的，它和<code>watch</code>的区别就是本身不会建立依赖关系，也就是获取到状态后，即使状态发生了变化，也不会触发自身的重建，从而无法响应状态的变化。例如前面的例子中，将<code>watch</code>直接改为<code>read</code>，再点击按钮时发现是没有任何变化的。</p><h4 id="context-select"><a href="#context-select" class="headerlink" title="context#select"></a>context#select</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="dart hljs">R select&lt;T, R&gt;(R <span class="hljs-built_in">Function</span>(T value) selector) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>当使用<code>watch</code>获取状态时，例如获取一个<code>ChangeNotifier</code>，此时该组件会与<code>ChangeNotifier</code>建立关系，当它内部的任意一个属性变化时（同时触发了<code>notifyListeners</code>），都会导致该组件重建。而使用<code>select</code>则可以有选择性的与某几个属性建立依赖关系。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="dart hljs">ChangeNotifierProvider&lt;CircleController&gt;(<br>  create: (_) =&gt; CircleController(),<br>  child: Builder(<br>    builder: (context) &#123;<br>      <span class="hljs-comment">// 获取到依赖的对象的具体字段</span><br>      <span class="hljs-keyword">final</span> color = context.select&lt;CircleController,Color&gt;((value)=&gt;value.color);<br>      <span class="hljs-keyword">return</span> Container(<br>        width: <span class="hljs-number">100</span>,<br>        height: <span class="hljs-number">100</span>,<br>        <span class="hljs-comment">// 使用颜色</span><br>        color: color,<br>        child: TextButton(<br>          onPressed: () &#123;<br>            <span class="hljs-comment">//点击按钮时修改颜色会触发重建</span><br>            context.read&lt;CircleController&gt;().color = Colors.blue;<br>            <span class="hljs-comment">// 如果修改别的属性就不会触发重建</span><br>            <span class="hljs-comment">// context.read&lt;CircleController&gt;().size += 40;</span><br>          &#125;,<br>          child: Center(child: Text(<span class="hljs-string">&#x27;Button&#x27;</span>)),<br>        ),<br>      );<br>    &#125;,<br>  ),<br>)<br></code></pre></td></tr></table></figure><h4 id="Provider-of"><a href="#Provider-of" class="headerlink" title="Provider#of"></a>Provider#of</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">static</span> T of&lt;T&gt;(BuildContext context, &#123;<span class="hljs-built_in">bool</span> listen = <span class="hljs-keyword">true</span>&#125;) &#123;...&#125;<br></code></pre></td></tr></table></figure><p>实际上，前面的<code>watch</code>和<code>read</code>都是对<code>Provider#of</code>方法的包装而已，他们的区别就是<code>listen</code>的取值。当取值为<code>true</code>时，表示获取状态时并且建立关联，此时也就相当于<code>watch</code>，当状态发生变化时会通知依赖方进行重建。取值为<code>false</code>时表明不会建立关联。</p><p>前面这几个方法都是通过<code>context</code>获取的，这就很容易造成<code>context</code>滥用的情况，从而导致无法完成局部刷新。也就是说，在通过<code>watch</code>、<code>select</code>、<code>Proivider.of(context, listen:true)</code>获取依赖值并建立关联时，是与<code>context</code>所属的组件建立的关联，当触发刷新时会导致<code>context</code>所在的组件被<code>rebuild</code>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleController</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>  Color _color = Colors.red;<br><br>  <span class="hljs-keyword">get</span> color =&gt; _color;<br>  <span class="hljs-keyword">set</span> color(value) &#123;<br>    _color = value;<br>    notifyListeners();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如有一个<code>ChangeNotifierProvider</code>提供了上面这个<code>CircleController</code>，然后对应的子组件如下：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyWidget(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 获取到CircleController并建立依赖关系</span><br>    <span class="hljs-keyword">final</span> controller = context.watch&lt;CircleController&gt;();<br><br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        Container(<br>          width: <span class="hljs-number">80</span>,<br>          height: <span class="hljs-number">80</span>,<br>          color: Colors.green,<br>          child: Text(<span class="hljs-string">&#x27;One&#x27;</span>),<br>        ),<br>        Container(<br>          width: <span class="hljs-number">80</span>,<br>          height: <span class="hljs-number">80</span>,<br>          color: controller.color,<br>          child: TextButton(<br>            onPressed: ()&#123;<br>              <span class="hljs-comment">// 点击按钮时修改颜色</span><br>              controller.color = Colors.yellow;<br>            &#125;,<br>            child: Text(<span class="hljs-string">&#x27;Two&#x27;</span>)<br>          ),<br>        ),<br>        Container(<br>          width: <span class="hljs-number">80</span>,<br>          height: <span class="hljs-number">80</span>,<br>          color: Colors.blue,<br>          child: Text(<span class="hljs-string">&#x27;Three&#x27;</span>),<br>        ),<br>      ],<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述子组件中，包含了一个<code>Column</code>，然后里面放了三个<code>Container</code>，其中第二个<code>Container</code>使用了<code>controller</code>中的颜色，并且在点击时修改了颜色。</p><p>注意，调用<code>watch</code>的<code>context</code>是<code>MyWidget</code>的<code>context</code>，但是实际用到的却只有它内部的一个<code>Container</code>，但是当颜色发生变化时，刷新是刷的<code>MyWidget</code>，也就是说会重新调用<code>MyWidget#build</code>来构建。这显然与我们的预期不符了，我们应该只想要<code>Container</code>进行重建，其他组件包括<code>Container</code>内部的<code>TextButton</code>都不发生重建。</p><p>当然了我们可以使用<code>Builder</code>来获取对应的<code>Context</code>:</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 将第二个Container用Builder包一下来获取context</span><br>Builder(builder: (context) &#123;<br>  <span class="hljs-comment">// 此时的Context是Builder的</span><br>  <span class="hljs-keyword">final</span> controller = context.watch&lt;CircleController&gt;();<br>  <span class="hljs-keyword">return</span> Container(<br>    width: <span class="hljs-number">80</span>,<br>    height: <span class="hljs-number">80</span>,<br>    color: controller.color,<br>    child: TextButton(<br>      onPressed: ()&#123;<br>        <span class="hljs-comment">// 点击按钮时修改颜色</span><br>        controller.color = Colors.yellow;<br>      &#125;,<br>      child: Text(<span class="hljs-string">&#x27;Two&#x27;</span>)<br>    ),<br>  );<br>&#125;),<br></code></pre></td></tr></table></figure><p>通过这种方式，可以将刷新范围限定在<code>Builder</code>中，也就是当点击按钮修改了颜色之后，并不会导致整个<code>MyWidget</code>的重建，而只会重建这个<code>Builder</code>。当然，这基本上已经能满足我们的需求了，实现了局部的刷新，但我们要求的可能还要更高一些，我们想只有<code>Container</code>重建，它内部的<code>child</code>不需要重建，通过这种方式就很难完成了。</p><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="dart hljs">Consumer(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-comment">// 不可变部分可以放在child避免重建</span><br>    Widget? child,<br>&#125;)<br></code></pre></td></tr></table></figure><p>前面几种获取状态的方法都是通过<code>context</code>获取的，也就是说需要我们手动去<code>watch</code>，很容易导致<code>context</code>的滥用而导致刷新范围不可控。使用<code>Consumer</code>就可以非常容易的控制范围，例如前面的那个<code>Container</code>刷新问题，就可以使用<code>Consumer</code>进行优化：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="dart hljs">Consumer&lt;CircleController&gt;(<br>  <span class="hljs-comment">// 可以直接拿到依赖的controller</span><br>  builder: (context, controller, child) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>       width: <span class="hljs-number">80</span>,<br>       height: <span class="hljs-number">80</span>,<br>       color: controller.color,<br>       child: TextButton(<br>         onPressed: ()&#123;<br>           controller.color = Colors.yellow;<br>         &#125;,<br>         child: Text(<span class="hljs-string">&#x27;Two&#x27;</span>)<br>       ),<br>     );<br>  &#125;,<br>),<br></code></pre></td></tr></table></figure><p>其实也就是避免了我们手写<code>watch</code>了，当然它还提供了一个<code>child</code>属性，我们可以将<code>Container</code>的<code>child</code>放在外面声明，然后直接应用就行了，这样刷新时就只会刷新<code>Container</code>，而不会刷新按钮了。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="dart hljs">Consumer&lt;CircleController&gt;(<br>  builder: (context, controller, child) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      width: <span class="hljs-number">80</span>,<br>      height: <span class="hljs-number">80</span>,<br>      color: controller.color,<br>      <span class="hljs-comment">// 不变部分直接引用就行</span><br>      child: child,<br>    );<br>  &#125;,<br>  <span class="hljs-comment">// 不变部分声明在这里</span><br>  child: TextButton(<br>    onPressed: () &#123;<br>      <span class="hljs-comment">// 只是read，不建立依赖关系，所以使用哪个context没啥太大的影响</span><br>      context.read&lt;CircleController&gt;().color = Colors.yellow;<br>    &#125;,<br>    child: Text(<span class="hljs-string">&#x27;Two&#x27;</span>),<br>  ),<br>),<br></code></pre></td></tr></table></figure><p>这是只依赖一个对象的<code>Consumer</code>，还可以选择<code>Consumer2</code>、<code>Consumer3</code>…</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 依赖一个对象，可以在builder中通过value访问</span><br>Consumer&lt;T&gt;<br><span class="hljs-comment">// 依赖两个对象，可以在builder中通过value和value2访问</span><br>Consumer2&lt;A, B&gt;<br>Consumer3&lt;A, B, C&gt;<br>Consumer4&lt;A, B, C, D&gt;<br>Consumer5&lt;A, B, C, D, E&gt;<br>Consumer6&lt;A, B, C, D, E, F&gt;<br></code></pre></td></tr></table></figure><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>前面的<code>Consumer</code>其实对应的就是<code>watch</code>的封装，它观察的是整个控制<code>ChangeNotifier</code>，不论它内部的任何属性变化，只要调用了<code>notifyListeners</code>就会导致组件的重建。而可能有时候我们这个组件只使用了一个字段，只需要这个字段变化时重建就行，而不关注其他字段。</p><p><code>Selector</code>其实做的就是这个工作，也就是对<code>select</code>的封装而已：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs">Selector(&#123;<br>    Key? key,<br>    <span class="hljs-comment">// 构建组件树</span><br>    <span class="hljs-keyword">required</span> ValueWidgetBuilder&lt;S&gt; builder,<br>    <span class="hljs-comment">// 选择依赖哪些字段</span><br>    <span class="hljs-keyword">required</span> S <span class="hljs-built_in">Function</span>(BuildContext, A) selector,<br>    ShouldRebuild&lt;S&gt;? shouldRebuild,<br>    Widget? child,<br>&#125;)<br></code></pre></td></tr></table></figure><p>同样的，还是对前面的那个<code>Container</code>进行修改：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="dart hljs">Selector&lt;CircleController, Color&gt;(<br>  <span class="hljs-comment">// 只关注颜色属性的变化</span><br>  selector: (context, controller) =&gt; controller.color,<br>  <span class="hljs-comment">// 参数中直接拿到颜色，而不是controller</span><br>  builder: (context, color, child) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      width: <span class="hljs-number">80</span>,<br>      height: <span class="hljs-number">80</span>,<br>      color: color,<br>      <span class="hljs-comment">// 直接引用不变的部分</span><br>      child: child,<br>    );<br>  &#125;,<br>  <span class="hljs-comment">// 不需要重建的部分声明在child中</span><br>  child: TextButton(<br>    onPressed: () &#123;<br>      <span class="hljs-comment">// 只是read，用哪个context无伤大雅</span><br>      context.read&lt;CircleController&gt;().color = Colors.yellow;<br>    &#125;,<br>    child: Text(<span class="hljs-string">&#x27;Two&#x27;</span>),<br>  ),<br>)<br></code></pre></td></tr></table></figure><p>就和<code>Consumer</code>依赖多个对象一样，<code>Selector</code>也支持依赖多个对象，使用方式也是一样的：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 不依赖对象，如果想要依赖，可以在selector中手动获取</span><br>Selector0&lt;T&gt;<br><span class="hljs-comment">// 依赖一个对象，在selector中通过value访问</span><br>Selector&lt;A, S&gt;<br><span class="hljs-comment">// 依赖两个对象，在selector中通过value和value1访问</span><br>Selector2&lt;A, B, S&gt;<br>Selector3&lt;A, B, C, S&gt;<br>Selector4&lt;A, B, C, D, S&gt;<br>Selector5&lt;A, B, C, D, E, S&gt;<br>Selector6&lt;A, B, C, D, E, F, S&gt;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Provider</code>作为状态管理，主要做的也就是提供状态和访问状态。提供状态用了多种<code>Provider</code>，实际中我们还是用的<code>ChangeNotifierProvider</code>比较多一些，当通过这些<code>Provider</code>提供状态后，子组件中就能够通过<code>context</code>获取到这些状态，实现对状态的使用和修改。</p><p>访问状态可以通过<code>context</code>获取，通常我们获取时会与状态建立关联，以便在状态发生变化时重建。而使用<code>context</code>获取容易造成滥用，所以通常会使用一些组件来获取状态，如<code>Consumer</code>和<code>Selector</code>。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Sat Oct 05 2024 15:01:28 GMT+0800");let n="Sat Oct 05 2024 15:01:28 GMT+0800";n="2025-11-05 18:25:57 +0800";var a=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-a)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Flutter/" class="post-footer-category">#&nbsp;Flutter</a> <a href="/tags/Flutter/" class="post-footer-tag">#&nbsp;Flutter</a></div><div class="nav"><div class="nav-item-prev"><a href="/2024/11/15/flutter-provider-source/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">Provider原理分析</div></div></a></div><div class="nav-item-next"><a href="/2024/09/10/flutter-state/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Flutter状态管理</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Provider" class="toc-link"><span class="toc-text">Provider</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%BC%95%E5%85%A5" class="toc-link"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%8F%90%E4%BE%9B%E7%8A%B6%E6%80%81" class="toc-link"><span class="toc-text">提供状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#Provider-1" class="toc-link"><span class="toc-text">Provider</span></a></li><li class="toc-item toc-level-4"><a href="#ChangeNotifierProvider" class="toc-link"><span class="toc-text">ChangeNotifierProvider</span></a></li><li class="toc-item toc-level-4"><a href="#ListenableProvider" class="toc-link"><span class="toc-text">ListenableProvider</span></a></li><li class="toc-item toc-level-4"><a href="#ValueListenableProvider" class="toc-link"><span class="toc-text">ValueListenableProvider</span></a></li><li class="toc-item toc-level-4"><a href="#FutureProvider" class="toc-link"><span class="toc-text">FutureProvider</span></a></li><li class="toc-item toc-level-4"><a href="#StreamProvider" class="toc-link"><span class="toc-text">StreamProvider</span></a></li><li class="toc-item toc-level-4"><a href="#ProxyProvider" class="toc-link"><span class="toc-text">ProxyProvider</span></a></li><li class="toc-item toc-level-4"><a href="#ListenableProxyProvider" class="toc-link"><span class="toc-text">ListenableProxyProvider</span></a></li><li class="toc-item toc-level-4"><a href="#ChangeNotifierProxyProvider" class="toc-link"><span class="toc-text">ChangeNotifierProxyProvider</span></a></li><li class="toc-item toc-level-4"><a href="#MultiProvider" class="toc-link"><span class="toc-text">MultiProvider</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81" class="toc-link"><span class="toc-text">使用状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#context-watch" class="toc-link"><span class="toc-text">context#watch</span></a></li><li class="toc-item toc-level-4"><a href="#context-read" class="toc-link"><span class="toc-text">context#read</span></a></li><li class="toc-item toc-level-4"><a href="#context-select" class="toc-link"><span class="toc-text">context#select</span></a></li><li class="toc-item toc-level-4"><a href="#Provider-of" class="toc-link"><span class="toc-text">Provider#of</span></a></li><li class="toc-item toc-level-4"><a href="#Consumer" class="toc-link"><span class="toc-text">Consumer</span></a></li><li class="toc-item toc-level-4"><a href="#Selector" class="toc-link"><span class="toc-text">Selector</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-09-10</div><a href="/2024/09/10/flutter-state/"><div class="recent-posts-item-content">Flutter状态管理</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-08-16</div><a href="/2024/08/16/flutter-canvas/"><div class="recent-posts-item-content">Flutter自定义绘制CustomPaint</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-07-23</div><a href="/2024/07/23/flutter-getx/"><div class="recent-posts-item-content">Flutter强大脚手架-GetX</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-06-16</div><a href="/2024/06/16/flutter-navigator/"><div class="recent-posts-item-content">Flutter界面跳转-Navigator</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-09-10</div><a href="/2024/09/10/flutter-state/"><div class="recent-posts-item-content">Flutter状态管理</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-08-16</div><a href="/2024/08/16/flutter-canvas/"><div class="recent-posts-item-content">Flutter自定义绘制CustomPaint</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>