<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Java泛型</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.0.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>39</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>15.19</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8" class="toc-link"><span class="toc-text">泛型的使用</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%B3%9B%E5%9E%8B%E4%B8%8A%E4%B8%8B%E9%99%90" class="toc-link"><span class="toc-text">泛型上下限</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%B3%9B%E5%9E%8B%E7%BB%A7%E6%89%BF" class="toc-link"><span class="toc-text">泛型继承</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4" class="toc-link"><span class="toc-text">泛型擦除</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Java泛型 thumbnail" class="image lozad" src="/img/cover/cover-generics.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Java泛型</h1></header><div class="post-meta post-show-meta"><time datetime="2024-02-20T11:45:19.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2024-02-20</span> </time><span class="dot"></span> <a href="/categories/Java/" class="post-meta-link">Java </a><span class="dot"></span> <span>约2.5k 字</span></div><div class="post-content" id="section"><p><code>Java</code>泛型是我们平常开发中经常遇到的，尤其是在一些框架中。使用泛型，我们可以写出通用的代码，来适配各种环境，例如可以通过泛型编码一个方法或类，使其可以接受不同类型的参数，而不需要编写各种重载方法等。</p><h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><p>泛型有两种使用场景，一种是泛型方法，一种是泛型类，在使用的时候通过<code>&lt;T&gt;</code>类进行声明，其中<code>T</code>可以换成任意字母或单词，大小写都可以，按照习惯都会将其声明为大写字母。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span> &#123;<br>        ...<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> &lt;K, V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">(K param1, V param2)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上是泛型方法的定义，即在方法的返回值前面通过<code>&lt;T&gt;</code>来声明一个泛型类型，然后在方法的参数列表和方法体中，都可以将<code>T</code>当成一个具体的类来进行使用。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>    demo.test(demo);<br>    demo.test(<span class="hljs-number">1</span>);<br>    demo.test(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于<code>test</code>方法的参数是一个泛型类型<code>T</code>，并未指定具体类型，所以在调用时可以传入任何类型的参数而不会报错。如果要使用多个泛型参数，则使用逗号隔开，如上面的<code>test1</code>方法，就声明了两个泛型类型<code>K</code>和<code>V</code>。</p><p>泛型类也是一样的，泛型类是在声明类时设置泛型类型，此时该类型可以在类中的任何地方使用。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T param)</span> &#123;<br>       ... <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于泛型方法，泛型类将泛型提取到了类的声明上去，跟在类名的后面，因此它的使用范围更大，可以在类中的任何地方使用泛型类型。而为了保证类中所有的方法使用的泛型是相同的，就需要在实例化类时就指明泛型的类型，这样在这个实例化的对象中才能保证统一。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Demo&lt;String&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>&lt;String&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型上下限"><a href="#泛型上下限" class="headerlink" title="泛型上下限"></a>泛型上下限</h3><p>在使用泛型类时，还有一种方法是通过通配符<code>?</code>来指明这个类的泛型是不可知的，这样我们就无法直接使用泛型，通过这种方式可以保证数据只能流出而无法流入。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &lt;T&gt; &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T param)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = param;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如上面这个就是一个普通的泛型类，有一个属性为泛型类型<code>T</code>，两个方法一个是<code>set</code>方法一个<code>get</code>方法。正常我们使用就是通过具体类型实例化一个对象，然后就可以给他设置参数和获取参数了。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-comment">// 正常使用</span><br>    Demo&lt;String&gt; demo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>    <span class="hljs-comment">// 设置参数</span><br>    demo.set(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// 获取参数</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> demo.get();<br>    System.out.println(str);<br>    <br>    <span class="hljs-comment">// 通过？来使用</span><br>    Demo&lt;?&gt; demo1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>    <span class="hljs-comment">// 编译报错</span><br>    <span class="hljs-comment">//demo1.set(&quot;hello&quot;);</span><br>    <span class="hljs-comment">// 获取的类型无法得知具体类型，只能通过Object引用</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> demo1.get();<br>&#125;<br></code></pre></td></tr></table></figure><p>当通过<code>?</code>来使用泛型时，意思就是不指定泛型的具体类型，因此无法调用<code>set</code>方法，因为这个方法的参数要求是泛型类型，而我们不知道是啥，因此无法传参。但是我们却可以访问<code>get</code>方法，只需要通过<code>Object</code>来进行引用即可。</p><p>那么通过<code>?</code>来使用泛型的应用场景呢？我们看下上面的实例就知道，这种使用方式限定了泛型类型的数据无法流入而只能流出，这就是使用场景。即我有一个<code>demo</code>实例，我想给你使用，但是我不想让你修改。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-comment">// 正常使用</span><br>    Demo&lt;String&gt; demo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>    <span class="hljs-comment">// 设置参数</span><br>    demo.set(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// 将demo传递给别人进行使用</span><br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useDemo</span><span class="hljs-params">(Demo&lt;?&gt; demo)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> demo.get();<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，我在<code>main</code>中有一个泛型类型为<code>String</code>的实例化对象<code>demo</code>，然后给他设置了参数。然后想给别人使用，但是不想给别人修改，就可以在<code>useDemo</code>的参数列表中以<code>Demo&lt;?&gt;</code>的类型来声明。这样，在<code>useDemo</code>方法中就只能获取而不能设置了。</p><p>那么问题又来了，使用<code>?</code>之后就只能获取而不能设置了，但是获取的类型只能认为是<code>Object</code>类型，这样即使拿到数据作用也不大。而为了避免这个问题，就又将通配符<code>?</code>进一步细化，给它一个上限和下限，分别控制数据的流入和流出。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useDemo</span><span class="hljs-params">(Demo&lt;? extends String&gt; demo)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> demo.get();<br>    <span class="hljs-comment">// 报错：还是无法设置泛型数据</span><br>    <span class="hljs-comment">//demo.set(&quot;s&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，泛型类型变成了<code>&lt;? extends String&gt;</code>，也就是说，泛型的这个类型虽然仍是不可知的，但是却可以知道它是<code>String</code>或者是<code>String</code>的子类，因此我们<code>get</code>方法获取到的泛型，可以直接通过<code>String</code>进行引用。这也就是上限，即限定了参数的<code>Demo</code>的泛型类型必须是<code>String</code>以及<code>String</code>的子类。</p><p>而有上限就必然有一个对应的下限，下限通过<code>super</code>关键字声明。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useDemo</span><span class="hljs-params">(Demo&lt;? <span class="hljs-built_in">super</span> String&gt; demo)</span> &#123;<br>    <span class="hljs-comment">// 无法得知类型，还是只能使用Object引用</span><br>     <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> demo.get();<br>  	<span class="hljs-comment">// 但是可以设置数据</span><br>    demo.set(<span class="hljs-string">&quot;s&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法的参数泛型变成了<code>&lt;? super String&gt;</code>，这句话的意思就是虽然泛型类型仍然是不可知的，但却可以知道它是<code>String</code>或者<code>String</code>的父类，因此可以继续往里面设置数据。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> extend A &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useDemo</span><span class="hljs-params">(Demo&lt;? <span class="hljs-built_in">super</span> String&gt; demo)</span> &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    demo.set(a);<br>    demo.set(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来加深下理解，上限<code>&lt;? extends String&gt;</code>的意思就是这个泛型类型确定了一个上界，它只能是这个上界的子类型，因此我们可以直接可以通过<code>Stirng</code>来获取，但无法设置，因为我们不知道它的具体类型是什么。</p><p>而下限<code>&lt;? super A&gt;</code>的意思是泛型类型确定了下界，它只能是这个下界的父类型，因此我们不能通过<code>String</code>来引用获取到的数据，而只能通过<code>Object</code>来引用。但是我们却可以给他设置数据，只能设置<code>String</code>或者它的父类。</p><p>注意：<code>extends</code>关键字不仅可以在通配符<code>?</code>后使用，也可以在任何泛型类和泛型方法中使用，但是<code>super</code>仅能在通配符<code>?</code>后使用。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// Demo类接收的泛型类型必须是Parent或其子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&gt; &#123;<br>    <br>    <span class="hljs-comment">// 泛型方法的参数必须是Person或其子类</span><br>    <span class="hljs-keyword">public</span> &lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(K person)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>泛型仍然是支持继承和覆写的，对于泛型方法而言，继承后覆写仍是泛型方法，而泛型类却可以指定类型。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-comment">// 如果重写，则泛型方法仍是泛型方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">super</span>.test(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面代码，在父类<code>Parent</code>中有一个泛型方法<code>test</code>，那么在子类<code>Child</code>中，如果选择覆写的话，它仍然只能是一个泛型方法，而不能改成具体类型。但是泛型类却不一样，他可以指定类型。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&lt;String&gt; &#123;<br>    <span class="hljs-comment">// 如果重写，则需要将泛型T替换成具体的类型String</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String t)</span> &#123;<br>        <span class="hljs-built_in">super</span>.test(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在<code>Parent</code>是一个泛型类了，那么在子类<code>Child</code>中，继承自<code>Parent</code>是可以选择给它指定一个类型的，如果指定了类型，这里指定了<code>String</code>类型，当然也可以选择不指定，仍使用泛型类型。但是当指定了类型后，如果要重写它的方法时，必须要将泛型类型替换成指定的类型<code>String</code>。</p><p>替换后，如果想用父类引用子类，则必须提供相同的泛型类型。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="java hljs">Parent&lt;String&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>Parent&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">String</span>&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>Parent&lt;? <span class="hljs-built_in">super</span> String&gt; p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-comment">// 报错：只能是String，因为Child指定了String类型</span><br><span class="hljs-comment">// Parent&lt;Integer&gt; p4 = new Child();</span><br></code></pre></td></tr></table></figure><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>泛型是在<code>JDK5</code>中引入的，它并没有大量的修改字节码，而是通过编译期间进行适配，在编译期间将泛型类型移除，从而实现直接复用原来的字节码逻辑，减少了大量的修改工作。也就是说，泛型的类型检查实际上是在编译期间完成的，而非运行期间进行检查。</p><p>如下面的代码，是个泛型类，那么在编译完成之后，类中的所有的<code>T</code>都会被替换成<code>Object</code>，也就是如下所示：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 泛型擦除后</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Object t)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么对于继承后指定类型的类，并且重写了带泛型的方法，则会额外生成一个指定类型的方法：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String t)</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 泛型擦除后</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String t)</span> &#123;<br>    &#125;<br>    <span class="hljs-comment">// 标记为ACC_BRIDGE, ACC_SYNTHETIC，无法直接访问</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Object t)</span> &#123;<br>        test((String)t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>泛型在<code>java</code>中应用还是比较多的，尤其是各种集合结构中。泛型的使用中，主要需要注意的就是它的上下限，主要控制的就是数据的暴露问题。其次就是泛型擦除问题，虽然用不到，但是面试它就总是问这个，贼烦。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Tue Feb 20 2024 19:45:19 GMT+0800");let n="Tue Feb 20 2024 19:45:19 GMT+0800";n="2025-09-04 10:58:34 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Java/" class="post-footer-category">#&nbsp;Java</a> <a href="/tags/%E6%B3%9B%E5%9E%8B/" class="post-footer-tag">#&nbsp;泛型</a></div><div class="nav"><div class="nav-item-prev"><a href="/2024/03/09/threads/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">Java多线程之间的加锁方式</div></div></a></div><div class="nav-item-next"><a href="/2024/01/02/navigation/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">在Compose中使用Navigation</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8" class="toc-link"><span class="toc-text">泛型的使用</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%B3%9B%E5%9E%8B%E4%B8%8A%E4%B8%8B%E9%99%90" class="toc-link"><span class="toc-text">泛型上下限</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%B3%9B%E5%9E%8B%E7%BB%A7%E6%89%BF" class="toc-link"><span class="toc-text">泛型继承</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4" class="toc-link"><span class="toc-text">泛型擦除</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-03-09</div><a href="/2024/03/09/threads/"><div class="recent-posts-item-content">Java多线程之间的加锁方式</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-07-23</div><a href="/2024/07/23/flutter-getx/"><div class="recent-posts-item-content">Flutter强大脚手架-GetX</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-06-16</div><a href="/2024/06/16/flutter-navigator/"><div class="recent-posts-item-content">Flutter界面跳转-Navigator</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-05-02</div><a href="/2024/05/02/flutter-dart/"><div class="recent-posts-item-content">Flutter基础语言Dart</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-04-17</div><a href="/2024/04/17/flutter-widget/"><div class="recent-posts-item-content">Flutter基础组件</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>