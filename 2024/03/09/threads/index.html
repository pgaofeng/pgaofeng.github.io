<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Java多线程之间的加锁方式</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.0.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>35</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>5</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>17</span> <span>标签</span> </a><a class="author-word-count"><span>13.24</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#synchronized" class="toc-link"><span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a href="#Lock" class="toc-link"><span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Java多线程之间的加锁方式 thumbnail" class="image lozad" src="/img/cover/cover-threads.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Java多线程之间的加锁方式</h1></header><div class="post-meta post-show-meta"><time datetime="2024-03-09T09:57:03.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2024-03-09</span> </time><span class="dot"></span> <a href="/categories/Java/" class="post-meta-link">Java </a><span class="dot"></span> <span>约1.7k 字</span></div><div class="post-content" id="section"><p><code>Java</code>多线程在实际开发中是应用非常广泛的，主要场景就是在需要多个任务需要同时执行的时候，并且线程中的数据是可以共享的，这也为多线程之间的协作奠定了基础。</p><p>在多线程场景中，最容易出问题的就是数据问题。由于数据是共享的，当多个线程对数据同时进行读写时，非常容易出现脏数据。因此引出了线程锁的概念，通过线程锁，可以将某块代码区域加锁，使其只允许一个线程访问，其他线程必须进行等待，从而避免多线程之间的问题。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code>关键字就是线程锁的一种，通过它可以将代码块进行锁住，通常我们在写单例代码时会用到它。它可以声明在方法体上，表示整个方法体都被锁住，也可以用在代码块上以实现更精细的控制。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>	<span class="hljs-comment">// 当一个线程访问test方法时，其他线程无法访问test方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBlock</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">// 当一个线程访问到这里时，其他线程可以进入test1方法，但是会阻塞在这里</span><br>        <span class="hljs-keyword">synchronized</span> (Demo.class) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>synchronized</code>关键字的两中用法，一种是直接在方法上使用，声明在返回值之前即可。另一种用法是直接通过<code>synchronized</code>关键字声明一个代码块，通过这个代码块进行加锁。注意，通过代码块的方式需要加入参数，这个参数就是锁的对象，即通过该参数来控制锁的生效范围。</p><p>例如上面的例子中，<code>synchronized (Demo.class)</code>参数是<code>Demo.class</code>，因此这个同步代码块就是在<code>Demo.class</code>上加的锁。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">demo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">demo2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>    <span class="hljs-comment">// 线程1在访问demo1的testBlock方法</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        demo1.testBlock();<br>    &#125;).start();<br>    <span class="hljs-comment">// 线程2在访问demo2的testBlock方法，但是会被阻塞</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        demo2.testBlock();<br>    &#125;).start();      <br>&#125;<br></code></pre></td></tr></table></figure><p>如上示例，虽然线程访问的是两个对象各自的方法，但是线程2还是会阻塞在同步代码块前，等待线程1执行完才能进入代码块。这是因为代码块的锁是<code>Demo.class</code>，而<code>Demo.class</code>在虚拟机中是唯一的，因此线程1获取到锁之后，线程2只能进入阻塞等待线程1结束。</p><p>如果修改一下：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">Objecet</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBlock</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">// 将锁换成object</span><br>        <span class="hljs-keyword">synchronized</span> (object) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">demo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>    <span class="hljs-type">Demo</span> <span class="hljs-variable">demo2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>    <span class="hljs-comment">// 线程1在访问demo1的testBlock方法</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        demo1.testBlock();<br>    &#125;).start();<br>    <span class="hljs-comment">// 线程2在访问demo2的testBlock方法，不会被阻塞</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        demo2.testBlock();<br>    &#125;).start();      <br>&#125;<br></code></pre></td></tr></table></figure><p>锁被换成了<code>Demo</code>的一个内部创建的对象，这样当<code>demo1</code>执行到同步代码块时，获取到的是<code>demo1</code>的内部<code>object</code>锁，因此<code>demo2</code>仍可以访问它自己的代码块。而同步方法，就是相当于用同步代码块将整个方法包起来，然后锁对象换成自己<code>this</code>而已。</p><p>简单来说，避免多线程问题的方法就是将多线程变成单线程，即通过<code>synchronized</code>关键字将关键的部分通过锁来只允许单线程执行，从而解决问题。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p><code>Lock</code>接口也提供了一系列的加锁解锁的方法，用于解决多线程之间的并发问题。他比<code>synchronized</code>更加灵活，功能更加丰富，同时也是轻量级锁。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-comment">// 加锁，获取不到锁时阻塞</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 加锁，如果获取锁时线程被中断，会抛出异常</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-comment">// 尝试加锁，返回值表示是否加锁成功</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 尝试加锁，无法获取锁时会等待time时间</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-comment">// 解锁</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它提供的方法大部分都是涉及加锁的场景，<code>synchronized</code>当获取不到锁时线程会被阻塞，而通过<code>Lock</code>，可以通过<code>tryLock</code>等方法来判断是否能够获取到锁。它最常用的一个实例就是可重入锁<code>ReentrantLock</code>。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-comment">/*true*/</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        ...<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方式比较简单，直接实例化一个<code>ReentrantLock</code>即可，注意在构造方法中可以添加一个布尔参数来控制这个锁是否是公平锁（按照等待的顺序排队，先等待的线程先获取锁），默认是不公平锁（谁抢到锁谁先执行）。从名字也能看到这个锁是可重入锁，即当前线程获取锁后，还能继续获取锁，应用场景就是从一个加锁方法调用另一个加锁方法，或者加锁方法的递归场景。</p><p>而不论<code>synchronized</code>和<code>ReentrantLock</code>，对于加锁的粒度都还是有点粗，因此又引入了更加细化的读写锁。对于数据而言，通常情况下是允许多个线程同时读取的，但是不允许多个线程同时写入，因此可以通过读写锁来将这两种场景进行区分。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-comment">// 构建读写锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>(<span class="hljs-comment">/*true*/</span>);<br>    <span class="hljs-comment">// 通过读写锁分别获取读锁和写锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> lock.readLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> lock.writeLock();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeSomething</span><span class="hljs-params">(String str)</span> &#123;<br>        writeLock.lock();<br>        <span class="hljs-comment">// 写入数据</span><br>        writeLock.unlock();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSomething</span><span class="hljs-params">()</span> &#123;<br>        String str;<br>        readLock.lock();<br>        <span class="hljs-comment">// 读取数据</span><br>        readLock.unlock();<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过读写锁，将读取操作和写入操作进行区分。当读取数据时，若是有线程已经获取了写锁，则会阻塞等待写锁释放才能继续获取读锁；若是没有线程获取写锁，则可直接获取到读锁，不论此时是否有其他线程已经获取了读锁。当写入数据时，必须保证没有线程获取读锁和写锁，否则会进入阻塞等待。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在<code>Java</code>中，通常都是通过<code>synchronized</code>和<code>Lock</code>这两种方式来实现线程之间的同步。在早期的JDK中，<code>synchronized</code>的实现是通过底层的信号量方式，这种方式涉及到内核态和用户态的转换，通常被称为重量级锁，而<code>Lock</code>的方式只需要在用户态完成，被称为轻量级锁。</p><p><code>synchronized</code>：非公平锁、可重入锁。</p><p><code>ReentrantLock</code>：既支持公平也支持非公平锁、可重入锁</p><p><code>ReentrantReadWriteLock</code>：既支持公平也支持非公平锁、可重入锁</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Sat Mar 09 2024 17:57:03 GMT+0800");let n="Sat Mar 09 2024 17:57:03 GMT+0800";n="2025-09-09 15:48:20 +0800";var a=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-a)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Java/" class="post-footer-category">#&nbsp;Java</a> <a href="/tags/Java/" class="post-footer-tag">#&nbsp;Java</a></div><div class="nav"><div class="nav-item-prev"></div><div class="nav-item-next"><a href="/2024/02/20/generics/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Java泛型</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#synchronized" class="toc-link"><span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a href="#Lock" class="toc-link"><span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-02-20</div><a href="/2024/02/20/generics/"><div class="recent-posts-item-content">Java泛型</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-03-09</div><a href="/2024/03/09/threads/"><div class="recent-posts-item-content">Java多线程之间的加锁方式</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-02-20</div><a href="/2024/02/20/generics/"><div class="recent-posts-item-content">Java泛型</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-01-02</div><a href="/2024/01/02/navigation/"><div class="recent-posts-item-content">在Compose中使用Navigation</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>