<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Flutter状态管理</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.1.1" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>45</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>18.72</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#StatelessWidget" class="toc-link"><span class="toc-text">StatelessWidget</span></a></li><li class="toc-item toc-level-3"><a href="#StatefulWidget" class="toc-link"><span class="toc-text">StatefulWidget</span></a></li><li class="toc-item toc-level-3"><a href="#ChangeNotifier" class="toc-link"><span class="toc-text">ChangeNotifier</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#Listenable" class="toc-link"><span class="toc-text">Listenable</span></a></li><li class="toc-item toc-level-4"><a href="#ChangeNotifier-1" class="toc-link"><span class="toc-text">ChangeNotifier</span></a></li><li class="toc-item toc-level-4"><a href="#ValueNotifier" class="toc-link"><span class="toc-text">ValueNotifier</span></a></li><li class="toc-item toc-level-4"><a href="#ListenableBuilder" class="toc-link"><span class="toc-text">ListenableBuilder</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#InheritedWidget" class="toc-link"><span class="toc-text">InheritedWidget</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">10</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Flutter状态管理 thumbnail" class="lozad image" src="/img/cover/cover-flutter-state.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Flutter状态管理</h1></header><div class="post-meta post-show-meta"><time datetime="2024-09-10T05:36:55.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2024-09-10</span> </time><span class="dot"></span> <a href="/categories/Flutter/" class="post-meta-link">Flutter </a><span class="dot"></span> <span>约8.5k 字</span></div><div class="post-content" id="section"><p><code>Flutter</code>是声明式<code>UI</code>框架，不像传统的安卓那样的命令式，我们无法拿到对应的组件然后将其修改。每当界面发生变化时，实际上就是重新创建了一组<code>Widget</code>，我们所说的状态管理就是对这样一组控制界面显示的变量做控制。</p><h3 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h3><p><code>StatelessWidget</code>无状态组件，它不包含任何状态属性，也无法响应状态的变化，仅仅就是一个普通组件，声明成什么样它就是什么样。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyCircle(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      width: <span class="hljs-number">100</span>,<br>      height: <span class="hljs-number">100</span>,<br>      decoration: ShapeDecoration(color: Colors.red, shape: CircleBorder()),<br>      child: Center(<br>        child: TextButton(onPressed: () &#123;<br>            <span class="hljs-comment">// 点击事件</span><br>        &#125;, child: Text(<span class="hljs-string">&#x27;Click&#x27;</span>)),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如上述例子，我们声明了一个<code>100*100</code>的红色的圆形，并且在圆形中间有一个文本按钮。它就是一个典型的无状态组件，当被声明在界面中后，他就不会变化，一直都是红色的圆形。当然，它本身也是有状态的，例如宽高和颜色都可以说是它的状态，因为它的显示需要依赖这些参数。那么我们将其提取出来，作为状态使用：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br><br>  <span class="hljs-comment">// 将尺寸和颜色提取出来，作为状态使用</span><br>  <span class="hljs-built_in">double</span> _size = <span class="hljs-number">100</span>;<br>  Color _color = Colors.red;<br><br>  MyCircle(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      width: _size,<span class="hljs-comment">// 使用提取出的状态</span><br>      height: _size,<br>      <span class="hljs-comment">// 使用提取出的状态</span><br>      decoration: ShapeDecoration(color: _color, shape: CircleBorder()),<br>      child: Center(<br>        child: TextButton(onPressed: () &#123;<br>          <span class="hljs-comment">// 点击按钮时，修改状态，尺寸+20，颜色改成蓝色</span><br>          _size += <span class="hljs-number">20</span>;<br>          _color = Colors.blue;<br>        &#125;, child: Text(<span class="hljs-string">&#x27;Click&#x27;</span>)),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将尺寸状态和颜色状态提取出去，然后在使用的地方直接使用这两个状态值，并且在点击按钮时修改这两个状态值。但是我们会发现，点击按钮时它并没有变化，还是一个红色的尺寸为100的圆形。</p><p>这是因为<code>Flutter</code>如果想要刷新界面，必须要重新调用它的<code>build</code>方法来创建新的组件。而我们点击按钮时，只是修改了状态值，并不能触发<code>build</code>，因此是无法响应变化的。而且作为无状态组件<code>StatelessWidget</code>，它也是不能被触发<code>build</code>的，只能由它的父组件刷新时，重新构建<code>MyCicle</code>，而重新构建又意味着重新创建了一个<code>MyCicle</code>，因此它还是一个红色的尺寸100的圆形。</p><p>因此，如果想要响应状态的变化，就不能使用<code>StatelessWidget</code>，而是要用<code>StatefulWidget</code>。</p><h3 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h3><p><code>StatefulWidget</code>就是<code>Flutter</code>中的有状态组件，它会在声明<code>Widget</code>时创建一个管理状态的类，当状态发生变化时，通过<code>setState</code>触发组件的刷新，实际上就是触发它本身的<code>build</code>方法来重新创建子组件。将前面的例子进行修改：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 组件比较模板化，暂不需要关注</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyCircle(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyCircle&gt; createState() =&gt; _MyCircleState();<br>&#125;<br><br><span class="hljs-comment">// 状态管理类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyCircleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyCircle</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 提取出来的状态</span><br>  <span class="hljs-built_in">double</span> _size = <span class="hljs-number">100</span>;<br>  Color _color = Colors.red;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      width: _size,<span class="hljs-comment">// 使用状态</span><br>      height: _size,<br>      decoration: ShapeDecoration(color: _color, shape: CircleBorder()),<br>      child: Center(<br>        child: TextButton(<br>          onPressed: () &#123;<br>            <span class="hljs-comment">// 点击时修改状态，必须使用setState触发更新</span><br>            setState(() &#123;<br>              _size += <span class="hljs-number">20</span>;<br>              _color = Colors.blue;<br>            &#125;);<br>          &#125;,<br>          child: Text(<span class="hljs-string">&#x27;Circle&#x27;</span>),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将前面的<code>MyCircle</code>组件使用<code>StatefulWidget</code>修改如上，它会创建一个状态管理类，然后状态和<code>UI</code>都是在状态管理类中声明。其他都没有修改，唯一的改动就是在点击事件中，修改状态值时使用了<code>setState</code>方法来修改状态值的。这也是有状态组件的最重要的一个方法，因为这个方法会触发界面的刷新。</p><p>实际上，<code>setState</code>也并不是触发界面的刷新，而是触发了<code>build</code>方法来重新创建组件，注意这里只是重新调用了<code>build</code>方法，而不是重新创建了一个<code>MyCircle</code>，因此状态值的修改仍是有效的，此时<code>_size</code>是130，<code>_color</code>被改成了蓝色，因此新创建的组件就是一个尺寸为120的蓝色圆形，表现形式就是点击后尺寸变大20颜色修改为蓝色。</p><p>有状态组件会声明一个依赖的状态管理类，所依赖的状态都声明在这里面，当修改时通过<code>setState</code>触发重建从而刷新界面，这些状态都可以说是这个组件的内部状态。那么，此时我有两个<code>MyCircle</code>，并且我想在点击任意一个圆形时，两个圆形都同时变化，也就是说两个组件共用同一组状态，现有的管理方式就无法实现了。</p><p>因此，就引出了状态提升的概念，即将状态向上提升，提到它们共有的父组件中，这样它们就都能使用父组件中的状态值来实现同步变化了。此时，<code>MyCircle</code>中就不需要管理状态了，我们也可以将其简写成<code>StatelessWidget</code>了，需要的参数通过构造方法传入即可。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-comment">// 状态值通过构造函数传入</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> size;<br>  <span class="hljs-keyword">final</span> Color color;<br>  <span class="hljs-comment">// 点击事件通过回调传出</span><br>  <span class="hljs-keyword">final</span> VoidCallback callback;<br><br>  <span class="hljs-keyword">const</span> MyCircle(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.size,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.color,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.callback,<br>  &#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      <span class="hljs-comment">// 使用构造方法传入的状态</span><br>      width: size,<br>      height: size,<br>      decoration: ShapeDecoration(color: color, shape: CircleBorder()),<br>      child: Center(<br>        child: TextButton(onPressed: callback, child: Text(<span class="hljs-string">&#x27;Circle&#x27;</span>)),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们又将<code>MyCircle</code>修改为了无状态组件，并且状态值不是内部存储和修改的，而是通过构造方法从外部传入进来的，这样当外部的状态发生变化时，会调用外部的<code>build</code>来刷新界面，从而创建新的<code>MyCircle</code>，然后完成刷新界面的目的。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 状态提升到父组件中</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyParent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyParent(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyParent&gt; createState() =&gt; _MyParentState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyParentState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyParent</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 父组件持有状态</span><br>  <span class="hljs-built_in">double</span> _size = <span class="hljs-number">100</span>;<br>  Color _color = Colors.red;<br><br>  <span class="hljs-comment">// 修改状态时仍通过setState修改</span><br>  <span class="hljs-keyword">void</span> _callback() &#123;<br>    setState(() &#123;<br>      _size += <span class="hljs-number">20</span>;<br>      _color = Colors.blue;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 父组件的布局内容是一个Column，里面两个MyCircle</span><br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        <span class="hljs-comment">// 通过构造方法传入状态</span><br>        MyCircle(size: _size, color: _color, callback: _callback),<br>        MyCircle(size: _size, color: _color, callback: _callback)<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将<code>MyCircle</code>的两个状态提升到了共有父组件<code>MyParent</code>中，<code>MyCircle</code>通过构造方法接收状态值。当状态发生变化时，仍是通过<code>setState</code>触发重建，此时会调用<code>MyParent</code>的<code>build</code>方法重新创建组件，然后就创建了新的两个<code>MyCircle</code>，并且构造方法传入的参数还是修改后的状态值，因此实现了同步变化的目的。</p><p>以上就是状态提升，也就是状态管理的手段，即将状态提升到足够高的位置，从而使得多个子组件之间可以共享状态。一般来说，只需要提到需要共享状态的子组件的最近共有父组件中就行了，就能实现它们的共享了。但在实际项目中，界面往往是非常复杂的，因此可能需要在多个组件中分别存放不同的状态，这对于管理来说是非常麻烦的 ，非常难进行维护，因此我们会将状态统一提到最顶层的父组件中，这样状态全部统一在一块了，就比较好管理维护了。</p><p>但这样带来一个问题，状态在最顶层的父组件中，使用的地方在多个层级以下的子组件中，因此需要通过构造方法一步步得将状态传递到目标子组件中，而中间的组件却根本不需要这些状态，这带来非常严重的耦合问题。当然这还不是最关键的，最关键的是会带来性能问题。</p><p>状态修改后是通过<code>setState</code>来触发重建的，当我们把状态提到最顶层后，任意一个状态发生变化，都会导致最顶层的父组件的<code>build</code>方法被调用，从而重建所有的组件，这是非常损耗性能的。</p><h3 id="ChangeNotifier"><a href="#ChangeNotifier" class="headerlink" title="ChangeNotifier"></a>ChangeNotifier</h3><p>最理想的情况是当状态发生变化时，只会重建使用到该状态的组件，而不会影响别的组件，因此就不能直接在父组件中<code>setState</code>。我们既想要将状态提升到最顶层父组件中，又想要状态变化时只影响到使用该状态的组件，这就需要用到观察者模式了。子组件观察最顶层父组件中的状态，当状态变化时就能通知到子组件中来，就不需要在父组件中<code>setState</code>来全部刷新了。</p><h4 id="Listenable"><a href="#Listenable" class="headerlink" title="Listenable"></a>Listenable</h4><p><code>Listenable</code>就是<code>Flutter</code>中用于实现观察者模式的接口，它主要定义了两个方法，分别是添加监听和移除监听。主要原理就是其他组件通过<code>addListener</code>添加监听，然后当状态值发生变化时，就能通知到监听者了。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Listenable</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> Listenable();<br>  <span class="hljs-keyword">factory</span> Listenable.merge(<span class="hljs-built_in">Iterable</span>&lt;Listenable?&gt; listenables) = _MergingListenable;<br>  <span class="hljs-keyword">void</span> addListener(VoidCallback listener);<br>  <span class="hljs-keyword">void</span> removeListener(VoidCallback listener);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ChangeNotifier-1"><a href="#ChangeNotifier-1" class="headerlink" title="ChangeNotifier"></a>ChangeNotifier</h4><p>它的实现类就是<code>ChangeNotifier</code>，名字就能表现出它的功能，即发生变化时进行通知。逻辑基本上没什么可说的，就是维护一个集合，当<code>addListener</code>时，将监听方法添加到集合中进行存储；当不需要使用时可以通过<code>removeListener</code>移除监听；另外额外提供了一个<code>notifyListeners</code>方法，会触发所有的监听者的回调。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">mixin</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeNotifier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Listenable</span> </span>&#123;<br>    <span class="hljs-comment">// 监听者个数</span><br>    <span class="hljs-built_in">int</span> _count = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 存放监听者</span><br>    <span class="hljs-built_in">List</span>&lt;VoidCallback?&gt; _listeners = _emptyListeners;<br>    <span class="hljs-comment">// 添加监听者</span><br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-keyword">void</span> addListener(VoidCallback listener) &#123; ... &#125;<br>    <span class="hljs-comment">// 移除监听者</span><br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-keyword">void</span> removeListener(VoidCallback listener) &#123; ... &#125;<br>    <span class="hljs-comment">// 通知所有的监听者</span><br>    <span class="hljs-keyword">void</span> notifyListeners() &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ChangeNotifier</code>本身是一个混入类，不仅可以正常继承，也可以进行混入（已经有了继承关系的类使用混入的方式），提高了灵活性。对于前面的例子，我们就可以将<code>MyCircle</code>所涉及的状态通过<code>ChangeNotifier</code>来进行管理：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>   <span class="hljs-built_in">double</span> _size = <span class="hljs-number">100</span>;<br>   <span class="hljs-keyword">get</span> size =&gt; _size;<br>   <span class="hljs-comment">// 修改size时，触发notifyListeners</span><br>   <span class="hljs-keyword">set</span> size(value) &#123;<br>     _size = value;<br>     notifyListeners();<br>   &#125;<br>   <br>   <span class="hljs-comment">// 修改color时，触发notifyListeners</span><br>   Color _color = Colors.red;<br>   <span class="hljs-keyword">get</span> color =&gt; _color;<br>   <span class="hljs-keyword">set</span> color(value) &#123;<br>     _color = value;<br>     notifyListeners();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们的父组件只需要持有状态，而不涉及到状态的修改，即不需要在父组件中<code>setState</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyParent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyParent(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyParent&gt; createState() =&gt; _MyParentState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyParentState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyParent</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">// 仍是将状态提升到最顶层父组件中</span><br>  <span class="hljs-keyword">final</span> controller = CircleController();<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        <span class="hljs-comment">// 子组件仍通过构造方法传入</span><br>        MyCircle(controller: controller),<br>        <span class="hljs-comment">// 不涉及到状态的组件</span><br>        Text(<span class="hljs-string">&#x27;Other Widget&#x27;</span>),<br>        <span class="hljs-comment">// 需要共用状态的组件</span><br>        MyCircle(controller: controller)<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>状态仍然是提升到最顶层，方便各个子组件共用这些状态，当然目前这些状态被封装到了<code>CircleController</code>中了，其他没什么变化，对于状态仍是通过构造方法逐层向下传递到目标子组件中。</p><p>然后就是子组件了，子组件需要向<code>CircleController</code>中添加监听，并且响应变化。而<code>Flutter</code>中，想要响应变化，就必须通过<code>build</code>构建新的组件，而触发<code>build</code>方法又必须用<code>setState</code>，因此<code>MyCircle</code>又得变回成有状态组件：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <br>  <span class="hljs-comment">// 状态通过构造方法传入</span><br>  <span class="hljs-keyword">final</span> CircleController controller;<br>  <span class="hljs-keyword">const</span> MyCircle(&#123;<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.controller&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyCircle&gt; createState() =&gt; _MyCircleState();<br>&#125;<br><br><span class="hljs-comment">// 对应的状态管理类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyCircleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyCircle</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// 初始化时添加监听</span><br>    widget.controller.addListener(onStateChanged);<br>  &#125;<br>  <br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-comment">// 结束时移除监听</span><br>    widget.controller.removeListener(onStateChanged);\<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br>  <br>  <span class="hljs-comment">// 状态变化时触发setState</span><br>  <span class="hljs-keyword">void</span> onStateChanged() &#123;<br>    setState(() &#123;&#125;);<br>  &#125;<br>  <br>  <br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      <span class="hljs-comment">// 使用controller中的参数</span><br>      width: widget.controller.size,<br>      height: widget.controller.size,<br>      decoration: ShapeDecoration(color: widget.controller.color, shape: CircleBorder()),<br>      child: Center(<br>        child: TextButton(onPressed: () &#123;<br>          <span class="hljs-comment">// 点击圆圈时，直接修改controller中的内容即可</span><br>          widget.controller.size += <span class="hljs-number">20</span>;<br>          widget.controller.color = Colors.blue;<br>        &#125;, child: Text(<span class="hljs-string">&#x27;Circle&#x27;</span>)),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，当我们点击圆圈时，修改了<code>controller</code>中的状态值，此时会将通知发送给所有的监听者，也就是我们多个<code>MyCircle</code>组件，而在<code>MyCircle</code>组件中，接收到状态变化时直接调用了<code>setState</code>触发了重建，因此能够实现状态响应。</p><h4 id="ValueNotifier"><a href="#ValueNotifier" class="headerlink" title="ValueNotifier"></a>ValueNotifier</h4><p>上述我们的<code>CircleController</code>中，涉及到了两个状态，一个是<code>_size</code>，一个是<code>_color</code>。如果只涉及到一个状态的变化，则可以使用<code>ValueNotifier</code>，它是<code>ChangeNotifier</code>的子类，内部存储了一个泛型状态值。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueNotifier</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChangeNotifier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ValueListenable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 构造方法中传入默认值</span><br>  ValueNotifier(<span class="hljs-keyword">this</span>._value) &#123;...&#125;<br><br>  <span class="hljs-comment">// 通过value获取到对应的值</span><br>  <span class="hljs-meta">@override</span><br>  T <span class="hljs-keyword">get</span> value =&gt; _value;<br>  T _value;<br>  <span class="hljs-keyword">set</span> value(T newValue) &#123;<br>    <span class="hljs-keyword">if</span> (_value == newValue) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _value = newValue;<br>    notifyListeners();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">String</span> toString() =&gt; <span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;describeIdentity(<span class="hljs-keyword">this</span>)&#125;</span>(<span class="hljs-subst">$value</span>)&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它本身是比较简单的，只在内部包装了一个<code>value</code>值并提供对应的<code>get/set</code>方法，并且在<code>set</code>时触发通知监听。跟我们自己写的<code>CircleController</code>逻辑是一样的，只是它用泛型代替了状态，因此用起来更方便一些。</p><p>另外就是，<code>ChangeNotifier</code>无法针对性的回调相关属性的监听，例如前面我们写的<code>CircleController</code>中，不论是<code>_size</code>变化还是<code>_color</code>变化，都会触发它所有的监听者。那么问题来了，当我们界面中状态很多的时候，组件A使用状态a，组件B使用状态b，组件C使用状态c，然后将他们全部进行状态提升，放在了最顶层父组件中。然后通过<code>ChangeNotifier</code>将他们放在同一个类中，此时不论任何一个状态发生变化，都会导致组件A、B、C同时刷新，这显然也是与我们的目标是不一致的。</p><p>此时就需要用到了<code>ValueNotifier</code>，我们将相关联的状态仍放在同一个<code>ChangeNotifier</code>中，如上面的例子中的<code>CircleController</code>，不关联的状态封装成单独的<code>ValueNotifier</code>，这样就能够实现它们之间互不关联了。这里，我们可以将<code>CircleController</code>修改一下：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 普通类，没有继承ChangeNotifier</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleController</span> </span>&#123;<br>   <span class="hljs-comment">// 将两个状态都封装成ValueNotifier</span><br>   <span class="hljs-keyword">final</span> size = ValueNotifier&lt;<span class="hljs-built_in">double</span>&gt;(<span class="hljs-number">100</span>);<br>   <span class="hljs-keyword">final</span> color = ValueNotifier&lt;Color&gt;(Colors.red);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上由于<code>size</code>和<code>color</code>它们是一组的，应该包装成一个整体<code>ChangeNotifier</code>，而不是两个<code>ValueNotifier</code>，这里只是为了示例，才将他们拆开的。</p><p>然后<code>MyParent</code>不需要修改，还是持有着<code>CircleController</code>，然后通过构造方法传递状态，主要就是<code>MyCircle</code>中需要修改下：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br><br>  <span class="hljs-keyword">final</span> CircleController controller;<br><br>  <span class="hljs-keyword">const</span> MyCircle(&#123;<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.controller&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyCircle&gt; createState() =&gt; _MyCircleState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyCircleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyCircle</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// 初始化时添加监听，注意需要将多个属性都添加一次</span><br>    widget.controller.size.addListener(onStateChanged);<br>    widget.controller.color.addListener(onStateChanged);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-comment">// 结束时移除监听，注意需要将多个属性都移除一次</span><br>    widget.controller.size.removeListener(onStateChanged);<br>    widget.controller.color.removeListener(onStateChanged);<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-comment">// 状态变化时触发setState</span><br>  <span class="hljs-keyword">void</span> onStateChanged() &#123;<br>    setState(() &#123;&#125;);<br>  &#125;<br><br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      <span class="hljs-comment">// 后缀需要通过value获取到实际的值</span><br>      width: widget.controller.size.value,<br>      height: widget.controller.size.value,<br>      decoration: ShapeDecoration(color: widget.controller.color.value, shape: CircleBorder()),<br>      child: Center(<br>        child: TextButton(onPressed: () &#123;<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;onPresssed&#x27;</span>);<br>          widget.controller.size.value += <span class="hljs-number">20</span>;<br>          widget.controller.color.value = Colors.blue;<br>        &#125;, child: Text(<span class="hljs-string">&#x27;Circle&#x27;</span>)),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和原先的逻辑基本上没啥区别，就是在添加监听的时候将每个关联的属性都添加了一次，移除的时候也是一样，然后就是使用状态值的时候，通过<code>value</code>属性获取实际的值。另外如果涉及的状态值很多的话，需要添加和移除好几次<code>listener</code>，是否有办法简化呢？</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Listenable</span> </span>&#123;<br>  <span class="hljs-comment">// 工厂构造方法</span><br>  <span class="hljs-keyword">factory</span> Listenable.merge(<span class="hljs-built_in">Iterable</span>&lt;Listenable?&gt; listenables) = _MergingListenable;<br>&#125;<br><br><span class="hljs-comment">// 合并的Listenable</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MergingListenable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Listenable</span> </span>&#123;<br>  _MergingListenable(<span class="hljs-keyword">this</span>._children);<br><br>  <span class="hljs-comment">// 记录需要合并的Listenable</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Iterable</span>&lt;Listenable?&gt; _children;<br><br>  <span class="hljs-comment">// 添加时，给每个child添加</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> addListener(VoidCallback listener) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> Listenable? child <span class="hljs-keyword">in</span> _children) &#123;<br>      child?.addListener(listener);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 移除时，给每个child移除</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> removeListener(VoidCallback listener) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> Listenable? child <span class="hljs-keyword">in</span> _children) &#123;<br>      child?.removeListener(listener);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过<code>Listenable</code>的工厂构造方法<code>merge</code>来合并多个<code>Listenable</code>，其内部逻辑就是一个包装器，将添加进来的监听给同时添加到多个<code>child</code>上就行了。下面我们使用这个来简化下我们的<code>MyCircle</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br><br>  <span class="hljs-keyword">final</span> CircleController controller;<br>  <span class="hljs-keyword">late</span> Listenable listenable;<br><br>  MyCircle(&#123;<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.controller&#125;) &#123;<br>    <span class="hljs-comment">// 通过merge构建一个新的Listenable</span><br>    listenable = Listenable.merge([<br>      controller.size,<br>      controller.color<br>    ]);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyCircle&gt; createState() =&gt; _MyCircleState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyCircleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyCircle</span>&gt; </span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// 初始化时添加监听,直接使用listenable</span><br>    widget.listenable.addListener(onStateChanged);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-comment">// 结束时移除监听,直接使用listenable</span><br>    widget.listenable.removeListener(onStateChanged);<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  ...<br>  <span class="hljs-comment">// 其他部分不需要改变</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>到这里，基本上就已经能实现我们的目标了：<strong>状态变化只影响到使用该状态的组件</strong>。我们的方案就是使用观察者模式，将状态提升到最顶层父组件后，并不直接触发<code>setState</code>，而是在需要使用该状态的地方，包装出一个<code>StatefulWidget</code>，然后注册监听，当监听到状态变化时，开始触发重建，从而刷新<code>UI</code>。每次都新建一个<code>StatefulWidiget</code>未免太过于麻烦，于是我们为了省事，将这部分封装一下：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListenableBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> Widget <span class="hljs-built_in">Function</span>(BuildContext context) builder;<br>  <span class="hljs-keyword">final</span> Listenable listenable;<br><br>  <span class="hljs-keyword">const</span> MyListenableBuilder(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-comment">// 需要监听的状态</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.listenable,<br>    <span class="hljs-comment">// 构建界面的方法</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.builder,<br>  &#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyListenableBuilder&gt; createState() =&gt; _MyListenableBuilderState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyListenableBuilderState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyListenableBuilder</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// 添加监听</span><br>    widget.listenable.addListener(_onStateChanged);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-comment">// 移除监听</span><br>    widget.listenable.removeListener(_onStateChanged);<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-comment">// 触发监听回调时，刷新UI</span><br>  <span class="hljs-keyword">void</span> _onStateChanged() &#123;<br>    setState(() &#123;&#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 调用builder方法构建新的组件</span><br>    <span class="hljs-keyword">return</span> widget.builder(context);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，我们只需要在需要使用状态的地方直接使用<code>MyListenableBuilder</code>包裹即可，然后我们修改下<code>MyCircle</code>，因为我们已经使用<code>MyListenableBuilder</code>了，所以<code>MyCircle</code>又可以回到最初的无状态组件了：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-comment">// 通过构造方法传入状态</span><br>  <span class="hljs-keyword">final</span> CircleController controller;<br><br>  <span class="hljs-keyword">const</span> MyCircle(&#123;<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.controller&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 使用我们定义的MyListenableBuilder包裹</span><br>    <span class="hljs-keyword">return</span> MyListenableBuilder(<br>      <span class="hljs-comment">// 因为controller中我们将状态包装成了多个ValueNotifier</span><br>      <span class="hljs-comment">// 这里需要通过merge进行合并，方便我们添加监听</span><br>      listenable: Listenable.merge([controller.color, controller.size]),<br>      builder: (_) =&gt; Container(<br>        <span class="hljs-comment">// 直接使用状态值即可</span><br>        width: controller.size.value,<br>        height: controller.size.value,<br>        decoration: ShapeDecoration(<br>          color: controller.color.value,<br>          shape: CircleBorder(),<br>        ),<br>        child: Center(<br>          child: TextButton(<br>            onPressed: () &#123;<br>              controller.size.value += <span class="hljs-number">20</span>;<br>              controller.color.value = Colors.blue;<br>            &#125;,<br>            child: Text(<span class="hljs-string">&#x27;Circle&#x27;</span>),<br>          ),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们点击按钮时，会修改<code>controller</code>中的尺寸和颜色，此时<code>MyListenableBuilder</code>就会触发重建，而它的<code>build</code>方法就是简单的调用参数<code>builder</code>，因此会通过<code>builder</code>重新构建组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">MyCircle--MyListenableBuilder--Container--Center--TextButton--Text<br></code></pre></td></tr></table></figure><p>现在，我们的<code>MyCircle</code>组件的层级是如上所示的，当状态变化时，会触发重建，重建的部分是<code>Container</code>，以及它的子组件<code>Center</code>和<code>TextButton</code>以及<code>Text</code>。但我们发现只有<code>Container</code>用到了状态，而另外三个组件并没有用到状态，也就是说重建实际上只需要<code>Container</code>重建就行了。于是我们修改下<code>MyListenableBuilder</code>，引入一个<code>child</code>属性来记录不可变的部分：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListenableBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-comment">// builder中加入一个参数child</span><br>  <span class="hljs-keyword">final</span> Widget <span class="hljs-built_in">Function</span>(BuildContext context, Widget? child) builder;<br>  <span class="hljs-keyword">final</span> Listenable listenable;<br>  <span class="hljs-comment">// 增加一个属性child，通过构造方法传入</span><br>  <span class="hljs-keyword">final</span> Widget? child;<br><br>  <span class="hljs-keyword">const</span> MyListenableBuilder(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.listenable,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-keyword">this</span>.child <span class="hljs-comment">// 构造方法传入</span><br>  &#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyListenableBuilder&gt; createState() =&gt; _MyListenableBuilderState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyListenableBuilderState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyListenableBuilder</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    widget.listenable.addListener(_onStateChanged);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    widget.listenable.removeListener(_onStateChanged);<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> _onStateChanged() &#123;<br>    setState(() &#123;&#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 将child参数传入</span><br>    <span class="hljs-keyword">return</span> widget.builder(context, widget.child);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们加入了一个可空的<code>child</code>，这是因为可能有的组件不包含不可变部分，因此不需要通过该参数进行记录。然后修改我们的<code>MyCircle</code>:</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> CircleController controller;<br><br>  <span class="hljs-keyword">const</span> MyCircle(&#123;<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.controller&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MyListenableBuilder(<br>      listenable: Listenable.merge([controller.color, controller.size]),<br>      builder: (_, child) =&gt; Container(<br>        width: controller.size.value,<br>        height: controller.size.value,<br>        decoration: ShapeDecoration(<br>          color: controller.color.value,<br>          shape: CircleBorder(),<br>        ),<br>        <span class="hljs-comment">// 原来的位置直接引用参数列表中的child即可</span><br>        child: child,<br>      ),<br>      <span class="hljs-comment">// 将不可变部分提取到child参数中</span><br>      child: Center(<br>        child: TextButton(<br>          onPressed: () &#123;<br>            controller.size.value += <span class="hljs-number">20</span>;<br>            controller.color.value = Colors.blue;<br>          &#125;,<br>          child: Text(<span class="hljs-string">&#x27;Circle&#x27;</span>),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过上面的一番改造，我们既保持了<code>MyCircle</code>的无状态属性，又能使其可以跟随状态发生变化，同时还控制了刷新的范围，只有用到状态的部分才重建，其他部分保持不变，提升了性能，简化了逻辑。</p><h4 id="ListenableBuilder"><a href="#ListenableBuilder" class="headerlink" title="ListenableBuilder"></a>ListenableBuilder</h4><p>简化整个代码的关键部分就在于我们自定义的<code>MyListenableBuilder</code>，它实际上是一个<code>StatefulWidget</code>，内部帮我们主动注册和移除监听，以及状态变化时主动帮我们<code>setState</code>。使用它，我们甚至可以保持整个编码过程中只使用<code>StatelessWidget</code>。</p><p>当然，这么有用的组件<code>Flutter</code>怎么会想不到呢，所以它其实是被内置到<code>Flutter</code>中的一个组件，名字叫做<code>ListenableBuilder</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListenableBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnimatedWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> ListenableBuilder(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">super</span>.listenable,<span class="hljs-comment">// 监听状态</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.builder,<span class="hljs-comment">// 构建组件</span><br>    <span class="hljs-keyword">this</span>.child,<span class="hljs-comment">// 不变的组件</span><br>  &#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Listenable <span class="hljs-keyword">get</span> listenable =&gt; <span class="hljs-keyword">super</span>.listenable;<br>  <span class="hljs-keyword">final</span> TransitionBuilder builder;<br>  <span class="hljs-keyword">final</span> Widget? child;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) =&gt; builder(context, child);<br>&#125;<br></code></pre></td></tr></table></figure><p>整个逻辑非常简单，主要就是继承自<code>AnimatedWidget</code>，而<code>AnimatedWidget</code>就是我们实现的第一版的不带<code>child</code>的<code>MyListenableBuilder</code>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimatedWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br><br>  <span class="hljs-keyword">const</span> AnimatedWidget(&#123;<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.listenable&#125;);<br><br>  <span class="hljs-keyword">final</span> Listenable listenable;<br>  <span class="hljs-meta">@protected</span><br>  Widget build(BuildContext context);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;AnimatedWidget&gt; createState() =&gt; _AnimatedState();<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_AnimatedState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">AnimatedWidget</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 注册监听</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    widget.listenable.addListener(_handleChange);<br>  &#125;<br><br>  <span class="hljs-comment">// 更新时重新注册</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> didUpdateWidget(AnimatedWidget oldWidget) &#123;<br>    <span class="hljs-keyword">super</span>.didUpdateWidget(oldWidget);<br>    <span class="hljs-keyword">if</span> (widget.listenable != oldWidget.listenable) &#123;<br>      oldWidget.listenable.removeListener(_handleChange);<br>      widget.listenable.addListener(_handleChange);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 移除监听</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    widget.listenable.removeListener(_handleChange);<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-comment">// 状态变化时setState</span><br>  <span class="hljs-keyword">void</span> _handleChange() &#123;<br>    <span class="hljs-keyword">if</span> (!mounted) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    setState(() &#123;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) =&gt; widget.build(context);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体下来没什么特殊的，和我们自定义的<code>MyListenableBuidler</code>是一样的逻辑。使用起来也是一样的，我们直接修改<code>MyCircle</code>，将<code>MyListenableBuilder</code>替换成内置的<code>ListenableBuilder</code>就行，其他一模一样，完全不需要改动。</p><p>基于<code>Listenable</code>的观察者，实际上还有好几个对应的组件可以使用：</p><ul><li><code>ListenableBuilder</code></li></ul><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">const</span> ListenableBuilder(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-comment">// 观测的状态，</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">super</span>.listenable,<br>    <span class="hljs-comment">// 构建组件的builder</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-comment">// 不变的部分</span><br>    <span class="hljs-keyword">this</span>.child,<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><code>AnimatedBuilder</code>（和<code>ListenableBuilder</code>一模一样，就是名字不一样）</li></ul><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">const</span> AnimatedBuilder(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-comment">// 观测的状态</span><br>    <span class="hljs-keyword">required</span> Listenable animation,<br>    <span class="hljs-comment">// 构建组件的builder</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">super</span>.builder,<br>    <span class="hljs-comment">// 不变的部分</span><br>    <span class="hljs-keyword">super</span>.child,<br>  &#125;)<br></code></pre></td></tr></table></figure><ul><li><code>ValueListenableBuilder</code></li></ul><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">const</span> ValueListenableBuilder(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-comment">// 注意类型是ValueListenable</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.valueListenable,<br>    <span class="hljs-comment">// 构建组件的builder，多了一个参数是value</span><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-comment">// 不变的部分</span><br>    <span class="hljs-keyword">this</span>.child,<br>&#125;);<br></code></pre></td></tr></table></figure><p>其中<code>ValueListenableBuilder</code>在用法上和<code>ListenableBuilder</code>稍微有些不同，它接收的状态类型不是普通的<code>Listenable</code>，而是<code>ValueListenable</code>，也就是对应的类型为<code>ValueNotifier</code>。它的局限性就在于只能观测到一个状态的变化，使用方式大概如下：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 状态是一个ValueNotifier</span><br><span class="hljs-keyword">final</span> _size = ValueNotifier&lt;<span class="hljs-built_in">double</span>&gt;(<span class="hljs-number">100</span>);<br><br>ValueListenableBuilder(<br>  <span class="hljs-comment">// 观察的状态</span><br>  alueListenable: _size,<br>  <span class="hljs-comment">// 构建组件，可以直接拿到value</span><br>  builder: (context, value, child) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      <span class="hljs-comment">// 直接使用value，不需要通过_size.value获取</span><br>      <span class="hljs-comment">// 当然通过_size.value获取也是可以的</span><br>      width: value,<br>      height: value,<br>      decoration: ShapeDecoration(<br>        color: Colors.red,<br>        shape: CircleBorder(),<br>      ),<br>      child: child,<br>    );<br>  &#125;,<br>  <span class="hljs-comment">// 不可变部分</span><br>  child: TextButton(<br>    onPressed: () &#123;<br>      _size.value += <span class="hljs-number">20</span>;<br>    &#125;,<br>    child: Text(<span class="hljs-string">&#x27;Circle&#x27;</span>),<br>  ),<br>)<br></code></pre></td></tr></table></figure><p>实际上我们用这个比较少，毕竟局限性太大，只能观测到一个状态的变化，而方便之处也仅仅是在<code>builder</code>中给我们提供了<code>value</code>值，使得我们不需要通过<code>_size.value</code>获取值了。因此，这个组件只能说是比较鸡肋吧，我直接<code>ListenableBuilder</code>一把梭就行了。</p><h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>为了管理和复用状态，我们使用状态提升的方式，将状态提取到最顶层父组件中，由父组件进行持有，从而可以共享到各个子组件中。但是状态提升带来了两个痛点：一是状态刷新会导致所有界面全部重建，一是状态需要通过构造方法一层一层传递到子组件中。第一个痛点我们使用<code>ChangeNotifier</code>和<code>ListenableBuilder</code>解决了，接下来就是第二个痛点了，如何将状态传递到子组件中。</p><p>我们之所以使用构造方法传递状态，是因为<code>Flutter</code>是声明式<code>UI</code>，我们不能获取到对应的组件，从而无法从组件中获取到状态。但有一个组件比较例外，就是<code>InheritedWidget</code>，它允许我们在子组件中通过<code>context</code>获取到它本身，从而获取到它所持有的状态。<code>InheritedWidget</code>是一个抽象类，必须要继承它实现相关的方法才可以。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleControllerProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>&#123;<br><br>  <span class="hljs-keyword">final</span> controller = CircleController();<br><br>  CircleControllerProvider(&#123;<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">super</span>.child&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> updateShouldNotify(<span class="hljs-keyword">covariant</span> CircleControllerProvider oldWidget) =&gt; <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们定义了一个<code>CircleControllerProvider</code>，用于存储我们的状态，它内部也基本上没干啥，就是定义了一个<code>controller</code>，然后重写了<code>updateShouldNotify</code>方法来判断是否需要通知依赖的子组件。</p><p>当它被声明在组件树中的时候，我们就可以通过<code>context</code>来获取到它：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 使用依赖方式获取InheritedWidget</span><br>context.dependOnInheritedWidgetOfExactType&lt;T&gt;();<br><span class="hljs-comment">// 直接获取</span><br>context.getInheritedWidgetOfExactType&lt;T&gt;();<br></code></pre></td></tr></table></figure><p>当状态由<code>CircleControllerProvider</code>提供时，我们的<code>MyParent</code>也不需要持有状态了，也就是可以改成无状态组件了：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyParent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyParent(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 获取到对应的InheritedWidget组件</span><br>    <span class="hljs-keyword">final</span> provider = context.dependOnInheritedWidgetOfExactType&lt;CircleControllerProvider&gt;();<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        <span class="hljs-comment">// 拿到组件后可以获取到状态值</span><br>        MyCircle(controller: provider!.controller),<br>        Text(<span class="hljs-string">&#x27;Other Widget&#x27;</span>),<br>        MyCircle(controller: provider!.controller),<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们是在<code>MyParent</code>中获取到的<code>CircleControllerProvider</code>，因此我们在声明组件树的时候，必须要将它包在<code>MyParent</code>外面。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="dart hljs">Scaffold(<br>  body: SafeArea(<br>    <span class="hljs-comment">// MyParent外面包一层Provider</span><br>    child: CircleControllerProvider(child: MyParent())<br>  ),<br>);<br></code></pre></td></tr></table></figure><p>我们在编写代码时，常用的颜色属性会通过<code>Theme.of(context)</code>来获取到<code>ThemeData</code>，这里其实用的也是<code>InheritedWidget</code>实现的，实际上使用<code>of</code>的方式获取实例也算是<code>Flutter</code>中一个约定俗成的方式。因此我们将其也改一下：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleControllerProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> controller = CircleController();<br><br>  CircleControllerProvider(&#123;<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">super</span>.child&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> updateShouldNotify(<span class="hljs-keyword">covariant</span> CircleControllerProvider oldWidget) =&gt; <span class="hljs-keyword">false</span>;<br><br>  <span class="hljs-comment">// 静态方法，返回的强制转成非空类型</span><br>  <span class="hljs-keyword">static</span> CircleController of(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> provider =  context.dependOnInheritedWidgetOfExactType&lt;CircleControllerProvider&gt;()!;<br>    <span class="hljs-keyword">return</span> provider.controller;<br>  &#125;<br><br>  <span class="hljs-comment">// 静态方法，返回的是可空类型</span><br>  <span class="hljs-keyword">static</span> CircleController? maybeOf(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> provider = context.dependOnInheritedWidgetOfExactType&lt;CircleControllerProvider&gt;();<br>    <span class="hljs-keyword">return</span> provider?.controller;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意我们通过<code>context</code>获取到的是可空类型，这是因为当你没有在界面中使用当前<code>InheritedWidget</code>时，肯定是无法获取到的，所以返回值是可空类型。</p><p>当使用这种方式时，<code>MyParent</code>也不需要通过构造方法来传递<code>controller</code>了，让使用状态的组件自己去获取就行了：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyParent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyParent(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        <span class="hljs-comment">// 不需要构造方法传入，直接就一个空参数就行</span><br>        MyCircle(),<br>        Text(<span class="hljs-string">&#x27;Other Widget&#x27;</span>),<br>        MyCircle(),<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改下<code>MyCircle</code>，让他自己去获取状态：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br><br>  <span class="hljs-comment">// 不需要构造方法传入</span><br>  <span class="hljs-keyword">const</span> MyCircle(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 直接通过context获取</span><br>    <span class="hljs-keyword">final</span> controller = CircleControllerProvider.of(context);<br>    <span class="hljs-comment">// 下面的部分不需要改动</span><br>    <span class="hljs-keyword">return</span> ListenableBuilder(<br>      listenable: Listenable.merge([controller.color, controller.size]),<br>      builder: (_, child) =&gt; Container(<br>        width: controller.size.value,<br>        height: controller.size.value,<br>        decoration: ShapeDecoration(<br>          color: controller.color.value,<br>          shape: CircleBorder(),<br>        ),<br>        child: child,<br>      ),<br>      child: Center(<br>        child: TextButton(<br>          onPressed: () &#123;<br>            controller.size.value += <span class="hljs-number">20</span>;<br>            controller.color.value = Colors.blue;<br>          &#125;,<br>          child: Text(<span class="hljs-string">&#x27;Circle&#x27;</span>),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里基本上就实现了状态管理，我们通过<code>InheritedWidget</code>来保存状态，在子组件中通过<code>context</code>来获取到状态，然后状态使用<code>ChangeNotifier</code>+<code>ListenableBuilder</code>实现局部刷新。</p><p>接下来在继续看下<code>InheritedWidget</code>的<code>updateShouldNotify</code>方法，当然前面我们重写时是直接返回了<code>false</code>，而它实际的作用是用来通知依赖的组件进行重建的。我们在获取<code>InheritedWidget</code>时，是通过<code>context</code>获取的，有两种方式，一个是<code>getInheritedWidgetOfExactType</code>，一个是<code>dependOnInheritedWidgetOfExactType</code>，其中使用<code>dependOn</code>开头的方法获取时，会将自身注册到<code>InheritedWidget</code>中，而<code>get</code>开头的仅仅是获取而不会注册。</p><p><code>InheritedWidget</code>实际上本来应该是要配合有状态组件来完成数据传递的，当状态发生变化时，会通知到<code>InheritedWidget</code>，然后它再去通知依赖的子组件进行重建，举个例子：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 持有状态的InheritedWidget</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateInheritedWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> size;<br>  <span class="hljs-keyword">final</span> Color color;<br><br>  <span class="hljs-keyword">const</span> StateInheritedWidget(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">super</span>.child,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.size,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.color,<br>  &#125;);<br><br>  <span class="hljs-comment">// 不通知更新</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> updateShouldNotify(<span class="hljs-keyword">covariant</span> StateInheritedWidget oldWidget) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 普通的子组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> ChildWidget(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 获取到状态，然后使用</span><br>    <span class="hljs-keyword">final</span> state = context<br>        .dependOnInheritedWidgetOfExactType&lt;StateInheritedWidget&gt;()!;<br>    <span class="hljs-keyword">return</span> Container(<br>      width: state.size,<br>      height: state.size,<br>      decoration: ShapeDecoration(color: state.color, shape: CircleBorder()),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 父组件，实际的状态持有者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> TopWidget(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;TopWidget&gt; createState() =&gt; _TopWidgetState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_TopWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">TopWidget</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">double</span> _size = <span class="hljs-number">100</span>;<br>  Color _color = Colors.red;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        <span class="hljs-comment">// 使用InheritedWidget传递状态，实际布局是ChildWidget</span><br>        StateInheritedWidget(size: _size, color: _color, child: ChildWidget()),<br>        ElevatedButton(onPressed: ()&#123;<br>          setState(() &#123;<br>            _size += <span class="hljs-number">40</span>;<br>            _color = Colors.blue;<br>          &#125;);<br>        &#125;, child: Text(<span class="hljs-string">&#x27;Button&#x27;</span>))<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码实际是能正常运行的，并且点击按钮也会响应颜色和尺寸的修改。这是因为当点击按钮时通过<code>setState</code>触发了<code>TopWidget#build</code>，导致所有的组件都重建了一次，所以是能够正常显示的。如果我们不想让它重建，那么可以将不重建的部分通过<code>const</code>修饰。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_TopWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">TopWidget</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">double</span> _size = <span class="hljs-number">100</span>;<br>  Color _color = Colors.red;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        <span class="hljs-comment">// 在ChildWidget前面加了const</span><br>        StateInheritedWidget(size: _size, color: _color, child: <span class="hljs-keyword">const</span> ChildWidget()),<br>        ElevatedButton(onPressed: ()&#123;<br>          setState(() &#123;<br>            _size += <span class="hljs-number">40</span>;<br>            _color = Colors.blue;<br>          &#125;);<br>        &#125;, child: Text(<span class="hljs-string">&#x27;Button&#x27;</span>))<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时点击按钮时，颜色和尺寸虽然改变了，但是由于<code>ChildWidget</code>没有重建，因此会导致点击按钮时，界面不会发生变化。如果想要它变化，就需要在<code>InheritedWidget</code>中重写<code>updateShouldNotify</code>的逻辑。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 持有状态的InheritedWidget</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateInheritedWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> size;<br>  <span class="hljs-keyword">final</span> Color color;<br><br>  <span class="hljs-keyword">const</span> StateInheritedWidget(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">super</span>.child,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.size,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.color,<br>  &#125;);<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> updateShouldNotify(<span class="hljs-keyword">covariant</span> StateInheritedWidget oldWidget) &#123;<br>    <span class="hljs-comment">// 当新旧InheritedWidget数据不一致时通知依赖的子组件重新build</span><br>    <span class="hljs-keyword">return</span> oldWidget.size != size || oldWidget.color != color;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改成以上的逻辑就可以了，这个方法的作用就是在它发生重建时，决定是否通知依赖的子组件进行重建。而依赖的子组件是在<code>context.dependOnInheritedWidgetOfExactType</code>获取时注册进来的，因此即使子组件被声明为<code>const</code>，当<code>InheritedWidget</code>通知你刷新时，子组件就必须要重新<code>build</code>了。</p><p>再回到我们最初的例子中，我们的状态使用的是<code>ChangeNotifier</code>，观察者使用的是<code>ListenableBuilder</code>，也就是我们只需要它传递状态的能力，而不需要它的这一套刷新逻辑，所以我们只需要简单的<code>return false</code>即可。并且我们在获取状态时，也直接使用<code>get</code>开头的方法就行，而不需要使用<code>dependOn</code>开头的方法。</p><p>由于<code>InheritedWidget</code>是抽象类，所以我们使用时必须要继承它，就像前面我们声明的<code>CircleControllerProvider</code>一样。当然这样写不是太合适，毕竟不可能每个<code>controller</code>都写一个对应的类吧，因此我们再对他抽象一下，使用泛型声明一个通用的类：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProvider</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> T controller;<br><br>  <span class="hljs-keyword">const</span> MyProvider(&#123;<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.controller, <span class="hljs-keyword">required</span> <span class="hljs-keyword">super</span>.child&#125;);<br><br>  <span class="hljs-keyword">static</span> T of&lt;T&gt;(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> context<br>        .dependOnInheritedWidgetOfExactType&lt;MyProvider&lt;T&gt;&gt;()!<br>        .controller;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> T? maybeOf&lt;T&gt;(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> context<br>        .dependOnInheritedWidgetOfExactType&lt;MyProvider&lt;T&gt;&gt;()<br>        ?.controller;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> updateShouldNotify(<span class="hljs-keyword">covariant</span> InheritedWidget oldWidget) =&gt; <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就可以直接使用<code>MyProvider</code>来传递状态了，而不需要再重新写一遍。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="dart hljs">MyProvider(<br>  controller: ValueNotifier&lt;<span class="hljs-built_in">double</span>&gt;(<span class="hljs-number">100</span>), <br>  child: MyProvider(<br>    controller: ValueNotifier&lt;<span class="hljs-built_in">double</span>&gt;(<span class="hljs-number">200</span>), <br>    <span class="hljs-comment">// 包了两层MyProvider</span><br>    child: MyChild()<br>  )<br>),<br></code></pre></td></tr></table></figure><p>如果在界面中，用到了多个<code>InheritedWidget</code>，并且它们的类型是一样的，这样在子组件中通过<code>context</code>获取时，就只会查找到离他最近的那个<code>InheritedWidget</code>。例如上面的例子中，<code>MyChild</code>在获取状态时，拿到的是200，而不是100。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Flutter</code>状态管理的实质就是状态提升，将状态提升到一定的高度后，方便对其进行管理以及方便子组件对状态的共享使用。</p><p>后面我们所做的一系列操作，都是为了解决状态提升后引入的问题，一是状态传递问题，一是全局刷新问题。针对这两个问题，我们可以引用<code>InheritedWidget</code>来解决状态的传递问题，然后在引入<code>ChangeNotifier</code>+<code>ListenableBuilder</code>解决全局刷新的问题。</p><p>整体逻辑如下图：顶层用<code>InheritedWidget</code>提供状态，需要使用状态的组件用<code>ListenableBuilder</code>包裹，不变的用<code>child</code>引用。然后注册监听，当监听到状态变化时，触发<code>rebuild</code>刷新界面。</p><p><img alt="状态管理" class="lozad post-image" src="/img/cover/cover-flutter-state.webp" data-src="/img/cover/cover-flutter-state.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Tue Sep 10 2024 13:36:55 GMT+0800");let n="Tue Sep 10 2024 13:36:55 GMT+0800";n="2025-11-04 12:17:53 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Flutter/" class="post-footer-category">#&nbsp;Flutter</a> <a href="/tags/Flutter/" class="post-footer-tag">#&nbsp;Flutter</a></div><div class="nav"><div class="nav-item-prev"><a href="/2024/10/05/flutter-provider/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">Flutter状态管理框架Provider</div></div></a></div><div class="nav-item-next"><a href="/2024/08/16/flutter-canvas/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Flutter自定义绘制CustomPaint</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#StatelessWidget" class="toc-link"><span class="toc-text">StatelessWidget</span></a></li><li class="toc-item toc-level-3"><a href="#StatefulWidget" class="toc-link"><span class="toc-text">StatefulWidget</span></a></li><li class="toc-item toc-level-3"><a href="#ChangeNotifier" class="toc-link"><span class="toc-text">ChangeNotifier</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#Listenable" class="toc-link"><span class="toc-text">Listenable</span></a></li><li class="toc-item toc-level-4"><a href="#ChangeNotifier-1" class="toc-link"><span class="toc-text">ChangeNotifier</span></a></li><li class="toc-item toc-level-4"><a href="#ValueNotifier" class="toc-link"><span class="toc-text">ValueNotifier</span></a></li><li class="toc-item toc-level-4"><a href="#ListenableBuilder" class="toc-link"><span class="toc-text">ListenableBuilder</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#InheritedWidget" class="toc-link"><span class="toc-text">InheritedWidget</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2025-01-01</div><a href="/2025/01/01/flutter-animation/"><div class="recent-posts-item-content">Flutter动画</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-12-20</div><a href="/2024/12/20/flutter-getx-source/"><div class="recent-posts-item-content">GetX原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-08-16</div><a href="/2024/08/16/flutter-canvas/"><div class="recent-posts-item-content">Flutter自定义绘制CustomPaint</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2025-01-01</div><a href="/2025/01/01/flutter-animation/"><div class="recent-posts-item-content">Flutter动画</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-12-20</div><a href="/2024/12/20/flutter-getx-source/"><div class="recent-posts-item-content">GetX原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>