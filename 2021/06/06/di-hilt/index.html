<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>好用的依赖注入框架-Hilt</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>28</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>14</span> <span>标签</span> </a><a class="author-word-count"><span>11.5</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" class="toc-link"><span class="toc-text">为什么使用依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E6%B7%BB%E5%8A%A0Hilt%E4%BE%9D%E8%B5%96" class="toc-link"><span class="toc-text">添加Hilt依赖</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C" class="toc-link"><span class="toc-text">前置工作</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E4%BD%BF%E7%94%A8Hilt" class="toc-link"><span class="toc-text">使用Hilt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#Inject%E6%A0%87%E8%AE%B0%E6%B3%A8%E5%85%A5" class="toc-link"><span class="toc-text">@Inject标记注入</span></a></li><li class="toc-item toc-level-4"><a href="#AndroidEntryPoint%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9" class="toc-link"><span class="toc-text">@AndroidEntryPoint注入的入口点</span></a></li><li class="toc-item toc-level-4"><a href="#HiltViewModel-%E6%B3%A8%E5%85%A5ViewModel" class="toc-link"><span class="toc-text">@HiltViewModel 注入ViewModel</span></a></li><li class="toc-item toc-level-4"><a href="#Module-InstallIn-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97" class="toc-link"><span class="toc-text">@Module @InstallIn 声明一个模块</span></a></li><li class="toc-item toc-level-4"><a href="#%E7%BB%84%E4%BB%B6Component" class="toc-link"><span class="toc-text">组件Component</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#SingletonComponent" class="toc-link"><span class="toc-text">SingletonComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ActivityRetainedComponent" class="toc-link"><span class="toc-text">ActivityRetainedComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ActivityComponent" class="toc-link"><span class="toc-text">ActivityComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ViewModelComponent" class="toc-link"><span class="toc-text">ViewModelComponent</span></a></li><li class="toc-item toc-level-5"><a href="#FragmentComponent" class="toc-link"><span class="toc-text">FragmentComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ViewComponent" class="toc-link"><span class="toc-text">ViewComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ViewWithFragmentComponent" class="toc-link"><span class="toc-text">ViewWithFragmentComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ServiceComponent" class="toc-link"><span class="toc-text">ServiceComponent</span></a></li><li class="toc-item toc-level-5"><a href="#%E4%B8%83%E7%A7%8D%E7%BB%84%E4%BB%B6%E7%9A%84module%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BB%85%E9%80%82%E7%94%A8class%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84module" class="toc-link"><span class="toc-text">七种组件的module生命周期以及使用范围，仅适用class关键字的module</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F" class="toc-link"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-6"><a href="#%E5%AF%B9%E5%BA%94Component%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F" class="toc-link"><span class="toc-text">对应Component的作用域</span></a></li></ol></li><li class="toc-item toc-level-5"><a href="#Provide%E5%92%8C-Binds" class="toc-link"><span class="toc-text">@Provide和@Binds</span></a></li><li class="toc-item toc-level-5"><a href="#Qualifier" class="toc-link"><span class="toc-text">Qualifier</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#%E5%85%B6%E4%BB%96" class="toc-link"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E9%99%84%E9%A1%B5" class="toc-link"><span class="toc-text">附页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88Hilt%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8E%BB%E5%88%9B%E5%BB%BAViewModel" class="toc-link"><span class="toc-text">为什么Hilt可以用原生的方式去创建ViewModel</span></a></li></ol></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="好用的依赖注入框架-Hilt thumbnail" class="image lozad" src="/img/cover/cover-hilt.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">好用的依赖注入框架-Hilt</h1></header><div class="post-meta post-show-meta"><time datetime="2021-06-06T12:56:48.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2021-06-06</span> </time><span class="dot"></span> <a href="/categories/Third-Libraries/" class="post-meta-link">Third Libraries </a><span class="dot"></span> <span>约6.3k 字</span></div><div class="post-content" id="section"><h3 id="为什么使用依赖注入"><a href="#为什么使用依赖注入" class="headerlink" title="为什么使用依赖注入"></a>为什么使用依赖注入</h3><p>要学习某个框架，必须要弄明白它是用来干嘛的，有什么好处。 那么<code>Hilt</code>是什么呢，它有什么好处呢？</p><p>首先，<code>Hilt</code>是一个依赖注入框架。依赖就是一个对象的功能依赖于其他对象去实现。就比如我们要上网，那我们就依赖于手机或者电脑，而在项目中，<code>ViewModel</code>想要获取数据就依赖于数据仓库<code>Repository</code>。我们依赖于某个东西的功能去实现自己的需求，这就是依赖。</p><p>而想要使用某个对象的功能，通常是直接<code>new</code>一个对象出来然后使用它的功能即可。但是这样的话，当依赖的对象很多的话，会导致类本身非常臃肿。因为要保持对每个依赖对象的创建和维护，而我们仅仅是想要使用它的功能而已，对于其他的并不关心。因此可以提供一个方法<code>setXXX</code>，这样类本身并不去创建维护对象，而是交给外部去管理并传递进来，这就是注入。</p><p>将依赖对象的创建交给了外部去传递进来，那么这个外部又应该是谁呢？发现这个过程交给谁都不太合适，因此就单独创建一个容器去创建管理，这个容器就是依赖注入框架，也就是本章说的<code>Hilt</code>。</p><h4 id="添加Hilt依赖"><a href="#添加Hilt依赖" class="headerlink" title="添加Hilt依赖"></a>添加Hilt依赖</h4><p>首先在项目的<code>build.gradle</code>中加入如下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    ext.hilt_version = <span class="hljs-string">&quot;2.36&quot;</span><br>    ...<br>    dependencies &#123;<br>        ...<br>        classpath <span class="hljs-string">&quot;com.google.dagger:hilt-android-gradle-plugin:$hilt_version&quot;</span><br>    &#125;<br>&#125;<br>...<br><br></code></pre></td></tr></table></figure><p>然后在要使用Hilt的<code>module</code>的<code>build.gradle</code>中加入：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    ...<br>    id <span class="hljs-string">&#x27;kotlin-kapt&#x27;</span><br>    id <span class="hljs-string">&#x27;dagger.hilt.android.plugin&#x27;</span><br>&#125;<br><br>android &#123;<br>    ...<br>    compileOptions &#123;<br>        sourceCompatibility JavaVersion.VERSION_1_8<br>        targetCompatibility JavaVersion.VERSION_1_8<br>    &#125;<br>    ...<br>&#125;<br><br>dependencies &#123;<br>    ...<br>    implementation <span class="hljs-string">&quot;com.google.dagger:hilt-android:$hilt_version&quot;</span><br>    kapt <span class="hljs-string">&quot;com.google.dagger:hilt-android-compiler:$hilt_version&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h4><p>要使用Hilt，首先要对<code>Application</code>进行处理，使用<code>@HiltAndroidApp</code>去注解<code>Application</code>。这是必须要做的，使用这个注解后，Hilt才会去生成一系列的容器组件，这时候才能够使用Hilt。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// App.kt</span><br><span class="hljs-meta">@HiltAndroidApp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span>:<span class="hljs-type">Application</span>()<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">// AndroidManifest.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.App&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="使用Hilt"><a href="#使用Hilt" class="headerlink" title="使用Hilt"></a>使用Hilt</h3><h4 id="Inject标记注入"><a href="#Inject标记注入" class="headerlink" title="@Inject标记注入"></a>@Inject标记注入</h4><p>Hilt的注入是通过注解来进行标识的，要注入的对象使用<code>@Inject</code>注解即可。同样的，要注入的对象的构造方法也要使用<code>@Inject</code>注解，如下例。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// Person.kt</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Hello&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// MainActivity.kt</span><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> person: Person<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        person.say()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>MainActivity</code>中并没有直接给<code>person</code>赋值，而是使用了<code>@Inject</code>进行注解，然后就直接使用了，这是因为Hilt在背后给这个字段去初始化赋值了。为了能够让Hilt去生成一个Person对象进行注入，我们还要给Person的构造方法上也加上<code>@Inject</code>，这样就完成了一个最简单的依赖注入了。</p><h4 id="AndroidEntryPoint注入的入口点"><a href="#AndroidEntryPoint注入的入口点" class="headerlink" title="@AndroidEntryPoint注入的入口点"></a>@AndroidEntryPoint注入的入口点</h4><p>还有一点就是在<code>MainActivity</code>上还使用了<code>@AndroidEntryPoint</code>，这个注解表示当前的<code>Activity</code>是一个注入的入口点，可以进行注入。Hilt并不是在哪都能进行注入的，而是有着特定的入口点，并且入口点必须得通过<code>@AndroidEntryPoint</code>注释。其中入口点有<strong>6</strong>个，<code>Application，Activity，Fragment，View，Service，BroadcastReceiver</code>。但是<code>Application</code>这个入口点不用使用<code>@AndroidEntryPoint</code>注解，因为它已经有了<code>@HiltAndroidApp</code>，所以可以直接注入。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// App.kt</span><br><span class="hljs-meta">@HiltAndroidApp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span>:<span class="hljs-type">Application</span>() &#123;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> person: Person<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate()<br>        person.say()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这几个入口点中，<code>View</code>和<code>Fragment</code>有些特殊，其他的入口点只要注解为<code>@AndroidEntryPoint</code>后，即可在其中进行Hilt的注入。但是对于Fragment而言，若是想在Fragment中使用Hilt的注入，除了在Fragment上使用@AndroidEntryPoint外，<strong>还要在其宿主Activity上也加上这个注解</strong>才行。而对于View而言，若是在View中使用Hilt的注入，首先在View上使用@AndroidEntryPoint，然后<strong>若是View用在Activity上，则Activity上也要加该注解。若是View用在Fragment上，则Fragment和Fragment的宿主Activity都要加上这个注解</strong>。</p><p>可以看到Hilt的使用是比较简单的，首先将类的构造方法使用<code>@Inject</code>注解，这表明该类可以被Hilt自动创建并注入到相应的地方，然后就是在入口点中使用@Inject进行注入即可。</p><h4 id="HiltViewModel-注入ViewModel"><a href="#HiltViewModel-注入ViewModel" class="headerlink" title="@HiltViewModel 注入ViewModel"></a>@HiltViewModel 注入ViewModel</h4><p><code>ViewModel</code>的注入和普通对象一样，首先给构造方法加@Inject，但是比普通对象多出来的是还要在它上面加入<code>@HiltViewModel</code>。并且注入的地方<strong>不能使用@Inject</strong>，而是和普通的使用ViewModel保持一致，使用<code>ViewModelProvider</code>去获取ViewModel。</p><p>注意这里不能使用@Inject去注入ViewModel，否则获取到的ViewModel只是一个普通对象，它在Activity销毁的时候也会被回收，而无法做到如ViewModel那样的在配置改变的时候依旧保存下来。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// MainAcitivity.kt</span><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> viewModel: ViewModel<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        viewModel = ViewModelProvider(<span class="hljs-keyword">this</span>)[MyViewModel::<span class="hljs-keyword">class</span>.java]<br>        println(viewModel)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// MyViewModel.kt</span><br><span class="hljs-meta">@HiltViewModel</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() : ViewModel()<br></code></pre></td></tr></table></figure><p>如是嫌弃<code>ViewModelProvider</code>方式获取的太麻烦，则可以使用<code>Activity-ktx</code>的获取方式：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// build.gradle中加入依赖</span><br>implementation <span class="hljs-string">&#x27;androidx.activity:activity-ktx:1.2.3&#x27;</span><br><br><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span>  viewModel:MyViewModel <span class="hljs-keyword">by</span> viewModels()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 若是想要在Fragment中也这样使用，需要加入Fragment-ktx的依赖：</span><br>implementation <span class="hljs-string">&#x27;androidx.fragment:fragment-ktx:1.3.4&#x27;</span><br></code></pre></td></tr></table></figure><p>对于无法在构造方法上加<code>@Inject</code>的类如系统类三方库中的类等，是不能直接进行注入的，要通过安装模块的方式去添加依赖。</p><h4 id="Module-InstallIn-声明一个模块"><a href="#Module-InstallIn-声明一个模块" class="headerlink" title="@Module @InstallIn 声明一个模块"></a>@Module @InstallIn 声明一个模块</h4><p>模块也就是<code>Module</code>，是一个类文件，它包含了很多的方法，这些方法就是用来提供注入对象的。</p><p>模块必须使用@Module来进行注解，说明当前类是一个Hilt模块，可以用来提供依赖。并且同时还要使用<code>@InstallIn</code>注解，该注解接收一个数组类型的参数，表示安装在哪个组件上。</p><p>组件代表着一个作用范围，安装在该组件上的模块所提供的依赖方法，只能在当前组件范围内才能进行注入。而且不同的组件对应着不同的生命周期，安装在它上面的模块只会在其生命周期内存在。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// NetModule.kt</span><br><span class="hljs-meta">@InstallIn(SingletonComponent::class)</span><br><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">object</span> NetModule &#123;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideRetrofit</span><span class="hljs-params">()</span></span>: Retrofit &#123;<br>        <span class="hljs-keyword">return</span> Retrofit.Builder()<br>            .baseUrl(<span class="hljs-string">&quot;https://xxxx.com/&quot;</span>)<br>            .build()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上例，就是声明了一个<code>NetModule</code>模块，用来提供<code>Retrofit</code>的依赖，并且安装在<code>SingletonComponent</code>组件上，<code>SingletonComponent</code>组件的作用范围是全局，因此在所有的地方都能使用该模块所提供依赖注入，也就是对Retrofit的注入。</p><p>在这个模块中，有个<code>@Provide</code>标注的方法，该注解表明这个方法是是用来提供依赖的。注意它的返回值是Retrofit，表明需要注入Retrofit实例的时候，就会通过这个方法去生成一个实例对象进行注入。在Module中，Module的类名，方法名都是随意定的，Hilt只关心返回值。下面就是可以直接在Activity中注入Retrofit了：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// MainActivity.kt</span><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> retrofit: Retrofit<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        println(retrofit.hashCode())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="组件Component"><a href="#组件Component" class="headerlink" title="组件Component"></a>组件Component</h4><p>当声明一个module的时候，必须要安装在组件上，这代表当前module可以给哪些类进行注入。在Hilt中，一共有<strong>八</strong>种组件，下面将逐一介绍组件的生命周期和作用范围。</p><h5 id="SingletonComponent"><a href="#SingletonComponent" class="headerlink" title="SingletonComponent"></a>SingletonComponent</h5><p><code>SingletonComponent</code>是针对<code>Application</code>的组件，安装在它上面的module会与Application的生命周期保持一致，在<code>Application#onCreate</code>的时候创建，在<code>Application#onDestroy</code>的时候销毁。并且该module所提供的依赖，<strong>在整个程序中都是可以使用的。</strong></p><p>下面声明了两个模块，都是安装在<code>SingletonComponent</code>上的，但是一个是普通类，一个是单例类：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(SingletonComponent::class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalModule</span> &#123;...&#125;<br><br><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(SingletonComponent::class)</span><br><span class="hljs-keyword">object</span> SingletonModule &#123;...&#125;<br></code></pre></td></tr></table></figure><p>这两种类型的模块有什么区别呢？使用<code>class</code>关键字的类是一个普通对象，因此会存在创建和销毁。它存在的范围也就是前面所说的组件的生命周期。例如在<code>SingletonSomponent</code>组件上，会在<code>Application#onCreate</code>的时候去<code>new</code>出一个<code>NormalModule</code>的实例对象，在<code>Application#onDestroy</code>的时候回收这个对象。</p><p>注意他是每个组件都会生成一个Module对象实例，例如若是这个module安装在<code>ActivityComponent</code>上的时候，会在每个<code>Activity#onCreate</code>的时候去创建一个module实例，也就是说，<em>每个Activity对应的module都是独立的对象</em>。</p><p>而使用<code>object</code>关键字的话，声明出来的module是一个<code>单例对象</code>，因此不会存在创建销毁过程。提供依赖的时候，用的都是同一个单例对象。</p><h5 id="ActivityRetainedComponent"><a href="#ActivityRetainedComponent" class="headerlink" title="ActivityRetainedComponent"></a>ActivityRetainedComponent</h5><p><code>ActivityRetainedComponent</code>是针对<code>Activity</code>的组件，因此它的生命周期是<code>Activity#onCreate</code>到<code>Activity#onDestroy</code>，但是它又比这个范围长一些。也就是当配置更改的时候，如旋转屏幕导致的Activity重建的时候，该组件并不会销毁，而是真正结束一个Activity的时候才会去销毁。简单来说就是生命周期与<code>ViewModel</code>是一致的。</p><p>安装在<code>ActivityRetainedComponent</code>组件上的module提供的依赖，<strong>可以在ViewModel中，Activity中，Fragment中，以及View中注入。</strong></p><h5 id="ActivityComponent"><a href="#ActivityComponent" class="headerlink" title="ActivityComponent"></a>ActivityComponent</h5><p><code>ActivityComponent</code>组件的生命周期也是与Activity一致，但是，它是跟<code>Activity</code>完全一致的。只要Activity销毁，对应的组件也会销毁。</p><p>安装在<code>ActivityComponent</code>上的module提供的依赖，<strong>可以在Activity中，Fragment中，以及View中注入</strong>。</p><h5 id="ViewModelComponent"><a href="#ViewModelComponent" class="headerlink" title="ViewModelComponent"></a>ViewModelComponent</h5><p><code>ViewModelComponent</code>组件和<code>ActivityRetainedComponent</code>是一样的，声明周期也是与<code>ViewModel</code>一致。唯一的区别是，安装在它上面的模块提供的依赖<strong>只能在ViewModel中使用</strong>。</p><h5 id="FragmentComponent"><a href="#FragmentComponent" class="headerlink" title="FragmentComponent"></a>FragmentComponent</h5><p><code>FragmentComponent</code>组件是针对于<code>Fragment</code>的，安装在它上面的组件在<code>Fragment#onAttach</code>的时候创建，在<code>Fragment#onDestroy</code>的时候销毁。</p><p>安装在它上面的module提供的依赖，<strong>只能在Fragment中注用</strong>。</p><h5 id="ViewComponent"><a href="#ViewComponent" class="headerlink" title="ViewComponent"></a>ViewComponent</h5><p><code>ViewComponent</code>组件是针对于<code>View</code>的，在<code>View创建的时候</code>创建，在<code>视图销毁</code>的时候销毁。并且安装在它上面的module提供的依赖<strong>只能在View中使用</strong>。</p><h5 id="ViewWithFragmentComponent"><a href="#ViewWithFragmentComponent" class="headerlink" title="ViewWithFragmentComponent"></a>ViewWithFragmentComponent</h5><p><code>ViewWithFragmentComponent</code>也是针对<code>View</code>的，但是注入的时候不仅要求在View上加入<code>@AndroidEntryPoint</code>，还要加上<code>@WithFragmentBindings</code>。安装在它上面的模块的生命周期也是与ViewComponent一样的。其中提供的依赖<strong>只能用在View上</strong>，<em>而且这个View还只能用在Fragment中，不能用在Activity中</em>。</p><h5 id="ServiceComponent"><a href="#ServiceComponent" class="headerlink" title="ServiceComponent"></a>ServiceComponent</h5><p><code>ServiceComponent</code>组件是针对<code>Service</code>的，依附于它的module在<code>Service#onCreate</code>的时候创建，在<code>Service#onDestroy</code>的时候销毁。并且安装在它上面的module<strong>只能用在Service中</strong>。</p><h5 id="七种组件的module生命周期以及使用范围，仅适用class关键字的module"><a href="#七种组件的module生命周期以及使用范围，仅适用class关键字的module" class="headerlink" title="七种组件的module生命周期以及使用范围，仅适用class关键字的module"></a>七种组件的module生命周期以及使用范围，仅适用class关键字的module</h5><table><thead><tr><th>组件</th><th>module创建</th><th>module销毁</th><th>可使用的入口点</th></tr></thead><tbody><tr><td>SingletonComponent</td><td>Application#onCreate</td><td>Application#onDestroy</td><td>全部</td></tr><tr><td>ActivityRetainedComponent</td><td>Activity#onCreate</td><td>Activity#onDestroy</td><td>ViewModel,Activity,Fragment,View</td></tr><tr><td>ActivityComponent</td><td>Activity#onCreate</td><td>Activity#onDestroy</td><td>Activity,Fragment,View</td></tr><tr><td>ViewModelComponent</td><td>Activity#onCreate</td><td>Activity#onDestroy</td><td>ViewModel</td></tr><tr><td>FragmentComponent</td><td>Fragment#onAttach</td><td>Fragment#onDestroy</td><td>Fragment</td></tr><tr><td>ViewComponent</td><td>View创建</td><td>View销毁</td><td>View</td></tr><tr><td>ViewWithFragmentComponent</td><td>View创建</td><td>View销毁</td><td>View</td></tr><tr><td>ServiceComponent</td><td>Service#onCreate</td><td>Service#onDestroy</td><td>Service</td></tr></tbody></table><p>作用范围很好理解，是用来缩小注入的范围，以避免滥用注入。那么生命周期又有什么用呢？比如在<code>MainActivity</code>中有三个<code>Fragment</code>，这三个Fragment想要共享一个对象<code>Person</code>，那么该怎么实现呢？</p><p>第一种方法是定义在Activity中，然后通过Fragment拿到Activity，进而拿到这个Person对象。第二个方法是将Person对象放到Activity的ViewModel中，然后在Fragment中也去获取这个ViewModel，进而拿到Person对象。</p><p>最后一种方式就是利用Hilt生命周期的特性：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareModule</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> person = Person()<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">providePerson</span><span class="hljs-params">()</span></span>: Person &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.person<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们知道，<code>ActivityComponent</code>上的module的在<code>Activity#onCreate</code>的时候创建，在<code>Activity#onDestroy</code>的时候销毁。因此它是与Activity对应的，而这个module提供的依赖是<code>ShareModule</code>中的内部对象。因此，只要Activity没有销毁，这个module也就是同一个对象，进而注入的依赖person也都是同一个对象，从而实现Fragment共享同一个对象。这时候只要在Fragment中这样使用就行了：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> : <span class="hljs-type">Fragment</span>()&#123;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> person: Person<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h6><p>除了使用上述的方式可以实现在Activity的生命周期内共享某个依赖对象外，Hilt还提供了一个作用域的概念。在某个作用域内，提供的依赖对象也是唯一的，将上例中的ShareModule改造一下：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> ShareModule &#123;<br><br>    <span class="hljs-meta">@ActivityScoped</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">providePerson</span><span class="hljs-params">()</span></span>: Person &#123;<br>        <span class="hljs-keyword">return</span> Person()<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>改造后的module也能实现和前面那样的效果，在Activity的生命周期内提供相同的<code>Person</code>对象。而只是简单的加了一个<code>@ActivityScoped</code>注解，这样，在Activity的生命周期范围内，拿到的依赖对象仍然是同一个，即使将module类使用<code>object</code>关键字声明成了单例类。</p><p>可以看到，使用作用域注解可以实现基于组件生命周期内提供单一对象的功能，这样的话，就可以直接将module定义为单例类就行了，若是<code>java</code>中的话定义成静态方法即可，这样可以用来避免频繁创建对象导致的开销。</p><p>另外注意一点就是，作用域注解必须与组件注解保持一致，比如在<code>ActivityComponent</code>只能使用<code>ActivityScoped</code>作用域，作用域注解的提供依赖的方法，在组件的生命周期内提供的是同一个依赖对象。</p><p>作用域注解不只是在module中使用，直接在类上面加上也是可以的，使用下面的代码也可以实现上述的效果：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@ActivityScoped</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() &#123;...&#125;<br></code></pre></td></tr></table></figure><h6 id="对应Component的作用域"><a href="#对应Component的作用域" class="headerlink" title="对应Component的作用域"></a>对应Component的作用域</h6><table><thead><tr><th>组件</th><th>生命周期</th><th>生命周期</th><th>作用域</th></tr></thead><tbody><tr><td>SingletonComponent</td><td>Application#onCreate</td><td>Application#onDestroy</td><td>Singleton</td></tr><tr><td>ActivityRetainedComponent</td><td>Activity#onCreate</td><td>Activity#onDestroy</td><td>ActivityRetainedScope</td></tr><tr><td>ActivityComponent</td><td>Activity#onCreate</td><td>Activity#onDestroy</td><td>ActivityScoped</td></tr><tr><td>ViewModelComponent</td><td>Activity#onCreate</td><td>Activity#onDestroy</td><td>ViewModelScoped</td></tr><tr><td>FragmentComponent</td><td>Fragment#onAttach</td><td>Fragment#onDestroy</td><td>FragmentScoped</td></tr><tr><td>ViewComponent</td><td>View创建</td><td>View销毁</td><td>ViewScoped</td></tr><tr><td>ViewWithFragmentComponent</td><td>View创建</td><td>View销毁</td><td>ViewScoped</td></tr><tr><td>ServiceComponent</td><td>Service#onCreate</td><td>Service#onDestroy</td><td>ServiceScoped</td></tr></tbody></table><p>在定义模块的时候，使用<code>@InstallIn</code>可以限定当前模块安装在哪个组件上。其中<code>@InstallIn</code>的参数是个数组，也就是说，我们可以将这个模块安装在多个组件上。使用多个组件可以将作用范围进行扩大，比如使用<code>FragmentComponent</code>和<code>ServiceComponent</code>，就可以使模块中的依赖在<code>Fragment</code>和<code>Service</code>中使用了。但是，使用了多组件的话，因为组件的生命周期和作用范围不同，因此是<strong>不能声明作用域注解的</strong>。</p><p>当然若是两个组件的生命周期是一样的，比如<code>ViewComponent</code>和<code>ViewWithFragmentComponent</code>，则还是可以使用作用域注解<code>@ViewScoped</code>的，但是这没有什么意义，因为<code>ViewComonent</code>的范围是包含了<code>Fragment</code>的。</p><h5 id="Provide和-Binds"><a href="#Provide和-Binds" class="headerlink" title="@Provide和@Binds"></a>@Provide和@Binds</h5><p><code>@Provide</code>前面有说过了，是在Module中用来修饰方法的，被它修饰的方法代表着提供依赖的方法，当需要该类型的依赖对象时，就会调用对应返回值的方法去注入依赖。</p><p>在Module中，类名和方法名都是没有意义的，可以随便起名(当然为了可读性还是不要随便起名)，至于提供什么依赖完全看函数的返回值类型。若是返回值类型是一个接口呢？。</p><p>举个例子，比如有个接口<code>Human</code>，两个子类<code>Man和Woman</code>：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sex</span><span class="hljs-params">()</span></span>: String<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() : Human &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sex</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;男&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() : Human &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sex</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;女&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若是想要在Activity中注入该怎么处理呢，简单，构造方法已经加入注解了，然后直接注入即可：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> man: Man<br><br>    <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> woman: Woman<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        println(<span class="hljs-string">&quot;Man:<span class="hljs-subst">$&#123;man.sex()&#125;</span>, Woman: <span class="hljs-subst">$&#123;woman.sex()&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那我要是想要在Activity中注入Human而不是具体的子类型，该怎么办呢？首先我们知道，Hilt注入的时候是根据类型来查找依赖关系的。顺序是先从当前组件上的Module上查找返回值类型为这个类型的方法，找不到后再去看这个类型的类上的构造方法上是否有<code>@Inject</code>注解，有的话就直接生成一个对象注入了。</p><p>而若是注入类型为Human的，因为Human是个接口，是没有构造方法的，因此也是没法去@Inejct的。因此，若是想注入一个接口类型，必须要为它提供一个module。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> HumanModule &#123;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">()</span></span>:Human &#123;<br>        <span class="hljs-keyword">return</span> Man()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>给<code>ActivityComponent</code>上安装这个Module后，就可以在<code>Activity</code>中使用<code>Human</code>注入了。另外这里注意一点，<em>Module一般是用来提供不可以直接注入的对象</em>，也就是三方库系统类那样的无法在构造方法添加<code>@Inject</code>的类，对于我们自己的类，如上面的<code>Man</code>对象，则不要在<code>provideMan</code>方法中直接去<code>new</code>一个对象，而是应该使用注入的方式，如下：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> HumanModule &#123;<br>    <br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">(man:<span class="hljs-type">Man</span>)</span></span>:Human &#123;<br>        <span class="hljs-comment">// 方法参数中的参数，会被Hilt直接注入</span><br>        <span class="hljs-comment">// 所以若是提供依赖的方法含有参数的话，参数必须是能够被注入的，否则会报错</span><br>        <span class="hljs-keyword">return</span> man<br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> man: Human<br><br>    <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> woman: Human<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        println(<span class="hljs-string">&quot;Man:<span class="hljs-subst">$&#123;man.sex()&#125;</span>, Woman: <span class="hljs-subst">$&#123;woman.sex()&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，在Activity中虽然可以注入Human了，但是注入的两个对象man和woman实际类型都是<code>Man</code>。若是想要它们不一样该怎么处理呢？</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> HumanModule &#123;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">(man:<span class="hljs-type">Man</span>)</span></span>:Human &#123;<br>        <span class="hljs-keyword">return</span> man<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideWoman</span><span class="hljs-params">(woman: <span class="hljs-type">Woman</span>)</span></span>:Human &#123;<br>        <span class="hljs-keyword">return</span> woman<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面的这个代码，直接再加一个方法，提供Woman对象，这样可以吗？当然是不行的，Hilt是根据返回值类型来选择使用哪个方法去生成依赖对象的。这两个方法的返回值都是Human，会导致注入的时候不知道该用哪个，因此这样写在编译的时候就会直接报错了。</p><h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="Qualifier"></a>Qualifier</h5><p><code>@Qualifier</code>就是用来解决上述问题的，当moudle中的两个或多个方法返回的类型是同样的时候，就代表着有了依赖冲突，肯定是编译不过的。因此就需要解决冲突，而解决冲突的方式就是给它们添加限定符，这样就可以将它们区分开了。<br>注意注入的时候也要加上限定符：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 定义两个注解，这两个注解用@Qualifier注解，代表着两种限定符</span><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManType</span><br><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WomanType</span><br><br><span class="hljs-comment">// 给module中重复的类型添加限定符</span><br><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> HumanModule &#123;<br>    <span class="hljs-meta">@ManType</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">(man:<span class="hljs-type">Man</span>)</span></span>:Human &#123;<br>        <span class="hljs-keyword">return</span> man<br>    &#125;<br><br>    <span class="hljs-meta">@WomanType</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideWoman</span><span class="hljs-params">(woman: <span class="hljs-type">Woman</span>)</span></span>:Human &#123;<br>        <span class="hljs-keyword">return</span> woman<br>    &#125;    <br>&#125;<br><br><span class="hljs-comment">// 使用的时候也要加上限定符</span><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-meta">@ManType</span><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> man: Human<br><br>    <span class="hljs-meta">@WomanType</span><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> woman: Human<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到上例中，有两个方法返回的都是Human，但是通过<code>ManType</code>和<code>WomanType</code>注解进行了区分，在Activity中注入的时候也是要进行区分的，否则仍然会导致编译失败。若是在注入的时候不想使用<code>Qualifier</code>，那么可以在Module中再增加一个方法，不加以任何修饰，这样就可以使用默认的了。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> HumanModule &#123;<br>    <span class="hljs-meta">@ManType</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">(man: <span class="hljs-type">Man</span>)</span></span>: Human &#123;<br>        <span class="hljs-keyword">return</span> man<br>    &#125;<br><br>    <span class="hljs-meta">@WomanType</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideWoman</span><span class="hljs-params">(woman: <span class="hljs-type">Woman</span>)</span></span>: Human &#123;<br>        <span class="hljs-keyword">return</span> woman<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDefault</span><span class="hljs-params">(man: <span class="hljs-type">Man</span>)</span></span>: Human &#123;<br>        <span class="hljs-keyword">return</span> man<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在Activity中的这三种注入，分别对应上面module中的方法</span><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-meta">@ManType</span><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> man: Human <span class="hljs-comment">// Man类型，provideMan方法提供</span><br><br>    <span class="hljs-meta">@WomanType</span><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> woman: Human <span class="hljs-comment">// Woman类型，provideWoman方法提供</span><br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> default: Human <span class="hljs-comment">// Man类型，provideDefault方法提供</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>上述就是<code>Qualifier</code>方法的使用情景，从开始到现在我们都是在module中使用<code>@Provides</code>去提供依赖，实际上还可以通过<code>@Binds</code>去提供依赖，这里改一下module：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HumanModule</span> &#123;<br>    <span class="hljs-meta">@ManType</span><br>    <span class="hljs-meta">@Binds</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">(man: <span class="hljs-type">Man</span>)</span></span>: Human<br><br>    <span class="hljs-meta">@WomanType</span><br>    <span class="hljs-meta">@Binds</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideWoman</span><span class="hljs-params">(woman: <span class="hljs-type">Woman</span>)</span></span>: Human<br><br>    <span class="hljs-meta">@Binds</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDefault</span><span class="hljs-params">(man: <span class="hljs-type">Man</span>)</span></span>: Human<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到和使用<code>Provides</code>的区别就是：module必须是一个<code>抽象类</code>，<code>@Provides</code>换成了<code>@Binds</code>，提供依赖的方法必须是一个<code>抽象方法</code>，这个抽象方法<code>只能有一个参数</code>，<code>必须有返回值</code>。这里注意的是提供依赖的方法是个抽象方法，返回值类型是提供的依赖类型，而参数就是实际返回的依赖对象。因此，<code>@Binds</code>仅适用于返回父类型的情况，所以抽象方法的返回值类型必须是参数的父类型。</p><p>相同类型的话仍然是通过<code>Qualifier</code>去进行区分的，所以<code>@Provides</code>方式的<code>module</code>是可以完全取代<code>@Binds</code>方式的。</p><p>这里举例是用接口举例的，实际上对于不是接口的也是可以的，甚至是同一个对象也是没问题的。因为Hilt会将限定符和返回值作为一组判定，只要不发生重复即可，所以返回值是接口还是父类都无关紧要的，如下这样也是可以的：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(SingletonComponent::class)</span><br><span class="hljs-keyword">object</span> NetModule &#123;<br>    <br>    <span class="hljs-meta">@MyRelease</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideRelease</span><span class="hljs-params">()</span></span>:Retrofit &#123;<br>        <span class="hljs-keyword">return</span> Retrofit.Builder()<br>            .baseUrl(<span class="hljs-string">&quot;http://www.xxx.com/&quot;</span>)<br>            .build()<br>    &#125;<br>    <br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideTest</span><span class="hljs-params">()</span></span> :Retrofit &#123;<br>        <span class="hljs-keyword">return</span> Retrofit.Builder()<br>            .baseUrl(<span class="hljs-string">&quot;http://test.com/&quot;</span>)<br>            .build()<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRelease</span><br></code></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其他默认提供的依赖，常用的一个<code>Application</code>，两种<code>Activity</code>，两种<code>Context</code>：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// Application，实际类型是我们自定义的App</span><br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mApp:Application<br><br><span class="hljs-comment">// 在同一个Activity种，这种两注解拿到的都是同一个对象</span><br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> activity:Activity<br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> fragmentActivity: FragmentActivity<br><br><span class="hljs-comment">// 这是Application对应的Context，使用限定符@ApplicationContext区分</span><br><span class="hljs-meta">@ApplicationContext</span><br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mAppContext: Context<br><br><span class="hljs-comment">// 这是Activity对应的Context，使用限定符@ActivityContext区分</span><br><span class="hljs-meta">@ActivityContext</span><br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mContext: Context<br></code></pre></td></tr></table></figure><p>可以看到，Hilt的入口点和组件息息相关。而除了这些入口点外，还能自定义入口点，但是意义不大，因为Hilt定义的入口点基本已经覆盖了Android中比较重要的东西了。所以自定义入口点意义不大。</p><h3 id="附页"><a href="#附页" class="headerlink" title="附页"></a>附页</h3><h4 id="为什么Hilt可以用原生的方式去创建ViewModel"><a href="#为什么Hilt可以用原生的方式去创建ViewModel" class="headerlink" title="为什么Hilt可以用原生的方式去创建ViewModel"></a>为什么Hilt可以用原生的方式去创建ViewModel</h4><p>Hilt对于<code>ViewModel</code>的创建方式和原生的创建方式是一致的，唯一的差别就是Hilt中在<code>ViewModel</code>加入了<code>@HiltViewModel</code>和<code>@Inject</code>两个注解。</p><p>原生有以下两种方式创建：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 方式一，使用activity-ktx提供的委托机制（还有fragment-ktx）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel <span class="hljs-keyword">by</span> viewModels&lt;MyViewModel&gt;()<br>    <br><span class="hljs-comment">// 方式二，使用最基本的获取方式</span><br>viewModel = ViewModelProvider(<span class="hljs-keyword">this</span>)[MyViewModel::<span class="hljs-keyword">class</span>.java]<br></code></pre></td></tr></table></figure><p>其实这两种方式实际都是一样的原理，都是通过<code>getDefaultViewModelProviderFactory()</code>方法去创建一个<code>ViewModelProvider.Factory</code>，然后由这个<code>Factory</code>去创建<code>ViewModel</code>。</p><p>所以，若是想要像正常那样创建<code>ViewModel</code>，则必须要重写<code>getDefaultViewModelProviderFactory</code>方法。实际上，编译时Hilt会根据注解去对于使用<code>@AndroidEnterPointer</code>注解的入口点类生成一个父类，然后通过字节码插桩方式去将该类的父类改为Hilt生成的类。这里这个类就是<code>Hilt_MainActivity</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hilt_MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GeneratedComponentManagerHolder</span> &#123;<br>  ...<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ViewModelProvider.Factory <span class="hljs-title function_">getDefaultViewModelProviderFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> DefaultViewModelFactories.getActivityFactory(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">super</span>.getDefaultViewModelProviderFactory());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在<code>Hilt_MainActivity</code>中也能看到，它确实重写了<code>getDefaultViewModelProviderFactory</code>。</p><p>注意第二个参数是<code>super.getDefaultViewModelProviderFactory</code>，这是原本的Factory。沿着<code>getActivityFactory</code>继续追踪下去，最终会走到<code>HiltViewModelFactory</code>中去，这个类也是Factory的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HiltViewModelFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ViewModelProvider</span>.Factory &#123;<br>  ...<br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ViewModel</span>&gt; T <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;<br>    <span class="hljs-keyword">if</span> (hiltViewModelKeys.contains(modelClass.getName())) &#123;<br>      <span class="hljs-keyword">return</span> hiltViewModelFactory.create(modelClass);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> delegateFactory.create(modelClass);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只看我们关注的部分，也就是Factory接口的实现方法<code>create</code>。从中也可以看出，当<code>hiltViewModelKeys</code>中包含当前要创建的<code>ViewModel</code>的类名的时候，使用<code>hiltViewModelFactory</code>去创建，否则使用<code>delegateFactory</code>去创建。</p><p>其中<code>delegateFactory</code>就是前面说的那个<code>super.getDefaultViewModelProviderFactory</code>，也就是原本的Factory。当<code>ViewModel</code>加了<code>@HiltViewModel</code>注解后，Hilt就会为它生成一个名字叫做<code>原类名_HiltModules</code>的类，并且有个静态的<code>provide</code>方法，该方法返回<code>ViewModel</code>的完整类名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel_HiltModules</span> &#123;<br>    ...<br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoSet</span><br>    <span class="hljs-meta">@HiltViewModelMap</span>.KeySet<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">provide</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;com.example.myapplication.MyViewModel&quot;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而前面<code>HiltViewModelFactory</code>中的<code>hiltViewModelKeys</code>就是调用每个<code>xxx_HiltModules#provide</code>方法形成的Set集合。所以到这里就很清晰了：</p><ul><li><p>若是<code>ViewModel</code>使用了<code>@HiltViewModel</code>注解，就会使用<code>hiltViewModelFactory</code>去创建实例。</p></li><li><p>若是没有使用，则使用<code>delegateFactory</code>(也就是默认的Factory)去创建实例。</p></li></ul><br><p><strong>所以，<code>ViewModel</code>上是否使用<code>@HiltViewModel</code>都是能正常运行的。但是：</strong></p><ul><li><p>&lt;不使用注解&gt; 默认的Factory只能创建<strong>空参构造方法</strong>的<code>ViewModel</code>。</p></li><li><p>&lt;使用注解&gt; Hilt的Factory可以创建<strong>带参数构造方法</strong>的<code>ViewModel</code>，当然参数必须也是可以进行注入的。</p></li></ul></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Sun Jun 06 2021 20:56:48 GMT+0800");let n="Sun Jun 06 2021 20:56:48 GMT+0800";n="2024-07-28 19:49:33 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Third-Libraries/" class="post-footer-category">#&nbsp;Third Libraries</a> <a href="/tags/Jetpack/" class="post-footer-tag">#&nbsp;Jetpack</a></div><div class="nav"><div class="nav-item-prev"><a href="/2021/08/05/database-room/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">将Room的使用方式塞到脑子里</div></div></a></div><div class="nav-item-next"><a href="/2021/04/10/view/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">View的绘制流程</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" class="toc-link"><span class="toc-text">为什么使用依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E6%B7%BB%E5%8A%A0Hilt%E4%BE%9D%E8%B5%96" class="toc-link"><span class="toc-text">添加Hilt依赖</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C" class="toc-link"><span class="toc-text">前置工作</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E4%BD%BF%E7%94%A8Hilt" class="toc-link"><span class="toc-text">使用Hilt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#Inject%E6%A0%87%E8%AE%B0%E6%B3%A8%E5%85%A5" class="toc-link"><span class="toc-text">@Inject标记注入</span></a></li><li class="toc-item toc-level-4"><a href="#AndroidEntryPoint%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9" class="toc-link"><span class="toc-text">@AndroidEntryPoint注入的入口点</span></a></li><li class="toc-item toc-level-4"><a href="#HiltViewModel-%E6%B3%A8%E5%85%A5ViewModel" class="toc-link"><span class="toc-text">@HiltViewModel 注入ViewModel</span></a></li><li class="toc-item toc-level-4"><a href="#Module-InstallIn-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97" class="toc-link"><span class="toc-text">@Module @InstallIn 声明一个模块</span></a></li><li class="toc-item toc-level-4"><a href="#%E7%BB%84%E4%BB%B6Component" class="toc-link"><span class="toc-text">组件Component</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#SingletonComponent" class="toc-link"><span class="toc-text">SingletonComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ActivityRetainedComponent" class="toc-link"><span class="toc-text">ActivityRetainedComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ActivityComponent" class="toc-link"><span class="toc-text">ActivityComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ViewModelComponent" class="toc-link"><span class="toc-text">ViewModelComponent</span></a></li><li class="toc-item toc-level-5"><a href="#FragmentComponent" class="toc-link"><span class="toc-text">FragmentComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ViewComponent" class="toc-link"><span class="toc-text">ViewComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ViewWithFragmentComponent" class="toc-link"><span class="toc-text">ViewWithFragmentComponent</span></a></li><li class="toc-item toc-level-5"><a href="#ServiceComponent" class="toc-link"><span class="toc-text">ServiceComponent</span></a></li><li class="toc-item toc-level-5"><a href="#%E4%B8%83%E7%A7%8D%E7%BB%84%E4%BB%B6%E7%9A%84module%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BB%85%E9%80%82%E7%94%A8class%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84module" class="toc-link"><span class="toc-text">七种组件的module生命周期以及使用范围，仅适用class关键字的module</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F" class="toc-link"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-6"><a href="#%E5%AF%B9%E5%BA%94Component%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F" class="toc-link"><span class="toc-text">对应Component的作用域</span></a></li></ol></li><li class="toc-item toc-level-5"><a href="#Provide%E5%92%8C-Binds" class="toc-link"><span class="toc-text">@Provide和@Binds</span></a></li><li class="toc-item toc-level-5"><a href="#Qualifier" class="toc-link"><span class="toc-text">Qualifier</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#%E5%85%B6%E4%BB%96" class="toc-link"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E9%99%84%E9%A1%B5" class="toc-link"><span class="toc-text">附页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88Hilt%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8E%BB%E5%88%9B%E5%BB%BAViewModel" class="toc-link"><span class="toc-text">为什么Hilt可以用原生的方式去创建ViewModel</span></a></li></ol></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2021-08-05</div><a href="/2021/08/05/database-room/"><div class="recent-posts-item-content">将Room的使用方式塞到脑子里</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-10-12</div><a href="/2021/10/12/bsdiff-translation/"><div class="recent-posts-item-content">【翻译】Naive Differences of Executable Code</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-09-06</div><a href="/2021/09/06/use-bsdiff-to-ugrade/"><div class="recent-posts-item-content">在Android中使用Bsdiff实现增量更新</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-02-20</div><a href="/2021/02/20/use-okhttp-2/"><div class="recent-posts-item-content">OkHttp3整体源码分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-01-27</div><a href="/2021/01/27/use_okhttp/"><div class="recent-posts-item-content">OkHttp3的简单使用</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-08-27</div><a href="/2023/08/27/overscroll/"><div class="recent-posts-item-content">View自定义回弹动效</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-07-11</div><a href="/2023/07/11/coroutine-2/"><div class="recent-posts-item-content">Kotlin协程的实现</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-06-05</div><a href="/2023/06/05/flow-2/"><div class="recent-posts-item-content">SharedFlow、StateFlow、SafeFlow的区别</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-05-22</div><a href="/2023/05/22/flow/"><div class="recent-posts-item-content">协程数据流Flow</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>