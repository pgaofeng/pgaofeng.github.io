<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>好用的依赖注入框架-Hilt | 没有感情的代码机器</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/img/blog.svg"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 7.0.0"></head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.addPlugin({
    "before:highlightBlock": ({ block }) => {
         block.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ /]*>/g, '\n');
    },
    "after:highlightBlock": ({ result }) => {
          result.value = result.value.replace(/\n/g, "<br>");
    }
});
</script><script type="text/javascript" src="/plugins/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/plugins/clipboard/clipboard.use.js" async> </script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">PGAOFENG</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">没有感情的代码机器</a></h1></div><p class="m-desc">不写bug的程序员,<br>不是一个好的程序员！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li class="m-sch"></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">好用的依赖注入框架-Hilt</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2021/06/06/%E5%A5%BD%E7%94%A8%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6-Hilt/">2021-06-06</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/Android/">Android</a>&nbsp;&bull;&nbsp;<a href="/categories/Android/Hilt/">Hilt</a></span></div></div><div class="p-content"><p><img src="/img/cover-hilt.webp" alt="img"></p>
<h3 id="为什么使用依赖注入"><a href="#为什么使用依赖注入" class="headerlink" title="为什么使用依赖注入"></a>为什么使用依赖注入</h3><p>要学习某个框架，必须要弄明白它是用来干嘛的，有什么好处。 那么<code>Hilt</code>是什么呢，它有什么好处呢？</p>
<p>首先，<code>Hilt</code>是一个依赖注入框架。依赖就是一个对象的功能依赖于其他对象去实现。就比如我们要上网，那我们就依赖于手机或者电脑，而在项目中，<code>ViewModel</code>想要获取数据就依赖于数据仓库<code>Repository</code>。我们依赖于某个东西的功能去实现自己的需求，这就是依赖。</p>
<p>而想要使用某个对象的功能，通常是直接<code>new</code>一个对象出来然后使用它的功能即可。但是这样的话，当依赖的对象很多的话，会导致类本身非常臃肿。因为要保持对每个依赖对象的创建和维护，而我们仅仅是想要使用它的功能而已，对于其他的并不关心。因此可以提供一个方法<code>setXXX</code>，这样类本身并不去创建维护对象，而是交给外部去管理并传递进来，这就是注入。</p>
<p>将依赖对象的创建交给了外部去传递进来，那么这个外部又应该是谁呢？发现这个过程交给谁都不太合适，因此就单独创建一个容器去创建管理，这个容器就是依赖注入框架，也就是本章说的<code>Hilt</code>。</p>
<h4 id="添加Hilt依赖"><a href="#添加Hilt依赖" class="headerlink" title="添加Hilt依赖"></a>添加Hilt依赖</h4><p>首先在项目的<code>build.gradle</code>中加入如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    ext.hilt_version = <span class="hljs-string">&quot;2.36&quot;</span><br>    ...<br>    dependencies &#123;<br>        ...<br>        classpath <span class="hljs-string">&quot;com.google.dagger:hilt-android-gradle-plugin:$hilt_version&quot;</span><br>    &#125;<br>&#125;<br>...<br><br></code></pre></td></tr></table></figure>
<p>然后在要使用Hilt的<code>module</code>的<code>build.gradle</code>中加入：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    ...<br>    id <span class="hljs-string">&#x27;kotlin-kapt&#x27;</span><br>    id <span class="hljs-string">&#x27;dagger.hilt.android.plugin&#x27;</span><br>&#125;<br><br>android &#123;<br>    ...<br>    compileOptions &#123;<br>        sourceCompatibility JavaVersion.VERSION_1_8<br>        targetCompatibility JavaVersion.VERSION_1_8<br>    &#125;<br>    ...<br>&#125;<br><br>dependencies &#123;<br>    ...<br>    implementation <span class="hljs-string">&quot;com.google.dagger:hilt-android:$hilt_version&quot;</span><br>    kapt <span class="hljs-string">&quot;com.google.dagger:hilt-android-compiler:$hilt_version&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h4><p>要使用Hilt，首先要对<code>Application</code>进行处理，使用<code>@HiltAndroidApp</code>去注解<code>Application</code>。这是必须要做的，使用这个注解后，Hilt才会去生成一系列的容器组件，这时候才能够使用Hilt。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// App.kt</span><br><span class="hljs-meta">@HiltAndroidApp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span>:<span class="hljs-type">Application</span>()<br></code></pre></td></tr></table></figure>


<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">// AndroidManifest.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.App&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="使用Hilt"><a href="#使用Hilt" class="headerlink" title="使用Hilt"></a>使用Hilt</h3><h4 id="Inject标记注入"><a href="#Inject标记注入" class="headerlink" title="@Inject标记注入"></a>@Inject标记注入</h4><p>Hilt的注入是通过注解来进行标识的，要注入的对象使用<code>@Inject</code>注解即可。同样的，要注入的对象的构造方法也要使用<code>@Inject</code>注解，如下例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Person.kt</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Hello&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// MainActivity.kt</span><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> person: Person<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        person.say()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>MainActivity</code>中并没有直接给<code>person</code>赋值，而是使用了<code>@Inject</code>进行注解，然后就直接使用了，这是因为Hilt在背后给这个字段去初始化赋值了。为了能够让Hilt去生成一个Person对象进行注入，我们还要给Person的构造方法上也加上<code>@Inject</code>，这样就完成了一个最简单的依赖注入了。</p>
<h4 id="AndroidEntryPoint注入的入口点"><a href="#AndroidEntryPoint注入的入口点" class="headerlink" title="@AndroidEntryPoint注入的入口点"></a>@AndroidEntryPoint注入的入口点</h4><p>还有一点就是在<code>MainActivity</code>上还使用了<code>@AndroidEntryPoint</code>，这个注解表示当前的<code>Activity</code>是一个注入的入口点，可以进行注入。Hilt并不是在哪都能进行注入的，而是有着特定的入口点，并且入口点必须得通过<code>@AndroidEntryPoint</code>注释。其中入口点有<strong>6</strong>个，<code>Application，Activity，Fragment，View，Service，BroadcastReceiver</code>。但是<code>Application</code>这个入口点不用使用<code>@AndroidEntryPoint</code>注解，因为它已经有了<code>@HiltAndroidApp</code>，所以可以直接注入。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// App.kt</span><br><span class="hljs-meta">@HiltAndroidApp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span>:<span class="hljs-type">Application</span>() &#123;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> person: Person<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate()<br>        person.say()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这几个入口点中，<code>View</code>和<code>Fragment</code>有些特殊，其他的入口点只要注解为<code>@AndroidEntryPoint</code>后，即可在其中进行Hilt的注入。但是对于Fragment而言，若是想在Fragment中使用Hilt的注入，除了在Fragment上使用@AndroidEntryPoint外，<strong>还要在其宿主Activity上也加上这个注解</strong>才行。而对于View而言，若是在View中使用Hilt的注入，首先在View上使用@AndroidEntryPoint，然后<strong>若是View用在Activity上，则Activity上也要加该注解。若是View用在Fragment上，则Fragment和Fragment的宿主Activity都要加上这个注解</strong>。</p>
<p>可以看到Hilt的使用是比较简单的，首先将类的构造方法使用<code>@Inject</code>注解，这表明该类可以被Hilt自动创建并注入到相应的地方，然后就是在入口点中使用@Inject进行注入即可。</p>
<h4 id="HiltViewModel-注入ViewModel"><a href="#HiltViewModel-注入ViewModel" class="headerlink" title="@HiltViewModel 注入ViewModel"></a>@HiltViewModel 注入ViewModel</h4><p><code>ViewModel</code>的注入和普通对象一样，首先给构造方法加@Inject，但是比普通对象多出来的是还要在它上面加入<code>@HiltViewModel</code>。并且注入的地方<strong>不能使用@Inject</strong>，而是和普通的使用ViewModel保持一致，使用<code>ViewModelProvider</code>去获取ViewModel。</p>
<p>注意这里不能使用@Inject去注入ViewModel，否则获取到的ViewModel只是一个普通对象，它在Activity销毁的时候也会被回收，而无法做到如ViewModel那样的在配置改变的时候依旧保存下来。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MainAcitivity.kt</span><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> viewModel: ViewModel<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        viewModel = ViewModelProvider(<span class="hljs-keyword">this</span>)[MyViewModel::<span class="hljs-keyword">class</span>.java]<br>        println(viewModel)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// MyViewModel.kt</span><br><span class="hljs-meta">@HiltViewModel</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() : ViewModel()<br></code></pre></td></tr></table></figure>

<p>如是嫌弃<code>ViewModelProvider</code>方式获取的太麻烦，则可以使用<code>Activity-ktx</code>的获取方式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// build.gradle中加入依赖</span><br>implementation <span class="hljs-string">&#x27;androidx.activity:activity-ktx:1.2.3&#x27;</span><br><br><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span>  viewModel:MyViewModel <span class="hljs-keyword">by</span> viewModels()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 若是想要在Fragment中也这样使用，需要加入Fragment-ktx的依赖：</span><br>implementation <span class="hljs-string">&#x27;androidx.fragment:fragment-ktx:1.3.4&#x27;</span><br></code></pre></td></tr></table></figure>



<p>对于无法在构造方法上加<code>@Inject</code>的类如系统类三方库中的类等，是不能直接进行注入的，要通过安装模块的方式去添加依赖。</p>
<h4 id="Module-InstallIn-声明一个模块"><a href="#Module-InstallIn-声明一个模块" class="headerlink" title="@Module @InstallIn 声明一个模块"></a>@Module @InstallIn 声明一个模块</h4><p>模块也就是<code>Module</code>，是一个类文件，它包含了很多的方法，这些方法就是用来提供注入对象的。</p>
<p>模块必须使用@Module来进行注解，说明当前类是一个Hilt模块，可以用来提供依赖。并且同时还要使用<code>@InstallIn</code>注解，该注解接收一个数组类型的参数，表示安装在哪个组件上。</p>
<p>组件代表着一个作用范围，安装在该组件上的模块所提供的依赖方法，只能在当前组件范围内才能进行注入。而且不同的组件对应着不同的生命周期，安装在它上面的模块只会在其生命周期内存在。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// NetModule.kt</span><br><span class="hljs-meta">@InstallIn(SingletonComponent::class)</span><br><span class="hljs-meta">@Module</span><br><span class="hljs-keyword">object</span> NetModule &#123;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideRetrofit</span><span class="hljs-params">()</span></span>: Retrofit &#123;<br>        <span class="hljs-keyword">return</span> Retrofit.Builder()<br>            .baseUrl(<span class="hljs-string">&quot;https://xxxx.com/&quot;</span>)<br>            .build()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上例，就是声明了一个<code>NetModule</code>模块，用来提供<code>Retrofit</code>的依赖，并且安装在<code>SingletonComponent</code>组件上，<code>SingletonComponent</code>组件的作用范围是全局，因此在所有的地方都能使用该模块所提供依赖注入，也就是对Retrofit的注入。</p>
<p>在这个模块中，有个<code>@Provide</code>标注的方法，该注解表明这个方法是是用来提供依赖的。注意它的返回值是Retrofit，表明需要注入Retrofit实例的时候，就会通过这个方法去生成一个实例对象进行注入。在Module中，Module的类名，方法名都是随意定的，Hilt只关心返回值。下面就是可以直接在Activity中注入Retrofit了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MainActivity.kt</span><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> retrofit: Retrofit<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        println(retrofit.hashCode())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="组件Component"><a href="#组件Component" class="headerlink" title="组件Component"></a>组件Component</h4><p>当声明一个module的时候，必须要安装在组件上，这代表当前module可以给哪些类进行注入。在Hilt中，一共有<strong>八</strong>种组件，下面将逐一介绍组件的生命周期和作用范围。</p>
<h5 id="SingletonComponent"><a href="#SingletonComponent" class="headerlink" title="SingletonComponent"></a>SingletonComponent</h5><p><code>SingletonComponent</code>是针对<code>Application</code>的组件，安装在它上面的module会与Application的生命周期保持一致，在<code>Application#onCreate</code>的时候创建，在<code>Application#onDestroy</code>的时候销毁。并且该module所提供的依赖，<strong>在整个程序中都是可以使用的。</strong></p>
<p>下面声明了两个模块，都是安装在<code>SingletonComponent</code>上的，但是一个是普通类，一个是单例类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(SingletonComponent::class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalModule</span> &#123;...&#125;<br><br><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(SingletonComponent::class)</span><br><span class="hljs-keyword">object</span> SingletonModule &#123;...&#125;<br></code></pre></td></tr></table></figure>

<p>这两种类型的模块有什么区别呢？使用<code>class</code>关键字的类是一个普通对象，因此会存在创建和销毁。它存在的范围也就是前面所说的组件的生命周期。例如在<code>SingletonSomponent</code>组件上，会在<code>Application#onCreate</code>的时候去<code>new</code>出一个<code>NormalModule</code>的实例对象，在<code>Application#onDestroy</code>的时候回收这个对象。</p>
<p>注意他是每个组件都会生成一个Module对象实例，例如若是这个module安装在<code>ActivityComponent</code>上的时候，会在每个<code>Activity#onCreate</code>的时候去创建一个module实例，也就是说，<em>每个Activity对应的module都是独立的对象</em>。</p>
<p>而使用<code>object</code>关键字的话，声明出来的module是一个<code>单例对象</code>，因此不会存在创建销毁过程。提供依赖的时候，用的都是同一个单例对象。</p>
<h5 id="ActivityRetainedComponent"><a href="#ActivityRetainedComponent" class="headerlink" title="ActivityRetainedComponent"></a>ActivityRetainedComponent</h5><p><code>ActivityRetainedComponent</code>是针对<code>Activity</code>的组件，因此它的生命周期是<code>Activity#onCreate</code>到<code>Activity#onDestroy</code>，但是它又比这个范围长一些。也就是当配置更改的时候，如旋转屏幕导致的Activity重建的时候，该组件并不会销毁，而是真正结束一个Activity的时候才会去销毁。简单来说就是生命周期与<code>ViewModel</code>是一致的。</p>
<p>安装在<code>ActivityRetainedComponent</code>组件上的module提供的依赖，<strong>可以在ViewModel中，Activity中，Fragment中，以及View中注入。</strong></p>
<h5 id="ActivityComponent"><a href="#ActivityComponent" class="headerlink" title="ActivityComponent"></a>ActivityComponent</h5><p><code>ActivityComponent</code>组件的生命周期也是与Activity一致，但是，它是跟<code>Activity</code>完全一致的。只要Activity销毁，对应的组件也会销毁。</p>
<p>安装在<code>ActivityComponent</code>上的module提供的依赖，<strong>可以在Activity中，Fragment中，以及View中注入</strong>。</p>
<h5 id="ViewModelComponent"><a href="#ViewModelComponent" class="headerlink" title="ViewModelComponent"></a>ViewModelComponent</h5><p><code>ViewModelComponent</code>组件和<code>ActivityRetainedComponent</code>是一样的，声明周期也是与<code>ViewModel</code>一致。唯一的区别是，安装在它上面的模块提供的依赖<strong>只能在ViewModel中使用</strong>。</p>
<h5 id="FragmentComponent"><a href="#FragmentComponent" class="headerlink" title="FragmentComponent"></a>FragmentComponent</h5><p><code>FragmentComponent</code>组件是针对于<code>Fragment</code>的，安装在它上面的组件在<code>Fragment#onAttach</code>的时候创建，在<code>Fragment#onDestroy</code>的时候销毁。</p>
<p>安装在它上面的module提供的依赖，<strong>只能在Fragment中注用</strong>。</p>
<h5 id="ViewComponent"><a href="#ViewComponent" class="headerlink" title="ViewComponent"></a>ViewComponent</h5><p><code>ViewComponent</code>组件是针对于<code>View</code>的，在<code>View创建的时候</code>创建，在<code>视图销毁</code>的时候销毁。并且安装在它上面的module提供的依赖<strong>只能在View中使用</strong>。</p>
<h5 id="ViewWithFragmentComponent"><a href="#ViewWithFragmentComponent" class="headerlink" title="ViewWithFragmentComponent"></a>ViewWithFragmentComponent</h5><p><code>ViewWithFragmentComponent</code>也是针对<code>View</code>的，但是注入的时候不仅要求在View上加入<code>@AndroidEntryPoint</code>，还要加上<code>@WithFragmentBindings</code>。安装在它上面的模块的生命周期也是与ViewComponent一样的。其中提供的依赖<strong>只能用在View上</strong>，<em>而且这个View还只能用在Fragment中，不能用在Activity中</em>。</p>
<h5 id="ServiceComponent"><a href="#ServiceComponent" class="headerlink" title="ServiceComponent"></a>ServiceComponent</h5><p><code>ServiceComponent</code>组件是针对<code>Service</code>的，依附于它的module在<code>Service#onCreate</code>的时候创建，在<code>Service#onDestroy</code>的时候销毁。并且安装在它上面的module<strong>只能用在Service中</strong>。</p>
<h5 id="七种组件的module生命周期以及使用范围，仅适用class关键字的module"><a href="#七种组件的module生命周期以及使用范围，仅适用class关键字的module" class="headerlink" title="七种组件的module生命周期以及使用范围，仅适用class关键字的module"></a>七种组件的module生命周期以及使用范围，仅适用class关键字的module</h5><table>
<thead>
<tr>
<th>组件</th>
<th>module创建</th>
<th>module销毁</th>
<th>可使用的入口点</th>
</tr>
</thead>
<tbody><tr>
<td>SingletonComponent</td>
<td>Application#onCreate</td>
<td>Application#onDestroy</td>
<td>全部</td>
</tr>
<tr>
<td>ActivityRetainedComponent</td>
<td>Activity#onCreate</td>
<td>Activity#onDestroy</td>
<td>ViewModel,Activity,Fragment,View</td>
</tr>
<tr>
<td>ActivityComponent</td>
<td>Activity#onCreate</td>
<td>Activity#onDestroy</td>
<td>Activity,Fragment,View</td>
</tr>
<tr>
<td>ViewModelComponent</td>
<td>Activity#onCreate</td>
<td>Activity#onDestroy</td>
<td>ViewModel</td>
</tr>
<tr>
<td>FragmentComponent</td>
<td>Fragment#onAttach</td>
<td>Fragment#onDestroy</td>
<td>Fragment</td>
</tr>
<tr>
<td>ViewComponent</td>
<td>View创建</td>
<td>View销毁</td>
<td>View</td>
</tr>
<tr>
<td>ViewWithFragmentComponent</td>
<td>View创建</td>
<td>View销毁</td>
<td>View</td>
</tr>
<tr>
<td>ServiceComponent</td>
<td>Service#onCreate</td>
<td>Service#onDestroy</td>
<td>Service</td>
</tr>
</tbody></table>
<p>作用范围很好理解，是用来缩小注入的范围，以避免滥用注入。那么生命周期又有什么用呢？比如在<code>MainActivity</code>中有三个<code>Fragment</code>，这三个Fragment想要共享一个对象<code>Person</code>，那么该怎么实现呢？</p>
<p>第一种方法是定义在Activity中，然后通过Fragment拿到Activity，进而拿到这个Person对象。第二个方法是将Person对象放到Activity的ViewModel中，然后在Fragment中也去获取这个ViewModel，进而拿到Person对象。</p>
<p>最后一种方式就是利用Hilt生命周期的特性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareModule</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> person = Person()<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">providePerson</span><span class="hljs-params">()</span></span>: Person &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.person<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先我们知道，<code>ActivityComponent</code>上的module的在<code>Activity#onCreate</code>的时候创建，在<code>Activity#onDestroy</code>的时候销毁。因此它是与Activity对应的，而这个module提供的依赖是<code>ShareModule</code>中的内部对象。因此，只要Activity没有销毁，这个module也就是同一个对象，进而注入的依赖person也都是同一个对象，从而实现Fragment共享同一个对象。这时候只要在Fragment中这样使用就行了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> : <span class="hljs-type">Fragment</span>()&#123;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> person: Person<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h6><p>除了使用上述的方式可以实现在Activity的生命周期内共享某个依赖对象外，Hilt还提供了一个作用域的概念。在某个作用域内，提供的依赖对象也是唯一的，将上例中的ShareModule改造一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> ShareModule &#123;<br><br>    <span class="hljs-meta">@ActivityScoped</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">providePerson</span><span class="hljs-params">()</span></span>: Person &#123;<br>        <span class="hljs-keyword">return</span> Person()<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>改造后的module也能实现和前面那样的效果，在Activity的生命周期内提供相同的<code>Person</code>对象。而只是简单的加了一个<code>@ActivityScoped</code>注解，这样，在Activity的生命周期范围内，拿到的依赖对象仍然是同一个，即使将module类使用<code>object</code>关键字声明成了单例类。</p>
<p>可以看到，使用作用域注解可以实现基于组件生命周期内提供单一对象的功能，这样的话，就可以直接将module定义为单例类就行了，若是<code>java</code>中的话定义成静态方法即可，这样可以用来避免频繁创建对象导致的开销。</p>
<p>另外注意一点就是，作用域注解必须与组件注解保持一致，比如在<code>ActivityComponent</code>只能使用<code>ActivityScoped</code>作用域，作用域注解的提供依赖的方法，在组件的生命周期内提供的是同一个依赖对象。</p>
<p>作用域注解不只是在module中使用，直接在类上面加上也是可以的，使用下面的代码也可以实现上述的效果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ActivityScoped</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() &#123;...&#125;<br></code></pre></td></tr></table></figure>

<h6 id="对应Component的作用域"><a href="#对应Component的作用域" class="headerlink" title="对应Component的作用域"></a>对应Component的作用域</h6><table>
<thead>
<tr>
<th>组件</th>
<th>生命周期</th>
<th>生命周期</th>
<th>作用域</th>
</tr>
</thead>
<tbody><tr>
<td>SingletonComponent</td>
<td>Application#onCreate</td>
<td>Application#onDestroy</td>
<td>Singleton</td>
</tr>
<tr>
<td>ActivityRetainedComponent</td>
<td>Activity#onCreate</td>
<td>Activity#onDestroy</td>
<td>ActivityRetainedScope</td>
</tr>
<tr>
<td>ActivityComponent</td>
<td>Activity#onCreate</td>
<td>Activity#onDestroy</td>
<td>ActivityScoped</td>
</tr>
<tr>
<td>ViewModelComponent</td>
<td>Activity#onCreate</td>
<td>Activity#onDestroy</td>
<td>ViewModelScoped</td>
</tr>
<tr>
<td>FragmentComponent</td>
<td>Fragment#onAttach</td>
<td>Fragment#onDestroy</td>
<td>FragmentScoped</td>
</tr>
<tr>
<td>ViewComponent</td>
<td>View创建</td>
<td>View销毁</td>
<td>ViewScoped</td>
</tr>
<tr>
<td>ViewWithFragmentComponent</td>
<td>View创建</td>
<td>View销毁</td>
<td>ViewScoped</td>
</tr>
<tr>
<td>ServiceComponent</td>
<td>Service#onCreate</td>
<td>Service#onDestroy</td>
<td>ServiceScoped</td>
</tr>
</tbody></table>
<p>在定义模块的时候，使用<code>@InstallIn</code>可以限定当前模块安装在哪个组件上。其中<code>@InstallIn</code>的参数是个数组，也就是说，我们可以将这个模块安装在多个组件上。使用多个组件可以将作用范围进行扩大，比如使用<code>FragmentComponent</code>和<code>ServiceComponent</code>，就可以使模块中的依赖在<code>Fragment</code>和<code>Service</code>中使用了。但是，使用了多组件的话，因为组件的生命周期和作用范围不同，因此是<strong>不能声明作用域注解的</strong>。</p>
<p>当然若是两个组件的生命周期是一样的，比如<code>ViewComponent</code>和<code>ViewWithFragmentComponent</code>，则还是可以使用作用域注解<code>@ViewScoped</code>的，但是这没有什么意义，因为<code>ViewComonent</code>的范围是包含了<code>Fragment</code>的。</p>
<h5 id="Provide和-Binds"><a href="#Provide和-Binds" class="headerlink" title="@Provide和@Binds"></a>@Provide和@Binds</h5><p><code>@Provide</code>前面有说过了，是在Module中用来修饰方法的，被它修饰的方法代表着提供依赖的方法，当需要该类型的依赖对象时，就会调用对应返回值的方法去注入依赖。</p>
<p>在Module中，类名和方法名都是没有意义的，可以随便起名(当然为了可读性还是不要随便起名)，至于提供什么依赖完全看函数的返回值类型。若是返回值类型是一个接口呢？。</p>
<p>举个例子，比如有个接口<code>Human</code>，两个子类<code>Man和Woman</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sex</span><span class="hljs-params">()</span></span>: String<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() : Human &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sex</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;男&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>() : Human &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sex</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;女&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>若是想要在Activity中注入该怎么处理呢，简单，构造方法已经加入注解了，然后直接注入即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> man: Man<br><br>    <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> woman: Woman<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        println(<span class="hljs-string">&quot;Man:<span class="hljs-subst">$&#123;man.sex()&#125;</span>, Woman: <span class="hljs-subst">$&#123;woman.sex()&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那我要是想要在Activity中注入Human而不是具体的子类型，该怎么办呢？首先我们知道，Hilt注入的时候是根据类型来查找依赖关系的。顺序是先从当前组件上的Module上查找返回值类型为这个类型的方法，找不到后再去看这个类型的类上的构造方法上是否有<code>@Inject</code>注解，有的话就直接生成一个对象注入了。</p>
<p>而若是注入类型为Human的，因为Human是个接口，是没有构造方法的，因此也是没法去@Inejct的。因此，若是想注入一个接口类型，必须要为它提供一个module。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> HumanModule &#123;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">()</span></span>:Human &#123;<br>        <span class="hljs-keyword">return</span> Man()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>给<code>ActivityComponent</code>上安装这个Module后，就可以在<code>Activity</code>中使用<code>Human</code>注入了。另外这里注意一点，<em>Module一般是用来提供不可以直接注入的对象</em>，也就是三方库系统类那样的无法在构造方法添加<code>@Inject</code>的类，对于我们自己的类，如上面的<code>Man</code>对象，则不要在<code>provideMan</code>方法中直接去<code>new</code>一个对象，而是应该使用注入的方式，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> HumanModule &#123;<br>    <br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">(man:<span class="hljs-type">Man</span>)</span></span>:Human &#123;<br>        <span class="hljs-comment">// 方法参数中的参数，会被Hilt直接注入</span><br>        <span class="hljs-comment">// 所以若是提供依赖的方法含有参数的话，参数必须是能够被注入的，否则会报错</span><br>        <span class="hljs-keyword">return</span> man<br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> man: Human<br><br>    <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> woman: Human<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        println(<span class="hljs-string">&quot;Man:<span class="hljs-subst">$&#123;man.sex()&#125;</span>, Woman: <span class="hljs-subst">$&#123;woman.sex()&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，在Activity中虽然可以注入Human了，但是注入的两个对象man和woman实际类型都是<code>Man</code>。若是想要它们不一样该怎么处理呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> HumanModule &#123;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">(man:<span class="hljs-type">Man</span>)</span></span>:Human &#123;<br>        <span class="hljs-keyword">return</span> man<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideWoman</span><span class="hljs-params">(woman: <span class="hljs-type">Woman</span>)</span></span>:Human &#123;<br>        <span class="hljs-keyword">return</span> woman<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如上面的这个代码，直接再加一个方法，提供Woman对象，这样可以吗？当然是不行的，Hilt是根据返回值类型来选择使用哪个方法去生成依赖对象的。这两个方法的返回值都是Human，会导致注入的时候不知道该用哪个，因此这样写在编译的时候就会直接报错了。</p>
<h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="Qualifier"></a>Qualifier</h5><p><code>@Qualifier</code>就是用来解决上述问题的，当moudle中的两个或多个方法返回的类型是同样的时候，就代表着有了依赖冲突，肯定是编译不过的。因此就需要解决冲突，而解决冲突的方式就是给它们添加限定符，这样就可以将它们区分开了。<br>注意注入的时候也要加上限定符：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义两个注解，这两个注解用@Qualifier注解，代表着两种限定符</span><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManType</span><br><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WomanType</span><br><br><span class="hljs-comment">// 给module中重复的类型添加限定符</span><br><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> HumanModule &#123;<br>    <span class="hljs-meta">@ManType</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">(man:<span class="hljs-type">Man</span>)</span></span>:Human &#123;<br>        <span class="hljs-keyword">return</span> man<br>    &#125;<br><br>    <span class="hljs-meta">@WomanType</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideWoman</span><span class="hljs-params">(woman: <span class="hljs-type">Woman</span>)</span></span>:Human &#123;<br>        <span class="hljs-keyword">return</span> woman<br>    &#125;    <br>&#125;<br><br><span class="hljs-comment">// 使用的时候也要加上限定符</span><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-meta">@ManType</span><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> man: Human<br><br>    <span class="hljs-meta">@WomanType</span><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> woman: Human<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到上例中，有两个方法返回的都是Human，但是通过<code>ManType</code>和<code>WomanType</code>注解进行了区分，在Activity中注入的时候也是要进行区分的，否则仍然会导致编译失败。若是在注入的时候不想使用<code>Qualifier</code>，那么可以在Module中再增加一个方法，不加以任何修饰，这样就可以使用默认的了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">object</span> HumanModule &#123;<br>    <span class="hljs-meta">@ManType</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">(man: <span class="hljs-type">Man</span>)</span></span>: Human &#123;<br>        <span class="hljs-keyword">return</span> man<br>    &#125;<br><br>    <span class="hljs-meta">@WomanType</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideWoman</span><span class="hljs-params">(woman: <span class="hljs-type">Woman</span>)</span></span>: Human &#123;<br>        <span class="hljs-keyword">return</span> woman<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDefault</span><span class="hljs-params">(man: <span class="hljs-type">Man</span>)</span></span>: Human &#123;<br>        <span class="hljs-keyword">return</span> man<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在Activity中的这三种注入，分别对应上面module中的方法</span><br><span class="hljs-meta">@AndroidEntryPoint</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-meta">@ManType</span><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> man: Human <span class="hljs-comment">// Man类型，provideMan方法提供</span><br><br>    <span class="hljs-meta">@WomanType</span><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> woman: Human <span class="hljs-comment">// Woman类型，provideWoman方法提供</span><br><br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> default: Human <span class="hljs-comment">// Man类型，provideDefault方法提供</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述就是<code>Qualifier</code>方法的使用情景，从开始到现在我们都是在module中使用<code>@Provides</code>去提供依赖，实际上还可以通过<code>@Binds</code>去提供依赖，这里改一下module：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(ActivityComponent::class)</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HumanModule</span> &#123;<br>    <span class="hljs-meta">@ManType</span><br>    <span class="hljs-meta">@Binds</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideMan</span><span class="hljs-params">(man: <span class="hljs-type">Man</span>)</span></span>: Human<br><br>    <span class="hljs-meta">@WomanType</span><br>    <span class="hljs-meta">@Binds</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideWoman</span><span class="hljs-params">(woman: <span class="hljs-type">Woman</span>)</span></span>: Human<br><br>    <span class="hljs-meta">@Binds</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDefault</span><span class="hljs-params">(man: <span class="hljs-type">Man</span>)</span></span>: Human<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到和使用<code>Provides</code>的区别就是：module必须是一个<code>抽象类</code>，<code>@Provides</code>换成了<code>@Binds</code>，提供依赖的方法必须是一个<code>抽象方法</code>，这个抽象方法<code>只能有一个参数</code>，<code>必须有返回值</code>。这里注意的是提供依赖的方法是个抽象方法，返回值类型是提供的依赖类型，而参数就是实际返回的依赖对象。因此，<code>@Binds</code>仅适用于返回父类型的情况，所以抽象方法的返回值类型必须是参数的父类型。</p>
<p>相同类型的话仍然是通过<code>Qualifier</code>去进行区分的，所以<code>@Provides</code>方式的<code>module</code>是可以完全取代<code>@Binds</code>方式的。</p>
<p>这里举例是用接口举例的，实际上对于不是接口的也是可以的，甚至是同一个对象也是没问题的。因为Hilt会将限定符和返回值作为一组判定，只要不发生重复即可，所以返回值是接口还是父类都无关紧要的，如下这样也是可以的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-meta">@InstallIn(SingletonComponent::class)</span><br><span class="hljs-keyword">object</span> NetModule &#123;<br>    <br>    <span class="hljs-meta">@MyRelease</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideRelease</span><span class="hljs-params">()</span></span>:Retrofit &#123;<br>        <span class="hljs-keyword">return</span> Retrofit.Builder()<br>            .baseUrl(<span class="hljs-string">&quot;http://www.xxx.com/&quot;</span>)<br>            .build()<br>    &#125;<br>    <br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideTest</span><span class="hljs-params">()</span></span> :Retrofit &#123;<br>        <span class="hljs-keyword">return</span> Retrofit.Builder()<br>            .baseUrl(<span class="hljs-string">&quot;http://test.com/&quot;</span>)<br>            .build()<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRelease</span><br></code></pre></td></tr></table></figure>



<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其他默认提供的依赖，常用的一个<code>Application</code>，两种<code>Activity</code>，两种<code>Context</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Application，实际类型是我们自定义的App</span><br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mApp:Application<br><br><span class="hljs-comment">// 在同一个Activity种，这种两注解拿到的都是同一个对象</span><br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> activity:Activity<br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> fragmentActivity: FragmentActivity<br><br><span class="hljs-comment">// 这是Application对应的Context，使用限定符@ApplicationContext区分</span><br><span class="hljs-meta">@ApplicationContext</span><br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mAppContext: Context<br><br><span class="hljs-comment">// 这是Activity对应的Context，使用限定符@ActivityContext区分</span><br><span class="hljs-meta">@ActivityContext</span><br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mContext: Context<br></code></pre></td></tr></table></figure>

<p>可以看到，Hilt的入口点和组件息息相关。而除了这些入口点外，还能自定义入口点，但是意义不大，因为Hilt定义的入口点基本已经覆盖了Android中比较重要的东西了。所以自定义入口点意义不大。</p>
<h2 id="附页"><a href="#附页" class="headerlink" title="附页"></a>附页</h2><h4 id="为什么Hilt可以用原生的方式去创建ViewModel"><a href="#为什么Hilt可以用原生的方式去创建ViewModel" class="headerlink" title="为什么Hilt可以用原生的方式去创建ViewModel"></a>为什么Hilt可以用原生的方式去创建ViewModel</h4><p>Hilt对于<code>ViewModel</code>的创建方式和原生的创建方式是一致的，唯一的差别就是Hilt中在<code>ViewModel</code>加入了<code>@HiltViewModel</code>和<code>@Inject</code>两个注解。</p>
<p>原生有以下两种方式创建：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 方式一，使用activity-ktx提供的委托机制（还有fragment-ktx）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel <span class="hljs-keyword">by</span> viewModels&lt;MyViewModel&gt;()<br>    <br><span class="hljs-comment">// 方式二，使用最基本的获取方式</span><br>viewModel = ViewModelProvider(<span class="hljs-keyword">this</span>)[MyViewModel::<span class="hljs-keyword">class</span>.java]<br></code></pre></td></tr></table></figure>

<p>其实这两种方式实际都是一样的原理，都是通过<code>getDefaultViewModelProviderFactory()</code>方法去创建一个<code>ViewModelProvider.Factory</code>，然后由这个<code>Factory</code>去创建<code>ViewModel</code>。</p>
<p>所以，若是想要像正常那样创建<code>ViewModel</code>，则必须要重写<code>getDefaultViewModelProviderFactory</code>方法。实际上，编译时Hilt会根据注解去对于使用<code>@AndroidEnterPointer</code>注解的入口点类生成一个父类，然后通过字节码插桩方式去将该类的父类改为Hilt生成的类。这里这个类就是<code>Hilt_MainActivity</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hilt_MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GeneratedComponentManagerHolder</span> &#123;<br>  ...<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ViewModelProvider.Factory <span class="hljs-title function_">getDefaultViewModelProviderFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> DefaultViewModelFactories.getActivityFactory(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">super</span>.getDefaultViewModelProviderFactory());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而在<code>Hilt_MainActivity</code>中也能看到，它确实重写了<code>getDefaultViewModelProviderFactory</code>。</p>
<p>注意第二个参数是<code>super.getDefaultViewModelProviderFactory</code>，这是原本的Factory。沿着<code>getActivityFactory</code>继续追踪下去，最终会走到<code>HiltViewModelFactory</code>中去，这个类也是Factory的实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HiltViewModelFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ViewModelProvider</span>.Factory &#123;<br>  ...<br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ViewModel</span>&gt; T <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;<br>    <span class="hljs-keyword">if</span> (hiltViewModelKeys.contains(modelClass.getName())) &#123;<br>      <span class="hljs-keyword">return</span> hiltViewModelFactory.create(modelClass);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> delegateFactory.create(modelClass);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>只看我们关注的部分，也就是Factory接口的实现方法<code>create</code>。从中也可以看出，当<code>hiltViewModelKeys</code>中包含当前要创建的<code>ViewModel</code>的类名的时候，使用<code>hiltViewModelFactory</code>去创建，否则使用<code>delegateFactory</code>去创建。</p>
<p>其中<code>delegateFactory</code>就是前面说的那个<code>super.getDefaultViewModelProviderFactory</code>，也就是原本的Factory。当<code>ViewModel</code>加了<code>@HiltViewModel</code>注解后，Hilt就会为它生成一个名字叫做<code>原类名_HiltModules</code>的类，并且有个静态的<code>provide</code>方法，该方法返回<code>ViewModel</code>的完整类名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel_HiltModules</span> &#123;<br>    ...<br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-meta">@IntoSet</span><br>    <span class="hljs-meta">@HiltViewModelMap</span>.KeySet<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">provide</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;com.example.myapplication.MyViewModel&quot;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而前面<code>HiltViewModelFactory</code>中的<code>hiltViewModelKeys</code>就是调用每个<code>xxx_HiltModules#provide</code>方法形成的Set集合。所以到这里就很清晰了：</p>
<ul>
<li><p>若是<code>ViewModel</code>使用了<code>@HiltViewModel</code>注解，就会使用<code>hiltViewModelFactory</code>去创建实例。</p>
</li>
<li><p>若是没有使用，则使用<code>delegateFactory</code>(也就是默认的Factory)去创建实例。</p>
<br/></li>
</ul>
<p><strong>所以，<code>ViewModel</code>上是否使用<code>@HiltViewModel</code>都是能正常运行的。但是：</strong></p>
<ul>
<li><p>&lt;不使用注解&gt; 默认的Factory只能创建<strong>空参构造方法</strong>的<code>ViewModel</code>。</p>
</li>
<li><p>&lt;使用注解&gt;   Hilt的Factory可以创建<strong>带参数构造方法</strong>的<code>ViewModel</code>，当然参数必须也是可以进行注入的。</p>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:penggaofeng1@163.com">Rmfone</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2021/06/06/%E5%A5%BD%E7%94%A8%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6-Hilt/">https://pgaofeng.github.io/2021/06/06/好用的依赖注入框架-Hilt/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">其他声明：</span><span class="p-copytight-value">本站所有文章均可随意转载，但请注明出处，文章原稿：<a target="_blank" rel="noopener" href="https://github.com/pgaofeng/NoteBook/tree/main/source/_posts">点击跳转Github</a></span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tags"></i><a href="/tags/%E4%B8%89%E6%96%B9%E5%BA%93/">三方库</a><a href="/tags/Jetpack/">Jetpack</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">为什么使用依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0Hilt%E4%BE%9D%E8%B5%96"><span class="toc-number">1.1.</span> <span class="toc-text">添加Hilt依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">前置工作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Hilt"><span class="toc-number">2.</span> <span class="toc-text">使用Hilt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Inject%E6%A0%87%E8%AE%B0%E6%B3%A8%E5%85%A5"><span class="toc-number">2.1.</span> <span class="toc-text">@Inject标记注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AndroidEntryPoint%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">@AndroidEntryPoint注入的入口点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HiltViewModel-%E6%B3%A8%E5%85%A5ViewModel"><span class="toc-number">2.3.</span> <span class="toc-text">@HiltViewModel 注入ViewModel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Module-InstallIn-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"><span class="toc-number">2.4.</span> <span class="toc-text">@Module @InstallIn 声明一个模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6Component"><span class="toc-number">2.5.</span> <span class="toc-text">组件Component</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SingletonComponent"><span class="toc-number">2.5.1.</span> <span class="toc-text">SingletonComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ActivityRetainedComponent"><span class="toc-number">2.5.2.</span> <span class="toc-text">ActivityRetainedComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ActivityComponent"><span class="toc-number">2.5.3.</span> <span class="toc-text">ActivityComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ViewModelComponent"><span class="toc-number">2.5.4.</span> <span class="toc-text">ViewModelComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FragmentComponent"><span class="toc-number">2.5.5.</span> <span class="toc-text">FragmentComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ViewComponent"><span class="toc-number">2.5.6.</span> <span class="toc-text">ViewComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ViewWithFragmentComponent"><span class="toc-number">2.5.7.</span> <span class="toc-text">ViewWithFragmentComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ServiceComponent"><span class="toc-number">2.5.8.</span> <span class="toc-text">ServiceComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%83%E7%A7%8D%E7%BB%84%E4%BB%B6%E7%9A%84module%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BB%85%E9%80%82%E7%94%A8class%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84module"><span class="toc-number">2.5.9.</span> <span class="toc-text">七种组件的module生命周期以及使用范围，仅适用class关键字的module</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.5.9.1.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94Component%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.5.9.2.</span> <span class="toc-text">对应Component的作用域</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Provide%E5%92%8C-Binds"><span class="toc-number">2.5.10.</span> <span class="toc-text">@Provide和@Binds</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Qualifier"><span class="toc-number">2.5.11.</span> <span class="toc-text">Qualifier</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.6.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E9%A1%B5"><span class="toc-number"></span> <span class="toc-text">附页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Hilt%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8E%BB%E5%88%9B%E5%BB%BAViewModel"><span class="toc-number">0.1.</span> <span class="toc-text">为什么Hilt可以用原生的方式去创建ViewModel</span></a></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2021/08/05/%E5%B0%86Room%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%A1%9E%E5%88%B0%E8%84%91%E5%AD%90%E9%87%8C/">&lt; 将Room的使用方式塞到脑子里</a></div></section><footer><p>最近更新：2024-01-14 12:41:13 | 本文作者：<a href="/." rel="nofollow">没有感情的代码机器</a><br> </p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>