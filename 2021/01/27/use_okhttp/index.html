<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>OkHttp3的简单使用</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>31</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>15</span> <span>标签</span> </a><a class="author-word-count"><span>12.16</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96" class="toc-link"><span class="toc-text">引入依赖</span></a></li><li class="toc-item toc-level-2"><a href="#%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82" class="toc-link"><span class="toc-text">简单的网络请求</span></a></li><li class="toc-item toc-level-2"><a href="#OkHttpClient" class="toc-link"><span class="toc-text">OkHttpClient</span></a></li><li class="toc-item toc-level-2"><a href="#Request" class="toc-link"><span class="toc-text">Request</span></a></li><li class="toc-item toc-level-2"><a href="#Call" class="toc-link"><span class="toc-text">Call</span></a></li><li class="toc-item toc-level-2"><a href="#Response" class="toc-link"><span class="toc-text">Response</span></a></li><li class="toc-item toc-level-2"><a href="#Interceptor" class="toc-link"><span class="toc-text">Interceptor</span></a></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">9</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="OkHttp3的简单使用 thumbnail" class="image lozad" src="/img/cover/cover-okhttp.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">OkHttp3的简单使用</h1></header><div class="post-meta post-show-meta"><time datetime="2021-01-27T13:15:58.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2021-01-27</span> </time><span class="dot"></span> <a href="/categories/Third-Libraries/" class="post-meta-link">Third Libraries </a><span class="dot"></span> <span>约1.9k 字</span></div><div class="post-content" id="section"><p><code>OkHttp</code>是目前最流行的网络请求框架，几乎现在的<code>Android</code>开发中都是使用<code>OkHttp</code>来进行网络请求的，搭配<code>Retrofit</code>使用的话更方便了。本篇文章即是记录<code>OkHttp</code>的一些基本使用方式，方便以后回忆和查询。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 统一管理OkHttp版本</span><br>implementation(platform(<span class="hljs-string">&quot;com.squareup.okhttp3:okhttp-bom:4.12.0&quot;</span>))<br><span class="hljs-comment">// OkHttp</span><br>implementation(<span class="hljs-string">&quot;com.squareup.okhttp3:okhttp&quot;</span>)<br><span class="hljs-comment">// log打印，方便查看网络请求的内容</span><br>implementation(<span class="hljs-string">&quot;com.squareup.okhttp3:logging-interceptor&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里同时引入了<code>OkHttp</code>和<code>Logging</code>库，因此使用了<code>okhttp-bom</code>去统一管理依赖版本。正常情况下只需要引入<code>implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)</code>即可。另外就是需要加上网络权限。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="简单的网络请求"><a href="#简单的网络请求" class="headerlink" title="简单的网络请求"></a>简单的网络请求</h2><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> request = Request.Builder()<br>        .url(<span class="hljs-string">&quot;https://www.wanandroid.com/banner/json&quot;</span>)<br>        .build()<br>    thread &#123;<br>        <span class="hljs-keyword">val</span> client = OkHttpClient()<br>        <span class="hljs-keyword">val</span> call = client.newCall(request)<br>        <span class="hljs-keyword">val</span> response = call.execute()<br>        Log.d(TAG, <span class="hljs-string">&quot;code = <span class="hljs-subst">$&#123;response.code&#125;</span>, message = <span class="hljs-subst">$&#123;response.body?.string()&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先创建一个<code>Request</code>对象，这是请求的主体，整个请求的参数以及方式等都是由<code>Request</code>去声明的。然后开了一个线程进行网络请求，因为<code>OkHttp</code>是禁止在主线程中进行同步方式的网络请求，因为请求过程是一个耗时操作，会阻塞主线程。然后就是创建了一个<code>OkHttpClient</code>，它是网络请求的一个工厂类转换类。请求的对象<code>Request</code>会被<code>OkHttpClient</code>转换成不同的<code>Call</code>的实现类，最终由Call以同步或者异步的方式来执行网络请求。</p><h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p>在上面的简单的网络请求实例中可以看到，<code>OkHttpClient</code>用来处理<code>Request</code>请求的。实际上它是一个通用的配置类，可以用来配置整个网络请求的属性。如缓存、连接池、线程池、<code>Cookie</code>等等，因此在开发中应该将其设计成单例的形式供各个功能模块进行调用。</p><p><code>OkHttpClient</code>采用了<code>Builder</code>模式设计，可以进行各种自定义的操作设置。实际上各种默认的设置已经能够满足大部分的需求了，需要自定义的部分反而不多，更多的是添加<code>Interceptor</code>。如我们上面的加的<code>Logging</code>的依赖即是一个拦截器，可以添加在<code>OkHttpClient</code>中用于请求参数的打印。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> mOkHttpClient = OkHttpClient.Builder()<br>    .addInterceptor(HttpLoggingInterceptor().also &#123; <br>        it.level = HttpLoggingInterceptor.Level.BODY <br>    &#125;)<br>.build()<br></code></pre></td></tr></table></figure><p>由于默认的<code>Logging</code>的<code>Level</code>是<code>NONE</code>，什么都不会输出，因此需要将其设置为其他可输出的级别，这里设置的是<code>BODY</code>级别，会输出所有的请求内容。</p><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><code>Request</code>是用来构建网络请求的，采用的Builder模式来构建一个请求，默认是<code>GET</code>的请求方式。对于常用的HTTP请求方法都是支持的，如<code>GET</code>、<code>POST</code>、<code>HEAD</code>、<code>PUT</code>等。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> request = Request.Builder()<br>    .url(<span class="hljs-string">&quot;https://www.wanandroid.com/banner/json&quot;</span>)<br>    .<span class="hljs-keyword">get</span>() <span class="hljs-comment">// 采用GET方式，默认方式。可以不用调用这个方法</span><br>    .build()<br></code></pre></td></tr></table></figure><p><code>GET</code>的请求方式比较简单，需要传递参数的话也是直接通过<code>url</code>中拼接参数。而<code>POST</code>通常不会在url中拼接参数，而是使用别的方式。对应在<code>Request</code>中，当选择<code>POST</code>方式时，必须传递一个非空的<code>RequestBody</code>参数用于存放请求参数。常用的如表单类型：则需要传递的是<code>FormBody</code>。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> request = Request.Builder()<br>    .url(<span class="hljs-string">&quot;https://www.wanandroid.com/user/login&quot;</span>)<br>    .post(<br>        FormBody.Builder()<br>            .add(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;rmfone&quot;</span>)<br>            .add(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;*****&quot;</span>)<br>            .build()<br>    )<br>    .build()<br></code></pre></td></tr></table></figure><p>简单表单格式，会在请求头中添加<code>Content-Type: application/x-www-form-urlencoded</code>。这种类型通常都是基础的字符串参数，如果想要传递文件等信息的话，则需要用到<code>MultipartBody</code>，可以支持各种参数类型。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> request = Request.Builder()<br>    .url(<span class="hljs-string">&quot;https://www.wanandroid.com/user/login&quot;</span>)<br>    .post(<br>        MultipartBody.Builder()<br>            .addPart(<br>                FormBody.Builder()<br>                    .add(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;rmfone&quot;</span>)<br>                    .add(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;*****&quot;</span>)<br>                    .build()<br>            )<br>            .addFormDataPart(<span class="hljs-string">&quot;2.jpg&quot;</span>, file.name, file.asRequestBody())<br>            .build()<br>    )<br>    .build()<br></code></pre></td></tr></table></figure><p><code>MultipartBody</code>实际产生的内容类型是混合类型，<code>Content-Type: multipart/mixed; boundary=d721ad8b-8e88-4fcf-b370-91b2a43aa50c</code>，会将请求内容分为多个部分，每个部分使用<code>boundary</code>的值来进行区分。上面的实例中，添加了一个表单类型的部分和一个文件内容的部分。至于其他的请求方式如<code>PUT</code>、<code>HEAD</code>等，与上面的也是一样的。</p><h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><p>Call是网络请求中的进一步实现，具体的实现是<code>RealCall</code>，最终的请求即是由Call发起的。它有两种请求方式，同步方式和异步方式。注意不要在主线程中调用同步方式的请求。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 同步方式，注意不要在主线程调用</span><br><span class="hljs-keyword">val</span> response = call.execute()<br><span class="hljs-comment">// 异步方式</span><br>call.enqueue(<span class="hljs-keyword">object</span> : Callback&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>, e: <span class="hljs-type">IOException</span>)</span></span> &#123;<br>        e.printStackTrace()<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>, response: <span class="hljs-type">Response</span>)</span></span> &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;code = <span class="hljs-subst">$&#123;response.code&#125;</span>, msg = <span class="hljs-subst">$&#123;response.body?.string()&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><code>Response</code>是网络请求的结果，可以通过<code>code</code>获取结果码来判断请求是否成功，然后通过<code>Response.body</code>获取到请求结果。正常来说直接通过<code>body.string()</code>即可获取到此次的请求结果。当然，如果是下载的话，则可以通过<code>body.byteStream()</code>获取到此次连接的数据流，然后通过读取<code>stream</code>来实现下载和计算进度。</p><h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><p>OkHttp的整体网络请求是使用的责任链模式实现的，主体是五大拦截器，逐渐细化对网络请求参数的拆解、封装、压缩、传输等。在此基础上，也允许我们添加自定义的拦截器去参与到网络请求的过程中。如前面引入的<code>HttpLoggingInterceptor</code>就是一个用于打印请求参数和结果的拦截器。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mOkHttpClient = OkHttpClient.Builder()<br>    .addInterceptor(HttpLoggingInterceptor().also &#123;<br>        it.level = HttpLoggingInterceptor.Level.BODY<br>    &#125;)<br>    .build()<br></code></pre></td></tr></table></figure><p>拦截器主要是在<code>OkHttpClient</code>构建的时候添加进去的，我们在正常使用的时候，传入自定义的<code>Interceptor</code>参数，然后在<code>intercept</code>方法中去处理自己的逻辑。如我们想在每次请求前和请求后打印出<code>HEAD</code>信息 ：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mOkHttpClient = OkHttpClient.Builder()<br>    .addInterceptor &#123; chain -&gt;<br>        <span class="hljs-comment">// 网络请求前</span><br>        <span class="hljs-keyword">val</span> request = chain.request()<br>        Log.d(TAG, <span class="hljs-string">&quot;before network: <span class="hljs-subst">$&#123;request.headers&#125;</span>&quot;</span>)<br>        <span class="hljs-comment">// 交给下一个拦截器处理，最终会实际请求</span><br>        <span class="hljs-keyword">val</span> response = chain.proceed(request)<br>        <span class="hljs-comment">//网络请求之后</span><br>        Log.d(TAG, <span class="hljs-string">&quot;after network: <span class="hljs-subst">$&#123;response.headers&#125;</span>&quot;</span>)<br>        response<br>    &#125;<br>    .build()<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网络请求无非是建立连接，发送请求，处理响应三个步骤。对于我们使用来说，只需要关注发送请求和处理响应即可。发送请求主要是构建<code>Request</code>，通过<code>Request</code>的构建时调用的不同方法去选择使用什么方式进行请求，以及参数的传入、<code>HEAD</code>的添加等。而像<code>Cookie</code>的添加，则是在构建<code>OkHttpClient</code>的时候传入的<code>CookieJar</code>来管理<code>Cookie</code>。每次请求的时候，都会根据<code>url</code>从<code>CookieJar</code>中取出对应的<code>Cookie</code>写入到请求头中，然后在收到响应后将响应头中的<code>Cookie</code>存储到<code>CookieJar</code>。</p><p>响应则更简单，主要是从<code>Response</code>中取出数据。可以从<code>Response</code>中获取到状态码来判断网络请求是否成功，最主要的是获取<code>body</code>信息，这是一次网络请求的主体，通常是使用<code>Json</code>格式的数据，然后我们将其序列化成对象进行使用即可，其余皆不需要关注。</p><p>由于<code>OkHttp</code>良好的封装和设计模式的应用，使得我们在使用的时候异常简单，几乎不需要什么学习成本即可完成网络请求。这么好的库不学习一番太过浪费了，后面将对<code>OkHttp</code>的源码进行分析，剖析它的设计之美。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Wed Jan 27 2021 21:15:58 GMT+0800");let n="Wed Jan 27 2021 21:15:58 GMT+0800";n="2024-07-29 21:39:01 +0800";var a=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-a)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Third-Libraries/" class="post-footer-category">#&nbsp;Third Libraries</a> <a href="/tags/OkHttp/" class="post-footer-tag">#&nbsp;OkHttp</a></div><div class="nav"><div class="nav-item-prev"><a href="/2021/02/20/use-okhttp-2/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">OkHttp3整体源码分析</div></div></a></div><div class="nav-item-next"></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96" class="toc-link"><span class="toc-text">引入依赖</span></a></li><li class="toc-item toc-level-2"><a href="#%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82" class="toc-link"><span class="toc-text">简单的网络请求</span></a></li><li class="toc-item toc-level-2"><a href="#OkHttpClient" class="toc-link"><span class="toc-text">OkHttpClient</span></a></li><li class="toc-item toc-level-2"><a href="#Request" class="toc-link"><span class="toc-text">Request</span></a></li><li class="toc-item toc-level-2"><a href="#Call" class="toc-link"><span class="toc-text">Call</span></a></li><li class="toc-item toc-level-2"><a href="#Response" class="toc-link"><span class="toc-text">Response</span></a></li><li class="toc-item toc-level-2"><a href="#Interceptor" class="toc-link"><span class="toc-text">Interceptor</span></a></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2021-02-20</div><a href="/2021/02/20/use-okhttp-2/"><div class="recent-posts-item-content">OkHttp3整体源码分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-10-05</div><a href="/2023/10/05/ffmpeg2/"><div class="recent-posts-item-content">FFmpeg解封装与重封装</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-09-06</div><a href="/2023/09/06/ffmpeg1/"><div class="recent-posts-item-content">FFmpeg编译so库文件</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-10-12</div><a href="/2021/10/12/bsdiff-translation/"><div class="recent-posts-item-content">【翻译】Naive Differences of Executable Code</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-10-05</div><a href="/2023/10/05/ffmpeg2/"><div class="recent-posts-item-content">FFmpeg解封装与重封装</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-09-06</div><a href="/2023/09/06/ffmpeg1/"><div class="recent-posts-item-content">FFmpeg编译so库文件</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-08-27</div><a href="/2023/08/27/overscroll/"><div class="recent-posts-item-content">View自定义回弹动效</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>