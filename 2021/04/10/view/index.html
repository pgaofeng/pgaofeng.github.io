<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>View的绘制流程</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>22</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>14</span> <span>标签</span> </a><a class="author-word-count"><span>9.88</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#View%E7%9A%84%E7%BB%98%E5%88%B6" class="toc-link"><span class="toc-text">View的绘制</span></a></li><li class="toc-item toc-level-3"><a href="#Measure" class="toc-link"><span class="toc-text">Measure</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#MeasureSpec" class="toc-link"><span class="toc-text">MeasureSpec</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#layout" class="toc-link"><span class="toc-text">layout</span></a></li><li class="toc-item toc-level-3"><a href="#draw" class="toc-link"><span class="toc-text">draw</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">3</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">5</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="View的绘制流程 thumbnail" class="image lozad" src="/img/cover/cover-view.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">View的绘制流程</h1></header><div class="post-meta post-show-meta"><time datetime="2021-04-10T11:20:31.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2021-04-10</span> </time><span class="dot"></span> <a href="/categories/Android-View/" class="post-meta-link">Android View </a><span class="dot"></span> <span>约5.5k 字</span></div><div class="post-content" id="section"><p><code>View</code>是我们在应用开发中用的最多的组件的，基本上所有的与界面相关的元素都是使用<code>View</code>呈现的。而<code>Android</code>为我们提供了很多的<code>View</code>供我们直接使用。如<code>LinearLayout</code>、<code>ImageView</code>等，当然我们也会根据自己的业务需求去自定义<code>View</code>，而在自定义的过程中，我们就会去在对应的绘制流程中做自定义操作。因此，了解<code>View</code>的绘制流程，对于我们自定义<code>View</code>来说是很有帮助的。</p><h3 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h3><p>界面布局分为<code>View</code>和<code>ViewGroup</code>，整个界面布局都是以<code>ViewGroup</code>为根节点的一个<code>View</code>树，这棵树的根节点也就是<code>DecorView</code>，最终被添加到<code>ViewRootImpl</code>中，这个过程是在<code>Activity#onResume</code>的时候添加进去的。所以，后续对于<code>View</code>树的管理，最终都是由<code>ViewRootImpl</code>直接触发的。</p><p>如<code>View</code>的绘制，直接的触发者就是<code>ViewRootImpl</code>，它会在需要刷新时，通过<code>preformTraversals</code>触发<code>View</code>的三个流程。这个方法非常长，大概有一千行，这里只关注对于<code>View</code>绘制的部分。</p><h3 id="Measure"><a href="#Measure" class="headerlink" title="Measure"></a>Measure</h3><p><code>measure</code>是<code>View</code>绘制的第一个流程，它主要的作用就是触发自己以及子<code>View</code>的测量，目的是计算出自己所需要占据的空间的大小。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// ViewRootImpl.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performTraversals</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (mFirst) &#123;<br>        <span class="hljs-comment">// 第一次需要进行布局</span><br>        mLayoutRequested = <span class="hljs-literal">true</span>;<br>        ...<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        desiredWindowWidth = frame.width();<br>        desiredWindowHeight = frame.height();<br>        <span class="hljs-comment">// 如果宽高发生了变化，需要重新布局</span><br>        <span class="hljs-keyword">if</span> (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;<br>            ...<br>            mLayoutRequested = <span class="hljs-literal">true</span>;<br>            windowSizeMayChange = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    ...<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">layoutRequested</span> <span class="hljs-operator">=</span> mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>    <span class="hljs-keyword">if</span> (layoutRequested) &#123;<br>        ...<br>        windowSizeMayChange |= measureHierarchy(host, lp, mView.getContext().getResources(),<br>                    desiredWindowWidth, desiredWindowHeight, shouldOptimizeMeasure);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>当触发<code>preformTraversals</code>的时候，并不是一定会触发布局的流程，而是会判断宽高是否发生了变化，只有发生了变化，才会去触发布局流程，最终也是通过<code>measureHierarchy</code>触发的。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// ViewRootImpl.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">measureHierarchy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> View host, <span class="hljs-keyword">final</span> WindowManager.LayoutParams lp,</span><br><span class="hljs-params">            <span class="hljs-keyword">final</span> Resources res, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> desiredWindowWidth, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> desiredWindowHeight,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> forRootSizeOnly)</span> &#123;<br>    <span class="hljs-type">int</span> childWidthMeasureSpec;<br>    <span class="hljs-type">int</span> childHeightMeasureSpec;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">windowSizeMayChange</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">goodMeasure</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 正常情况下lp.width的值为match_patent。这里通常对应的是dialog手动设置宽度为wrap_content</span><br>    <span class="hljs-keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">DisplayMetrics</span> <span class="hljs-variable">packageMetrics</span> <span class="hljs-operator">=</span> res.getDisplayMetrics();<br>        res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, <span class="hljs-literal">true</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">baseSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123;<br>            baseSize = (<span class="hljs-type">int</span>)mTmpValue.getDimension(packageMetrics);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (baseSize != <span class="hljs-number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;<br>           <span class="hljs-comment">// 以较小的baseSize获取测量属性spec</span><br>           childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width, lp.privateFlags);<br>           childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height,<br>                lp.privateFlags);<br>           <span class="hljs-comment">// 触发子View的绘制</span><br>           performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<br>           <span class="hljs-comment">// 查看测量过后，root的测量结果是否太小</span><br>           <span class="hljs-keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="hljs-number">0</span>) &#123;<br>               goodMeasure = <span class="hljs-literal">true</span>;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-comment">// 给大一点的宽度</span><br>               baseSize = (baseSize+desiredWindowWidth)/<span class="hljs-number">2</span>;<br>               <span class="hljs-comment">// 然后再次测量</span><br>               childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width, lp.privateFlags);<br>               performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<br>               <span class="hljs-comment">// 查看这次的测量结果是否还小</span><br>               <span class="hljs-keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="hljs-number">0</span>) &#123;<br>                   goodMeasure = <span class="hljs-literal">true</span>;<br>               &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果测量的结果不是一个好的结果，说明：</span><br>    <span class="hljs-comment">// 1.宽度不是wrap_content，之前没测。2.宽度是war_content，但是给定的宽度不满足view的要求</span><br>    <span class="hljs-keyword">if</span> (!goodMeasure) &#123;<br>        <span class="hljs-comment">// 以实际的窗口的宽度去获取测量属性spec</span><br>        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width,<br>                lp.privateFlags);<br>        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height,<br>                lp.privateFlags);<br>        <span class="hljs-keyword">if</span> (!forRootSizeOnly || !setMeasuredRootSizeFromSpec(<br>                childWidthMeasureSpec, childHeightMeasureSpec)) &#123;<br>            <span class="hljs-comment">// 触发测量</span><br>            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果只是测量root，并且宽高是match_parent或者具体值，则不会去measure了，省了一次测量</span><br>            mViewMeasureDeferred = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;<br>            windowSizeMayChange = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> windowSizeMayChange;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setMeasuredRootSizeFromSpec</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">widthMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(widthMeasureSpec);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">heightMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(heightMeasureSpec);<br>    <span class="hljs-comment">// 宽高值是否是精确值，如果有一个不是的话，则返回false</span><br>    <span class="hljs-keyword">if</span> (widthMode != MeasureSpec.EXACTLY || heightMode != MeasureSpec.EXACTLY) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 宽高值都是精确值，即match_patent或者具体的数值</span><br>    mMeasuredWidth = MeasureSpec.getSize(widthMeasureSpec);<br>    mMeasuredHeight = MeasureSpec.getSize(heightMeasureSpec);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>measureHierarchy</code>中会进行一系列的判断，首先根据<code>WindowManager.LayoutParams</code>的宽高属性判断是否是<code>wrap_content</code>来决定如何测量，如果是的话，则不会给实际的宽度限制，而是给一个少一点的<code>baseSize</code>来让子<code>View</code>测量，如果测量过后结果为尺寸太小，则会重新给大一点的宽度再次测量，如果还太小，则会在后面重新按原尺寸进行测量。</p><p>如果<code>LayoutParams</code>的宽度不是<code>wrap_content</code>，或者在前面的的测量中，两次的测量结果都太小，则会使用具体的窗口宽高进行测量。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// ViewRootImpl.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRootMeasureSpec</span><span class="hljs-params">(<span class="hljs-type">int</span> windowSize, <span class="hljs-type">int</span> measurement, <span class="hljs-type">int</span> privateFlags)</span> &#123;<br>    <span class="hljs-type">int</span> measureSpec;<br>    <span class="hljs-comment">// 如果设置了PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT，则使用match_patent</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">rootDimension</span> <span class="hljs-operator">=</span> (privateFlags &amp; PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT) != <span class="hljs-number">0</span><br>            ? MATCH_PARENT : measurement;<br>    <span class="hljs-keyword">switch</span> (rootDimension) &#123;<br>        <span class="hljs-keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:<br>            <span class="hljs-comment">// 给定的宽度是窗口宽度，但是测量规格精确值</span><br>            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:<br>            <span class="hljs-comment">/// 给定的宽度是窗口宽度，但是测量规格为最大值</span><br>            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);<br>            <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">// 宽度是一个具体值，给定测量规格为精确值</span><br>            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> measureSpec;<br>&#125;<br></code></pre></td></tr></table></figure><p>在通过<code>getRootMeasureSpec</code>获取到<code>root</code>的测量属性后，就会通过<code>performMeasure</code>进行测量。注意<code>View</code>的测量属性是一个<code>int</code>值，然后高2位表示测量模式，低30位表示具体的数值。最终的测量还是走到了<code>View</code>的<code>measure</code>方法。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// ViewRootImpl.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> childWidthMeasureSpec, <span class="hljs-type">int</span> childHeightMeasureSpec)</span> &#123;<br>    <span class="hljs-keyword">if</span> (mView == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="hljs-string">&quot;measure&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(Trace.TRACE_TAG_VIEW);<br>    &#125;<br>    mMeasuredWidth = mView.getMeasuredWidth();<br>    mMeasuredHeight = mView.getMeasuredHeight();<br>    mViewMeasureDeferred = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h4><p><code>MeasureSpec</code>是<code>View</code>的一个静态内部类，属于一个工具类，它的作用就是将模式和数值组合成一个测量属性，同样的也可以将一个测量属性拆分为模式和数值。它是用来限制子<code>View</code>的测量规格，其模式有三种：</p><ul><li><code>EXACTLY</code>：精确模式，通常在xml中设置宽或高为<code>match_parent</code>或者具体数值</li><li><code>AT_MOST</code>：最大模式，通常在xml中设置为<code>wrap_content</code>是为最大模式</li><li><code>UNSPECIFIED</code>：未指定模式，使用这种模式表示对宽高没有要求，类似于<code>AT_MOST</code>但是不需要给定最大值限定</li></ul><p>在了解了测量测试后，我们继续看后面子<code>View</code>的具体测量过程，即<code>measure</code>流程：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// View.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <br>    <span class="hljs-comment">// 根据宽高属性构建key，该key用于存储测量结果的缓存</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) widthMeasureSpec &lt;&lt; <span class="hljs-number">32</span> | (<span class="hljs-type">long</span>) heightMeasureSpec &amp; <span class="hljs-number">0xffffffffL</span>;<br>    <span class="hljs-keyword">if</span> (mMeasureCache == <span class="hljs-literal">null</span>) mMeasureCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongSparseLongArray</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// view是够设置了forceLayout</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">forceLayout</span> <span class="hljs-operator">=</span> (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;<br>    <span class="hljs-comment">// 宽高属性是否发生了变化</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">specChanged</span> <span class="hljs-operator">=</span> widthMeasureSpec != mOldWidthMeasureSpec<br>           || heightMeasureSpec != mOldHeightMeasureSpec;<br>    <span class="hljs-comment">// 宽高属性是否都是精确模式</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isSpecExactly</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY<br>           &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;<br>    <span class="hljs-comment">// 已测量的宽高是否与此次测量属性中的宽高一致</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">matchesSpecSize</span> <span class="hljs-operator">=</span> getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)<br>           &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);<br>    <span class="hljs-comment">// 是否需要测量</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">needsLayout</span> <span class="hljs-operator">=</span> specChanged<br>           &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);<br><br>    <span class="hljs-comment">// 如果需要测量，或者设置了forceLayout，则进行测量</span><br>    <span class="hljs-keyword">if</span> (forceLayout || needsLayout) &#123;<br>        <span class="hljs-comment">// 清除测量属性</span><br>        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;<br>        resolveRtlPropertiesIfNeeded();<br>        <span class="hljs-comment">// 如果不是forceLayout，则从缓存中取测量值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cacheIndex</span> <span class="hljs-operator">=</span> forceLayout ? -<span class="hljs-number">1</span> : mMeasureCache.indexOfKey(key);<br>        <span class="hljs-keyword">if</span> (cacheIndex &lt; <span class="hljs-number">0</span> || sIgnoreMeasureCache) &#123;<br>            <span class="hljs-comment">// 进行实际的测量</span><br>            onMeasure(widthMeasureSpec, heightMeasureSpec);<br>            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 从缓存中获取，然后不需要测量，直接设置测量结果</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> mMeasureCache.valueAt(cacheIndex);<br>            setMeasuredDimensionRaw((<span class="hljs-type">int</span>) (value &gt;&gt; <span class="hljs-number">32</span>), (<span class="hljs-type">int</span>) value);<br>            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br>        &#125;<br><br>         <span class="hljs-comment">// 如果我们重写了onMeasure，必须要在测量完成后通过setMeasuredDimension设置测量结果，否则直接抛异常</span><br>        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;View with id &quot;</span> + getId() + <span class="hljs-string">&quot;: &quot;</span><br>                    + getClass().getName() + <span class="hljs-string">&quot;#onMeasure() did not set the&quot;</span><br>                    + <span class="hljs-string">&quot; measured dimension by calling&quot;</span><br>                    + <span class="hljs-string">&quot; setMeasuredDimension()&quot;</span>);<br>        &#125;<br><br>        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;<br>    &#125;<br><br>    mOldWidthMeasureSpec = widthMeasureSpec;<br>    mOldHeightMeasureSpec = heightMeasureSpec;<br>    <span class="hljs-comment">// 缓存测量结果，以便下次直接使用</span><br>    mMeasureCache.put(key, ((<span class="hljs-type">long</span>) mMeasuredWidth) &lt;&lt; <span class="hljs-number">32</span> |<br>            (<span class="hljs-type">long</span>) mMeasuredHeight &amp; <span class="hljs-number">0xffffffffL</span>); <span class="hljs-comment">// suppress sign extension</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>measure</code>中也还是没有进行实际的测量，它首先会判读是否需要测量：宽高发生了变化或者<code>forceLayout</code>。当满足条件后还不一定会测量，而是根据宽高属性构建key，然后从缓存中查看之前是否已经对这对宽高属性测量过，如果查到的话会直接设置为宽高属性，查不到的时候才会去<code>onMeasure</code>进行测量。当然如果<code>forceLayout</code>的话就会直接测量了，也不需要管宽高是否发生变化，是否有缓存等。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// View.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forceLayout</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (mMeasureCache != <span class="hljs-literal">null</span>) mMeasureCache.clear();<br><br>    mPrivateFlags |= PFLAG_FORCE_LAYOUT;<br>    mPrivateFlags |= PFLAG_INVALIDATED;<br>&#125;    <br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestLayout</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    mPrivateFlags |= PFLAG_FORCE_LAYOUT;<br>    mPrivateFlags |= PFLAG_INVALIDATED;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中在<code>froceLayout</code>和<code>requestLayout</code>的时候，会设置<code>FORCE</code>属性，因此，如果我们想要强制进行测量时，就可以通过这两个方法中的任何一个来触发。然后接下来继续看<code>onMeasure</code>：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// View.java</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),<br>        getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDefaultSize</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> measureSpec)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(measureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(measureSpec);<br><br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>    <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>        result = size;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>    <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>        result = specSize;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，测量过程中并没有区分<code>AT_MOST</code>和<code>EXACTLY</code>，也就是说它实际上并没有区分<code>wrap_content</code>和<code>match_parent</code>，最终的结果都是按照<code>match_parent</code>处理的。因此，如果我们自定义<code>View</code>则必须要重写<code>onMeasure</code>来处理这两种情况。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// View.java</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMeasuredDimension</span><span class="hljs-params">(<span class="hljs-type">int</span> measuredWidth, <span class="hljs-type">int</span> measuredHeight)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">optical</span> <span class="hljs-operator">=</span> isLayoutModeOptical(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;<br>        <span class="hljs-type">Insets</span> <span class="hljs-variable">insets</span> <span class="hljs-operator">=</span> getOpticalInsets();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">opticalWidth</span>  <span class="hljs-operator">=</span> insets.left + insets.right;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">opticalHeight</span> <span class="hljs-operator">=</span> insets.top  + insets.bottom;<br>        measuredWidth  += optical ? opticalWidth  : -opticalWidth;<br>        measuredHeight += optical ? opticalHeight : -opticalHeight;<br>    &#125;<br>    setMeasuredDimensionRaw(measuredWidth, measuredHeight);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMeasuredDimensionRaw</span><span class="hljs-params">(<span class="hljs-type">int</span> measuredWidth, <span class="hljs-type">int</span> measuredHeight)</span> &#123;<br>    mMeasuredWidth = measuredWidth;<br>    mMeasuredHeight = measuredHeight;<br><br>    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;<br>&#125;<br></code></pre></td></tr></table></figure><p>在前面的<code>measure</code>流程中，在<code>onMeasure</code>之后会检测flag中是否有<code>PFLAG_MEASURED_DIMENSION_SET</code>，如果没哟会直接抛出异常，这是在提醒我们重写<code>onMeasure</code>进行测量的话，测量完成后必须将测量结果通过<code>setMeasuredDimension</code>告知到<code>View</code>本身。到这里我们似乎已经看完了测量的流程，最终是走到<code>View</code>的<code>onMeasure</code>中进行测量。我们的界面并不是一个单独的<code>View</code>，而是一整颗<code>View</code>树，因此对于<code>ViewGroup</code>而言，则一定不能使用默认的<code>onMeasure</code>进行测量本身，而是应该重写该方法，在<code>onMeasure</code>的时候触发它的子<code>View</code>的测量。</p><p>我们看下<code>FrameLayout</code>是如何做的：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// FrameLayout</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> getChildCount();<br>    ...<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChildAt(i);<br>        <span class="hljs-keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;<br>            measureChildWithMargins(child, widthMeasureSpec, <span class="hljs-number">0</span>, heightMeasureSpec, <span class="hljs-number">0</span>);<br>            ...<br>        &#125;<br>    &#125;<br>    ...<br>    setMeasuredDimension(<br>        resolveSizeAndState(maxWidth, widthMeasureSpec, childState),<br>        resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)<br>    );<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，当我们自定义<code>ViewGroup</code>的时候也应该按照它这样操作，首先触发每个子<code>View</code>的测量，最终计算出自身的宽高，然后设置下去。其中<code>measureChildWithMargins</code>是<code>ViewGroup</code>中定义的一些列方法，可以帮助我们快速触发子<code>View</code>的测量。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// ViewGroup.java</span><br><br><br><span class="hljs-comment">// 遍历子View，然后测量</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChildren</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mChildrenCount;<br>    <span class="hljs-keyword">final</span> View[] children = mChildren;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> children[i];<br>        <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;<br>            measureChild(child, widthMeasureSpec, heightMeasureSpec);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 和measureChildWithMargins一样，只是少了margin，只有padding</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChild</span><span class="hljs-params">(View child, <span class="hljs-type">int</span> parentWidthMeasureSpec,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> parentHeightMeasureSpec)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> child.getLayoutParams();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childWidthMeasureSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,<br>            mPaddingLeft + mPaddingRight, lp.width);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childHeightMeasureSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(parentHeightMeasureSpec,<br>            mPaddingTop + mPaddingBottom, lp.height);<br>    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChildWithMargins</span><span class="hljs-params">(View child,</span><br><span class="hljs-params">        <span class="hljs-type">int</span> parentWidthMeasureSpec, <span class="hljs-type">int</span> widthUsed,</span><br><span class="hljs-params">        <span class="hljs-type">int</span> parentHeightMeasureSpec, <span class="hljs-type">int</span> heightUsed)</span> &#123;<br>    <span class="hljs-comment">// 获取子View的属性</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MarginLayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (MarginLayoutParams) child.getLayoutParams();<br>    <span class="hljs-comment">// 传入自己的测量属性，以及已经使用过的宽度：padding和margin，然后计算子View的测量属性</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childWidthMeasureSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,<br>            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin<br>                    + widthUsed, lp.width);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childHeightMeasureSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(parentHeightMeasureSpec,<br>            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin<br>                    + heightUsed, lp.height);<br>    <span class="hljs-comment">// 将测量属性传给子View去测量</span><br>    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ViewGroup</code>给我们提供了三个方法供我们快速触发子<code>View</code>的测量。</p><ul><li><code>measureChildren</code>：遍历子<code>View</code>，然后通过<code>measureChild</code>触发子<code>View</code>的测量</li><li><code>measureChild</code>：计算子<code>View</code>的测量属性，然后实际触发测量。</li><li><code>measureChildWithMargins</code>：计算子<code>View</code>的测量属性，然后实际触发测量。</li></ul><p>当我们自定义<code>View</code>的时候，通常情况下还需要处理<code>LayoutParams</code>相关的逻辑。默认情况下使用的<code>LayoutParams</code>只支持<code>padding</code>等基础属性，而如果想要使用<code>margin</code>的话，则需要处理使其支持<code>MarginLayoutParams</code>。当子<code>View</code>不支持<code>margin</code>的时候，我们测量子<code>View</code>需要使用<code>measureChild</code>，如果所有的子<code>View</code>都不支持<code>margin</code>的话，则可以使用<code>measureChildren</code>直接触发所有的子<code>View</code>进行测量。否则的话只能使用<code>measureChildWithMargins</code>来触发。</p><p>同样的，快速获取子<code>View</code>的测量属性也是有提供的工具方法的，就是<code>getChildMeasureSpec</code>：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// ViewGroup.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getChildMeasureSpec</span><span class="hljs-params">(<span class="hljs-type">int</span> spec, <span class="hljs-type">int</span> padding, <span class="hljs-type">int</span> childDimension)</span> &#123;<br>    <span class="hljs-comment">// 父View的测量模式和测量值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">specMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(spec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(spec);<br>    <span class="hljs-comment">// 实际可用的尺寸需要去掉已使用的尺寸</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, specSize - padding);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">resultSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">resultMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>        <span class="hljs-comment">// 父View是精确模式</span><br>        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>            <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果子View设置了具体的尺寸，则也是精确模式，并使用它设置的值</span><br>                resultSize = childDimension;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>                <span class="hljs-comment">// 如果子View是match_parent，则也是精确模式，并使用父View提供的值</span><br>                resultSize = size;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>                <span class="hljs-comment">// 如果子View是wrap_content, 则使用父View提供的值，并设置为最大限制模式</span><br>                resultSize = size;<br>                resultMode = MeasureSpec.AT_MOST;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// 父View是最大限制模式</span><br>        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>            <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果子View设置了具体的尺寸，则也是精确模式，并使用它设置的值</span><br>                resultSize = childDimension;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>                <span class="hljs-comment">// 如果子View是match_parent，则也是最大限制模式，并使用父View提供的值</span><br>                resultSize = size;<br>                resultMode = MeasureSpec.AT_MOST;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>                <span class="hljs-comment">// 如果子View是wrap_content, 则使用父View提供的值，并设置为最大限制模式</span><br>                resultSize = size;<br>                resultMode = MeasureSpec.AT_MOST;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// 父View是未指定模式</span><br>        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>            <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果子View设置了具体的尺寸，则也是精确模式，并使用它设置的值</span><br>                resultSize = childDimension;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>                <span class="hljs-comment">// 如果子View是match_parent，则也是未指定模式，并使用父View提供的值</span><br>                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;<br>                resultMode = MeasureSpec.UNSPECIFIED;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>                <span class="hljs-comment">// 如果子View是match_parent，则也是最大限制模式，并使用父View提供的值</span><br>                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;<br>                resultMode = MeasureSpec.UNSPECIFIED;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将测量模式和测量值组合成测量属性返回</span><br>        <span class="hljs-keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);<br>    &#125;<br></code></pre></td></tr></table></figure><p>实际开发中我们就可以直接使用<code>getChildMeasureSpec</code>来快速构建子<code>View</code>的测量属性，它会综合父<code>View</code>的测量属性和子<code>View</code>的布局属性来构建出子<code>View</code>的测量属性。具体可以看下面的表格：</p><table><thead><tr><th>子布局属性\父测量属性</th><th>EXACTLY</th><th>AT_MOST</th><th>UNSPECIFIED</th></tr></thead><tbody><tr><td><code>match_parent</code></td><td>模式：<code>EXACTLY</code> &amp; 值：父值</td><td>模式：<code>AT_MOST</code> &amp; 值：父值</td><td>模式：<code>UNSPECIFIED</code> &amp; 值：父值</td></tr><tr><td><code>wrap_content</code></td><td>模式：<code>AT_MOST</code> &amp; 值：父值</td><td>模式：<code>AT_MOST</code> &amp; 值：父值</td><td>模式：<code>UNSPECIFIED</code> &amp; 值：父值</td></tr><tr><td>具体<code>dp</code>值</td><td>模式：<code>EXACTLY</code> &amp; 值：子值</td><td>模式：<code>EXACTLY</code> &amp; 值：子值</td><td>模式：<code>EXACTLY</code> &amp; 值：子值</td></tr></tbody></table><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>还是从<code>ViewRootImpl</code>开始触发，<code>View</code>绘制的三个流程都是在<code>performTraverals</code>中触发的。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// ViewRootImpl.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performTraversals</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 和measure的条件是一样的</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">didLayout</span> <span class="hljs-operator">=</span> layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>    <span class="hljs-keyword">if</span> (didLayout) &#123;<br>        performLayout(lp, mWidth, mHeight);<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>进入布局的条件和前面的进入测量的条件是一样的，也就是说，<code>measure</code>和<code>layout</code>通常是一起生效的。最终通过<code>preformLayout</code>进入实际的布局阶段，其中参数<code>mWidth</code>和<code>mHeight</code>是在前面赋值的，其实际为<code>mWinFram</code>的宽高，即窗口的宽高。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// ViewRootImpl.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performLayout</span><span class="hljs-params">(WindowManager.LayoutParams lp, <span class="hljs-type">int</span> desiredWindowWidth,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> desiredWindowHeight)</span> &#123;<br>    mScrollMayChange = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 标记开始测量</span><br>    mInLayout = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// host即为DecorView</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> mView;<br>    <span class="hljs-keyword">if</span> (host == <span class="hljs-literal">null</span>) &#123;<br>       <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 开始实际触发布局</span><br>        host.layout(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());<br>        ...<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(Trace.TRACE_TAG_VIEW);<br>    &#125;<br>    mInLayout = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>host</code>即是<code>View</code>树中的树根节点<code>DecorView</code>，由此布局的过程进入到<code>View</code>体系中。这里不去看具体的实现，直接看<code>ViewGroup</code>中的布局流程。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// ViewGroup.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">layout</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="hljs-literal">null</span> || !mTransition.isChangingLayout())) &#123;<br>        <span class="hljs-keyword">if</span> (mTransition != <span class="hljs-literal">null</span>) &#123;<br>            mTransition.layoutChange(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-built_in">super</span>.layout(l, t, r, b);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// record the fact that we noop&#x27;d it; request layout when transition finishes</span><br>        mLayoutCalledWhileSuppressed = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上是什么都没做的，最终还是回到<code>super.layout()</code>中。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// View.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">layout</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-comment">// 测量过程中，如果从缓存中获取到了以前测量过的结果，是不会触发测量的，而是直接跳过测量，同时设置了该flag</span><br>    <span class="hljs-comment">// 会在布局过程中再次触发onMeasure，</span><br>    <span class="hljs-keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="hljs-number">0</span>) &#123;<br>        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);<br>        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldL</span> <span class="hljs-operator">=</span> mLeft;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldT</span> <span class="hljs-operator">=</span> mTop;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldB</span> <span class="hljs-operator">=</span> mBottom;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldR</span> <span class="hljs-operator">=</span> mRight;<br><br>    <span class="hljs-comment">// 在setFrame中，会判断这四个值是否发生了变化，如果变化了，则重新赋值并返回true</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">changed</span> <span class="hljs-operator">=</span> isLayoutModeOptical(mParent) ?<br>            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);<br><br>    <span class="hljs-comment">// 如果宽高发生了变化，或者触发过measure测量，则重新布局。这个flag是测量时赋值的</span><br>    <span class="hljs-keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;<br>    	<span class="hljs-comment">// 触发布局，在ViewGroup中是抽象方法，在View中是空实现</span><br>        onLayout(changed, l, t, r, b);<br>        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>layout</code>中可以看到还会调用了一次<code>onMeasure</code>，这是因为在<code>measure</code>时，如果新的宽高属性在之前已经被测量过并且还在缓存中存储时，是不会去通过<code>onMeasure</code>继续测量的，而是直接设置为缓存的宽高，并通过设置<code>flag</code>将<code>onMeasure</code>延迟到了<code>layout</code>流程中。本身引入缓存的机制是为了节省一次测量流程的，但是实际上很多<code>View</code>还是依赖<code>onMeasure</code>的，因此不能完全省略，而是将其延迟到了<code>layout</code>前执行，这样可以将<code>performTraverals</code>中可能出现的多次测量的过程缩减到一次，整体上还是提高了测量的效率的。</p><p>然后就是设置它本身的宽高，如果上下左右的坐标发生了变化，或者前面测量过，则通过<code>onLayout</code>将布局流程继续分发下去。<code>onLayout</code>是一个空实现，但是在<code>ViewGroup</code>中被重写为抽象方法。因此，如果我们是自定义<code>View</code>，实际上是不需要处理这个方法的，因为我们的位置是由父布局来设置的；但是如果我们是自定义的<code>ViewGroup</code>中，则必须要重写该方法，并在该方法中去布局它自己的子<code>View</code>。</p><p>例如我们看<code>FrameLayout</code>的实现：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// FrameLayout.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLayout</span><span class="hljs-params">(<span class="hljs-type">boolean</span> changed, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> bottom)</span> &#123;<br>    layoutChildren(left, top, right, bottom, <span class="hljs-literal">false</span> <span class="hljs-comment">/* no force left gravity */</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">layoutChildren</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> bottom, <span class="hljs-type">boolean</span> forceLeftGravity)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> getChildCount();<br>    ...<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChildAt(i);<br>        <span class="hljs-keyword">if</span> (child.getVisibility() != GONE) &#123;<br>            ...<br>            child.layout(childLeft, childTop, childLeft + width, childTop + height);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际看到就是计算需要给子<code>View</code>布局的左右坐标，然后通过<code>layout</code>方法继续将布局流程给到子<code>View</code>。需要注意的就是在<code>onLayout</code>中，坐标值实际上是相对于父布局的，因此如果一个<code>View</code>被放置在父布局的左上角，那么在<code>onLayout</code>中的<code>left</code>和<code>top</code>值均为0。</p><h3 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h3><p>同样的，还在从<code>ViewRootImpl</code>中触发，然后回到<code>View</code>中。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// ViewRootImpl.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performTraversals</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isViewVisible) &#123;<br>       ...<br>       <span class="hljs-comment">// 界面不可见</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cancelAndRedraw) &#123;<br>       <span class="hljs-comment">// 重新触发三个流程</span><br>       scheduleTraversals();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ....<br>        <span class="hljs-comment">// 通过performDraw触发绘制</span><br>        <span class="hljs-keyword">if</span> (!performDraw() &amp;&amp; mActiveSurfaceSyncGroup != <span class="hljs-literal">null</span>) &#123;<br>            mActiveSurfaceSyncGroup.markSyncReady();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">performDraw</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">fullRedrawNeeded</span> <span class="hljs-operator">=</span> mFullRedrawNeeded || mActiveSurfaceSyncGroup != <span class="hljs-literal">null</span>;<br>    mFullRedrawNeeded = <span class="hljs-literal">false</span>;<br>    mIsDrawing = <span class="hljs-literal">true</span>;<br>    ...<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 绘制</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">canUseAsync</span> <span class="hljs-operator">=</span> draw(fullRedrawNeeded, usingAsyncReport &amp;&amp; mSyncBuffer);<br>        ...<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mIsDrawing = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终触发到<code>draw</code>方法中，这里实际还没有到<code>view</code>中，因为这里涉及<code>surface</code>以及硬件加速，所以会有很多的流程，才会走到<code>view</code>中。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fullRedrawNeeded, <span class="hljs-type">boolean</span> forceDraw)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">appScale</span> <span class="hljs-operator">=</span> mAttachInfo.mApplicationScale;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Rect</span> <span class="hljs-variable">dirty</span> <span class="hljs-operator">=</span> mDirty;<br>    <span class="hljs-comment">// 记录上次的Rect</span><br>    <span class="hljs-keyword">if</span> (fullRedrawNeeded) &#123;<br>        dirty.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-type">int</span>) (mWidth * appScale + <span class="hljs-number">0.5f</span>), (<span class="hljs-type">int</span>) (mHeight * appScale + <span class="hljs-number">0.5f</span>));<br>    &#125;<br>    <span class="hljs-comment">// ViewTreeObserver.onDraw</span><br>    mAttachInfo.mTreeObserver.dispatchOnDraw();<br>    ...<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">useAsyncReport</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;<br>        <span class="hljs-keyword">if</span> (isHardwareEnabled()) &#123;<br>            <span class="hljs-comment">// 开启了硬件加速</span><br>            mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="hljs-built_in">this</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ...<br>            <span class="hljs-keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,<br>                    scalingRequired, dirty, surfaceInsets)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> useAsyncReport;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">drawSoftware</span><span class="hljs-params">(Surface surface, AttachInfo attachInfo, <span class="hljs-type">int</span> xoff, <span class="hljs-type">int</span> yoff,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> &#123;<br><br>    <span class="hljs-comment">// Draw with software renderer.</span><br>    <span class="hljs-keyword">final</span> Canvas canvas;<br>    ...<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 根据偏移移动画布</span><br>        canvas.translate(-xoff, -yoff);<br>        <span class="hljs-keyword">if</span> (mTranslator != <span class="hljs-literal">null</span>) &#123;<br>            mTranslator.translateCanvas(canvas);<br>        &#125;<br>        canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 进入到View的绘制流程</span><br>        mView.draw(canvas);<br>        drawAccessibilityFocusedDrawableIfNeeded(canvas);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的<code>View</code>的绘制流程，实际上是属于软件绘制的，也就是<code>drawSoftware</code>，最终走到<code>View</code>的绘制流程中。注意在<code>ViewGroup</code>是没有重写<code>draw</code>的，因此最终走到的是在<code>view</code>中。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-meta">@CallSuper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *      1. 绘制背景</span><br><span class="hljs-comment">     *      2. 保存画布等待做渐隐边界</span><br><span class="hljs-comment">     *      3. 绘制View的内容</span><br><span class="hljs-comment">     *      4. 绘制子View</span><br><span class="hljs-comment">     *      5. 恢复画布并做渐隐边界</span><br><span class="hljs-comment">     *      6. 绘制滚动条</span><br><span class="hljs-comment">     *      7. 绘制焦点的高亮</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">// 步骤1，绘制背景</span><br>    <span class="hljs-type">int</span> saveCount;<br>    drawBackground(canvas);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">viewFlags</span> <span class="hljs-operator">=</span> mViewFlags;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">horizontalEdges</span> <span class="hljs-operator">=</span> (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">verticalEdges</span> <span class="hljs-operator">=</span> (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果没有渐隐渐现的边界要求，则跳过步骤2和5</span><br>    <span class="hljs-keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;<br>        <span class="hljs-comment">// 步骤3，绘制自身内容</span><br>        onDraw(canvas);<br>        <span class="hljs-comment">// 步骤4，绘制子View</span><br>        dispatchDraw(canvas);<br>        <span class="hljs-comment">// 步骤6，绘制前景和滚动条</span><br>        onDrawForeground(canvas);<br>        <span class="hljs-comment">// 步骤7，绘制焦点高亮</span><br>        drawDefaultFocusHighlight(canvas);<br>         <span class="hljs-comment">// 绘制结束</span><br>         <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 后面的流程没有省略步骤2和5，按顺序绘制的</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>绘制流程一共分了7个步骤，其他的我们基本上不需要去关注，基本上只需要关注步骤3即可。通常情况下，如果我们是自定义<code>ViewGroup</code>是不需要关注绘制的，如果是自定义<code>View</code>，则需要重写<code>onDraw</code>，然后在画布中绘制我们想要的界面内容即可。这个方法在<code>View</code>中也是一个空实现，等待我们重写并进行自定义绘制。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里，基本上<code>View</code>的绘制流程已经看完了，主要就是由<code>ViewRootImpl</code>触发的<code>performTraversals</code>，进入触发到<code>View</code>树的测量、布局、绘制三个流程。对于应用开发而言，如果是自定义<code>ViewGroup</code>，则重写<code>onMeasure</code>测量自身并触发子<code>View</code>的测量，然后重写<code>onLayout</code>触发子<code>View</code>的布局；如果是自定义<code>View</code>，则重写<code>onMeasure</code>测量自身，然后重写<code>onDraw</code>绘制自身内容即可。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Sat Apr 10 2021 19:20:31 GMT+0800");let n="Sat Apr 10 2021 19:20:31 GMT+0800";n="2024-12-26 16:37:09 +0800";var a=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-a)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Android-View/" class="post-footer-category">#&nbsp;Android View</a> <a href="/tags/View/" class="post-footer-tag">#&nbsp;View</a></div><div class="nav"><div class="nav-item-prev"><a href="/2021/06/06/di-hilt/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">好用的依赖注入框架-Hilt</div></div></a></div><div class="nav-item-next"><a href="/2021/03/12/aidl/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Android进程间通信-AIDL</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-3"><a href="#View%E7%9A%84%E7%BB%98%E5%88%B6" class="toc-link"><span class="toc-text">View的绘制</span></a></li><li class="toc-item toc-level-3"><a href="#Measure" class="toc-link"><span class="toc-text">Measure</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#MeasureSpec" class="toc-link"><span class="toc-text">MeasureSpec</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#layout" class="toc-link"><span class="toc-text">layout</span></a></li><li class="toc-item toc-level-3"><a href="#draw" class="toc-link"><span class="toc-text">draw</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2021-11-22</div><a href="/2021/11/22/android-scrolling-nested/"><div class="recent-posts-item-content">Android滑动事件之嵌套滑动</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-11-02</div><a href="/2021/11/02/coordinatorlayout-behavior/"><div class="recent-posts-item-content">CoordinatorLayout的秘密之Behavior</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-06-05</div><a href="/2023/06/05/flow-2/"><div class="recent-posts-item-content">SharedFlow、StateFlow、SafeFlow的区别</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-05-22</div><a href="/2023/05/22/flow/"><div class="recent-posts-item-content">协程数据流Flow</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-01-14</div><a href="/2023/01/14/sp-wp-refbase/"><div class="recent-posts-item-content">Android智能指针</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-10-02</div><a href="/2022/10/02/ams/"><div class="recent-posts-item-content">App管理服务-ActivityManagerService</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>