<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>将Room的使用方式塞到脑子里</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>34</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>5</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>16</span> <span>标签</span> </a><a class="author-word-count"><span>13.08</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Room%E7%AE%80%E4%BB%8B" class="toc-link"><span class="toc-text">Room简介</span></a></li><li class="toc-item toc-level-2"><a href="#%E4%BE%9D%E8%B5%96%E6%B7%BB%E5%8A%A0" class="toc-link"><span class="toc-text">依赖添加</span></a></li><li class="toc-item toc-level-2"><a href="#%E5%AE%9A%E4%B9%89%E8%A1%A8%E7%BB%93%E6%9E%84" class="toc-link"><span class="toc-text">定义表结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E8%A1%A8%E5%B1%9E%E6%80%A7" class="toc-link"><span class="toc-text">表属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E8%A1%A8%E5%90%8D%E7%A7%B0" class="toc-link"><span class="toc-text">表名称</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%88%97%E5%90%8D" class="toc-link"><span class="toc-text">列名</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%BF%BD%E7%95%A5%E7%9A%84%E5%B1%9E%E6%80%A7" class="toc-link"><span class="toc-text">忽略的属性</span></a></li><li class="toc-item toc-level-4"><a href="#%E4%B8%BB%E9%94%AE" class="toc-link"><span class="toc-text">主键</span></a></li><li class="toc-item toc-level-4"><a href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E5%88%97" class="toc-link"><span class="toc-text">索引和唯一列</span></a></li><li class="toc-item toc-level-4"><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC" class="toc-link"><span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%A4%96%E9%94%AE" class="toc-link"><span class="toc-text">外键</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F" class="toc-link"><span class="toc-text">外键约束</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="toc-link"><span class="toc-text">表的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="toc-link"><span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-5"><a href="#%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1" class="toc-link"><span class="toc-text">嵌套对象</span></a></li><li class="toc-item toc-level-5"><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" class="toc-link"><span class="toc-text">类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a href="#%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB" class="toc-link"><span class="toc-text">表的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E4%B8%80%E5%AF%B9%E4%B8%80" class="toc-link"><span class="toc-text">一对一</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F" class="toc-link"><span class="toc-text">查询方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#%E4%B8%80%E5%AF%B9%E5%A4%9A" class="toc-link"><span class="toc-text">一对多</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A" class="toc-link"><span class="toc-text">多对多</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a href="#%E5%88%9B%E5%BB%BADAO" class="toc-link"><span class="toc-text">创建DAO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#Insert" class="toc-link"><span class="toc-text">Insert</span></a></li><li class="toc-item toc-level-3"><a href="#Delete%E3%80%81Update" class="toc-link"><span class="toc-text">Delete、Update</span></a></li><li class="toc-item toc-level-3"><a href="#Query" class="toc-link"><span class="toc-text">Query</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#%E4%BD%BF%E7%94%A8" class="toc-link"><span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%BA%93" class="toc-link"><span class="toc-text">定义数据库</span></a></li><li class="toc-item toc-level-3"><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84Dao" class="toc-link"><span class="toc-text">创建数据库以及对应的Dao</span></a></li><li class="toc-item toc-level-3"><a href="#Migration" class="toc-link"><span class="toc-text">Migration</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">1</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="将Room的使用方式塞到脑子里 thumbnail" class="image lozad" src="/img/cover/cover-room.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">将Room的使用方式塞到脑子里</h1></header><div class="post-meta post-show-meta"><time datetime="2021-08-05T14:00:55.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2021-08-05</span> </time><span class="dot"></span> <a href="/categories/Third-Libraries/" class="post-meta-link">Third Libraries </a><span class="dot"></span> <span>约7.5k 字</span></div><div class="post-content" id="section"><h2 id="Room简介"><a href="#Room简介" class="headerlink" title="Room简介"></a>Room简介</h2><p><code>Room</code>是一个数据库框架，但它不是自己去实现的数据库，而是操作<code>sqlite</code>数据库，所以也可以称它为数据库封装框架。</p><p>对于使用者而言，仅需几个注解几个文件就能实现对数据库的操作，还是很方便的。并且由于采用的是编译时处理注解生成文件的方式，所以基本上不会有什么性能的损失。并且<code>Room</code>与协程也是无缝连接的，使用起来极其方便。</p><h2 id="依赖添加"><a href="#依赖添加" class="headerlink" title="依赖添加"></a>依赖添加</h2><p><code>Room</code>需要使用注解处理器，在<code>kotlin</code>项目中需要加上<code>kotlin-kapt</code>插件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    ...<br>    id <span class="hljs-string">&#x27;kotlin-kapt&#x27;</span><br>&#125;<br><br>dependencies &#123;<br>	...<br>    <span class="hljs-comment">// room数据库</span><br>    <span class="hljs-keyword">def</span> room_version = <span class="hljs-string">&quot;2.3.0&quot;</span><br>    implementation(<span class="hljs-string">&quot;androidx.room:room-runtime:$room_version&quot;</span>)<br>    kapt(<span class="hljs-string">&quot;androidx.room:room-compiler:$room_version&quot;</span>)<br>    <br>    <span class="hljs-comment">// 若是想要使用kotlin相关的一些功能，如suspend，flow等需要使用room-ktx依赖</span><br>    <span class="hljs-comment">// 若是加上了这个依赖，则前面的room-runtime依赖可以省略不加</span><br>    implementation(<span class="hljs-string">&quot;androidx.room:room-ktx:$room_version&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定义表结构"><a href="#定义表结构" class="headerlink" title="定义表结构"></a>定义表结构</h2><p>在<code>Room</code>中，我们不需要手动去创建表，而是定义一个实体类并且使用<code>@Entity</code>注解。这样<code>Room</code>就会根据类的字段去创建相应的数据库表，注意每个表必须都有一个主键。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id:<span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name:String<br>)<br></code></pre></td></tr></table></figure><p>如上的一个<code>Person</code>类，就会在数据库中生成一个<code>Person</code>表，两个字段分别叫<code>id</code>和<code>name</code>，并且都是非空类型。也就是说，默认情况下，表的名字和对应的类名是一致的，列的名称也是与字段的名称是一致的。</p><p>并且，由于<code>Kotlin</code>有非空检查，所以创建的表的字段也会对应的是否可空。如上面的对象生成的<code>Person</code>表，其中<code>name</code>列就是<code>not null</code> 的。若是使用<code>Java</code>声明的类，则<code>name</code>默认就会是可空的，除非给<code>name</code>字段加上<code>NotNull</code>注解。而<code>id</code>因为是主键，所以一定是不为空的。</p><h3 id="表属性"><a href="#表属性" class="headerlink" title="表属性"></a>表属性</h3><p>表的属性如表名，主键，外键等也是可以定制的，而不是一直固定死的。</p><h4 id="表名称"><a href="#表名称" class="headerlink" title="表名称"></a>表名称</h4><p>默认情况下，表名与类名保持一致。如上面的<code>Person</code>类对应的表名也是<code>Person</code>。可以通过<code>@Entity</code>的<code>tableName</code>属性进行修改。如下面的代码，则<code>Person</code>对应的表名就是<code>my_person</code></p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity(tableName = <span class="hljs-string">&quot;my_person&quot;</span>)</span><br>date <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(...)<br></code></pre></td></tr></table></figure><h4 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h4><p>默认情况下，列名与字段名也是保持一致的。如上面的<code>name</code>字段对应的列名就是<code>name</code>。可以通过<code>@ColumnInfo</code>的<code>name</code>属性进行修改（<code>ColumnInfo</code>有很多属性，这里先只说<code>name</code>属性）。如下例，则是将列名改成<code>person_name</code>。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id:<span class="hljs-built_in">Int</span><br>    <span class="hljs-meta">@ColumnInfo(name = <span class="hljs-string">&quot;person_name&quot;</span>)</span><br>    <span class="hljs-keyword">val</span> name:String,<br>)<br></code></pre></td></tr></table></figure><h4 id="忽略的属性"><a href="#忽略的属性" class="headerlink" title="忽略的属性"></a>忽略的属性</h4><p>在实体类中，有些字段可能是不想要映射在数据库的表中的，此时可以使用<code>@Ignore</code>注解某个不需要的字段，这样实体类对应的数据库表中就不会有该字段对应的列了。如下，则<code>Person</code>表中是没有<code>sex</code>列的。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 方式一，使用@Ignore注解</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> (<br>    ...<br>    <span class="hljs-meta">@Ignore</span><br>    <span class="hljs-keyword">val</span> sex: String<br>)<br><br><span class="hljs-comment">// 方式二，使用Entity的ignoreColumns属性</span><br><span class="hljs-meta">@Entity(ignoredColumns = [<span class="hljs-string">&quot;sex&quot;</span>])</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> (<br>    ...<br>    <span class="hljs-keyword">val</span> sex: String<br>)<br></code></pre></td></tr></table></figure><p><strong>注意上面的代码是错误的，只是用来演示的</strong>。在实体类中，要求每个字段都是能够访问的，并且要有不包含<code>@Ignore</code>的字段。如上例，构造方法中有了<code>sex</code>参数，所以会编译报错。并且，每个对应数据库列的字段都必须有<code>getter/setter</code>方法，其中<code>getter</code>是必须有的，而<code>setter</code>可以没有，但是没有<code>setter</code>的参数必须出现在构造方法中，也就是必须得提供一个注入的入口。</p><p>所以遇到<code>@Ignore</code>的参数，可以这样声明：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 方式一，不放在构造方法中</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> (<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name: String<br>) &#123;<br>    <span class="hljs-meta">@Ignore</span><br>    <span class="hljs-keyword">val</span> sex: String = <span class="hljs-string">&quot;男&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 方式二，额外提供一个不含sex的构造方法</span><br><span class="hljs-comment">// 提供的构造方法参数名字必须对应字段名字</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> (<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name: String,<br>    <span class="hljs-meta">@Ignore</span><br>    <span class="hljs-keyword">val</span> sex: String<br>)&#123;<br>    <span class="hljs-keyword">constructor</span>(id: <span class="hljs-built_in">Int</span>, name: String): <span class="hljs-keyword">this</span>(id, name, sex = <span class="hljs-string">&quot;男&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 方式三，提供默认值让编译器自动生成构造方法</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name: String,<br>    <span class="hljs-meta">@Ignore</span><br>    <span class="hljs-keyword">val</span> sex: String = <span class="hljs-string">&quot;男&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>从上面三种方式中，还是第一种方式比较好，首先比较简单，其次将二者分开了会显得更清晰。另外上面说的都是<code>data class</code>，而普通的类也是可以的：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">var</span> id: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-meta">@ColumnInfo(name = <span class="hljs-string">&quot;m_name&quot;</span>)</span><br>    <span class="hljs-keyword">var</span> name: String = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-meta">@Ignore</span><br>    <span class="hljs-keyword">val</span> sex: String = <span class="hljs-string">&quot;男&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意上面的普通类没有提供构造方法，也就是默认的构造方法，这时候<code>id</code>和<code>name</code>必须设置为<code>var</code>类型，因为这样才会自动生成<code>getter/setter</code>方法。</p><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>每个表必须有一个主键，主键是唯一的，不能重复。一个表中的主键可以不只是一个字段，而可以由多个字段组成复合主键。有两种方式可以设置主键，一种是使用<code>@PrimaryKey</code>，一种是使用<code>@Entity</code>的<code>primaryKeys</code>属性设置。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 方式一，使用@PrimaryKey直接设置在对应的字段上</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id:<span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name:String<br>)<br><br><span class="hljs-comment">// 方式二，使用primarykeys属性</span><br><span class="hljs-meta">@Entity(primaryKeys = [<span class="hljs-string">&quot;id&quot;</span>])</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-keyword">val</span> id:<span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name:String<br>)<br></code></pre></td></tr></table></figure><p>这两种的设置都能把<code>id</code>列设为主键，但是看起来还是第一种方式比较方便看着也清晰，所以一般使用第一种方式，直接将<code>@PrimaryKey</code>注解在对应的字段上即可。</p><p>但是第一种方式只能设置简单主键，也就是只有一个列是主键的情况。对于复合主键，则必须通过第二种方式去设置了。</p><p>主键还可以是自增的，将<code>autoGenerate</code>属性设为<code>true</code>即可，此时id可以设置也可以不设置，不设置则自动递增。但是这种情况下主键必须是<code>Int</code>或者<code>Long</code>类型，这样<code>insert</code>的时候，若是不带入主键，则自动递增设置值，注意这种情况下，主键要设置为可空的，然后在插入的时候赋值为<code>null</code>。递增是从1开始的，每次插入的时候会从最高的值开始递增。例如有两条数据，id分别是1和100，则下次插入数据的id则是101。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> (<br>    <span class="hljs-meta">@PrimaryKey(autoGenerate = true)</span><br>    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>?,<br>    <span class="hljs-keyword">val</span> name: String,<br>)<br><br><span class="hljs-comment">// dao.insert(Person(null, &quot;Person_1&quot;))</span><br></code></pre></td></tr></table></figure><h4 id="索引和唯一列"><a href="#索引和唯一列" class="headerlink" title="索引和唯一列"></a>索引和唯一列</h4><p>索引是数据库表中的一列或者多个列构成的一个排序的结构，当查询的时候，可以通过索引查询出位置，然后得到结果而不需要遍历原来的表数据来匹配结果。所以使用索引可以加快查询的速度。</p><p>可以将索引当成一个数据库表，存储着对应的数据以及相应位置的引用。但是这个表是给数据库管理系统使用的，不是给我们使用的，用户就正常执行相应的<code>SQL</code>语句，然后由数据库去进行优化选择是否查询索引。</p><p>创建索引需要消耗一定的存储空间，并且会拖慢更新表的操作，因为当插入或者修改表的时候也会更新索引表，但是好处是查询的速度大大增加（数据量很大的时候）。</p><p>而我们在手机本地存的数据显然不会很多，所以基本用不到索引。在<code>Room</code>中可以通过两种方式去创建索引。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 方式一，通过ColumnInfo的index属性设置索引</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    ...<br>    <span class="hljs-meta">@ColumnInfo(index = true)</span><br>    <span class="hljs-keyword">val</span> childId:<span class="hljs-built_in">Int</span><br>)<br><br><span class="hljs-comment">// 方式二，使用Entity的indices设置索引</span><br><span class="hljs-meta">@Entity(indices = [Index(<span class="hljs-string">&quot;childId&quot;</span>)])</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    ...<br>    <span class="hljs-keyword">val</span> childId:<span class="hljs-built_in">Int</span><br>)<br></code></pre></td></tr></table></figure><p>方式一比较方便，直接在对应的字段上注解<code>ColumnInfo</code>并且设置<code>index</code>属性为<code>true</code>即可。但是这种方式只能设置单列的索引。若是多个注解，则会生成多个索引，而非多列的索引。</p><p>方式二比较强大，是通过<code>Entity</code>的<code>indices</code>属性去创建索引。<code>indices</code>是一个数组，可以设置多个索引，索引通过<code>Index</code>去配置。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 创建两个索引，一个是只有name列的索引，一个是name和childId的双列的索引</span><br><span class="hljs-meta">@Entity(</span><br><span class="hljs-meta">    indices = [</span><br><span class="hljs-meta">        Index(<span class="hljs-string">&quot;name&quot;</span>),</span><br><span class="hljs-meta">        Index(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;childId&quot;</span>)</span><br><span class="hljs-meta">    ]</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> uid: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name: String,<br>    <span class="hljs-keyword">val</span> childId: <span class="hljs-built_in">Int</span><br>)<br></code></pre></td></tr></table></figure><p>上述的代码创建了两个索引，一个是<code>name</code>的索引，一个数<code>name</code>和<code>childId</code>的索引，像这种需要多个列的索引，用<code>ColumnInfo</code>是无法完成的。</p><p>索引还可以设置为<code>unique</code>，也就是索引不能重复。若是单列的索引，则该列的数据不能重复，若是多列的索引，则组合不能重复。 可以让某个列像是主键一样。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 给name列创建一个索引，并且不能重复</span><br><span class="hljs-meta">@Entity(</span><br><span class="hljs-meta">    indices = [Index(<span class="hljs-string">&quot;name&quot;</span>,unique = true)]</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> uid: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name: String,<br>    <span class="hljs-keyword">val</span> childId: <span class="hljs-built_in">Int</span><br>)<br><br><span class="hljs-comment">// 插入一条数据</span><br>insert into User values(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// 报错，因为name重复了，即使主键没重复</span><br>insert into User values(<span class="hljs-number">2</span>， <span class="hljs-string">&quot;张三&quot;</span>，<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>列中字段是可以设置默认值的，当<code>insert</code>的时候，若是没有插入该列，则会自动使用默认值去填充。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> uid: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-meta">@ColumnInfo(defaultValue = <span class="hljs-string">&quot;nobody&quot;</span>)</span><br>    <span class="hljs-keyword">val</span> name: String,<br>    <span class="hljs-meta">@ColumnInfo(defaultValue = <span class="hljs-string">&quot;-1&quot;</span>)</span><br>    <span class="hljs-keyword">val</span> childId: <span class="hljs-built_in">Int</span><br>)<br></code></pre></td></tr></table></figure><p>实际上，通过<code>Room</code>的<code>Dao</code>进行正常插入的时候，是无法使用到默认值的。因为<code>kotlin</code>是有非空检测的，因此不允许在<code>name</code>和<code>childId</code>字段传值为<code>null</code>。而若是将这两个字段设置为可空的话，对应的表的列属性也是可为<code>NULL</code>的，这时候传入<code>null</code>的话，表中的对应列也会是<code>NULL</code>，而不会去应用默认值。</p><p>所以，想要使用默认值，要么使用<code>Java</code>语言操作（定义实体类时使用<code>@NotNull</code>注解字段，然后传入<code>null</code>），要么使用<code>@Query</code>直接执行插入的<code>SQL</code>语句。涉及到的<code>DAO</code>部分会在后面讲解。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Query(<span class="hljs-string">&quot;insert into User(uid) values(:id)&quot;</span>)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">insertByQuery</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span><br></code></pre></td></tr></table></figure><h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>外键只能通过<code>Entity</code>的<code>foreignKeys</code>属性去设置，类型为<code>ForeignKey</code>。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity(</span><br><span class="hljs-meta">    foreignKeys = [</span><br><span class="hljs-meta">        ForeignKey(</span><br><span class="hljs-meta">            entity = User::class,</span><br><span class="hljs-meta">            parentColumns = [<span class="hljs-string">&quot;uid&quot;</span>],</span><br><span class="hljs-meta">            childColumns = [<span class="hljs-string">&quot;childId&quot;</span>]</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">    ]</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name: String,<br>    <span class="hljs-keyword">val</span> childId: <span class="hljs-built_in">Int</span><br>)<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> uid: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name: String<br>)<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>Person</code>表中的<code>childId</code>是一个外键，引用<code>User</code>表中的<code>uid</code>列。这些都是在<code>ForeignKey</code>中配置的。首先参数<code>entity</code>指向外键引用的表对应的实体类，<code>parentColumns</code>指的是引用的表中的列，而<code>clildColumns</code>指的是本表中引用的列名。</p><p>其中<code>parentColumns</code>和<code>childColumns</code>都是数组类型的，二者的数量必须是对应的。并且对于外键引用的列，一般引用另一个表的主键，并且最好设置为索引<code>index</code>。若是引用的不是主键，则必须将引用列设置为索引并且<code>unique</code>。</p><h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><p>具有外键的表操作具有级联属性，也就是当被引用的表修改时，引用的表也会同步修改。可以通过<code>ForeignKey</code>中的<code>onDelete</code>和<code>onUpdate</code>属性来设置约束操作。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity(</span><br><span class="hljs-meta">    foreignKeys = [</span><br><span class="hljs-meta">        ForeignKey(</span><br><span class="hljs-meta">            entity = User::class, </span><br><span class="hljs-meta">            parentColumns = [<span class="hljs-string">&quot;uid&quot;</span>], </span><br><span class="hljs-meta">            childColumns = [<span class="hljs-string">&quot;user&quot;</span>],</span><br><span class="hljs-meta">            onDelete = ForeignKey.CASCADE,</span><br><span class="hljs-meta">            onUpdate = ForeignKey.CASCADE</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">    ]</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>?,<br>    <span class="hljs-keyword">val</span> name: String,<br>    <span class="hljs-keyword">val</span> user: <span class="hljs-built_in">Int</span><br>)<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> uid: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> sex: String<br>)<br></code></pre></td></tr></table></figure><p>如上例，<code>Person</code>表中的<code>user</code>列是一个外键，引用了<code>User</code>表中的<code>uid</code>列，并且设置了<code>onDelete</code>的操作为级联<code>CASCADE</code>。所以当<code>User</code>表发生删除事件后，也会对<code>Person</code>表中引用的数据进行删除。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tex">User表中有一条数据：<br><br>   id  |  name<br>   ----+---------<br>    1  |   “男”<br><br><br>Person表中有两条数据：<br><br>   id  |  name   | user<br>   ----+---------+------<br>    1  |  “张三”  |  1<br>    2  |  “李四”  |  1<br></code></pre></td></tr></table></figure><p>如上，<code>Person</code>表中两条数据的外键都是引用的<code>User</code>中的那条数据，所以当<code>User</code>表中的数据删除后，<code>Person</code>表中的两条引用数据也会自动删除，这就是<code>CASCADE</code>的效果。一共五种约束操作：</p><ul><li><code>NO_ACTION</code> 没有操作，也就是默认约束，当删除<code>User</code>中那条数据的时候，由于被<code>Person</code>中的数据引用着，所以直接抛出异常</li><li><code>RESTRICT</code> 和<code>NO_ACTION</code>一样，不同是<code>RETRICT</code>在字段修改或删除的时候就去检查外键约束，而不是等语句执行完</li><li><code>SET_NULL</code> 将外键引用的表的字段设为<code>NULL</code>。如上表，当删除<code>User</code>中的数据时，<code>Person</code>表中的两条数据的<code>user</code>列的值都会被设置为<code>NULL</code>。当然，上面我们定义实体类的时候属性<code>user:Int</code>是非空的，所以实际删除的时候会抛出异常，要实现这种操作，必须将对应的外键的类型设置为可空的<code>user:Int?</code>。</li><li><code>SET_DEFAULT</code> 将外键的引用表的字段设置为默认值。需要注意的是，默认值必须也是存在于被引用的表中的字段，也就是<code>User</code>中的另一条数据。所以，这种情况下，被引用表<code>User</code>表至少要有一条数据,用于被<code>Person</code>表设置默认值，否则会因为找不到引用数据而抛出异常。</li><li><code>CASCADE</code> 级联操作，也是最常用的约束关系，当<code>User</code>表删除数据的时候，引用这条数据的<code>Person</code>表中的两条数据都会删除。修改<code>User</code>表的这条数据的<code>uid</code>的时候，<code>Person</code>表中的<code>user</code>字段也会改成新修改的值。</li></ul><h4 id="表的数据类型"><a href="#表的数据类型" class="headerlink" title="表的数据类型"></a>表的数据类型</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p><code>Room</code>只支持八大基本数据类型和<code>String</code>类型。</p><ul><li><code>Byte，Short，Int，Long</code> 表中被当做<code>INTEGER</code>存储</li><li><code>Boolean</code> 表中被当做<code>INTEGER</code>存储，0为<code>false</code>，1为<code>true</code></li><li><code>Char</code> 表中被当做<code>INTEGER</code>存储，记录的值是其<code>ACSII</code>码</li><li><code>Float，Double</code> 表中被当做<code>REAL</code>类型存储</li><li><code>String</code> 表中被当做<code>TEXT</code>类型存储</li></ul><h5 id="嵌套对象"><a href="#嵌套对象" class="headerlink" title="嵌套对象"></a>嵌套对象</h5><p>也就是说，在定义表对应的实体对象的时候，字段默认是只能使用这九种数据类型的，若是使用了其他的类型，则在编译期间就会报错。</p><p><code>Room</code>还提供了嵌套对象的注解<code>@Embedded</code>，可以将嵌套对象展开，作为当前表的字段。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>?,<br>    <span class="hljs-meta">@Embedded</span><br>    <span class="hljs-keyword">val</span> user: User<br>)<br><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<br>    <span class="hljs-keyword">val</span> uid: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> sex:String<br>)<br></code></pre></td></tr></table></figure><p>如上面的代码，则生成的<code>Person</code>表中，一共有三列，分别是<code>id，uid，sex</code>可以看到直接将<code>User</code>类中的字段展开到了<code>Person</code>表中。这种展开是有限制的，就是名称不能重复，比如<code>Person</code>中有个字段叫做<code>id</code>，则<code>User</code>表中不能有<code>id</code>这个字段。</p><p>其中<code>User</code>这个类可以是普通的类，也可以是一个被<code>@Entity</code>的数据库表的实体类。</p><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>类型转换就是添加相应的<code>TypeConverter</code>，然后在操作数据库表的时候，<code>Room</code>就会根据<code>TypeConverter</code>将对应的字段转换成目标类型，然后在进行数据库操作。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">object</span> DateTypeConverter &#123;<br><br>    <span class="hljs-meta">@TypeConverter</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fromTimestamp</span><span class="hljs-params">(value: <span class="hljs-type">Long</span>?)</span></span>: Date? &#123;<br>        <span class="hljs-keyword">return</span> value?.let &#123; Date(it) &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@TypeConverter</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dateToTimestamp</span><span class="hljs-params">(date: <span class="hljs-type">Date</span>?)</span></span>: <span class="hljs-built_in">Long</span>? &#123;<br>        <span class="hljs-keyword">return</span> date?.time<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上例，就是将<code>Date</code>类型和<code>Long</code>类型互相转换的转换器，使用<code>TypeConverter</code>注解来注解方法，表示该方法用来转换的。转换器可以是单例对象<code>object class</code> 也可以是普通的对像。当添加该转换器后，就可以定义具有<code>Date</code>字段的数据库映射对象了。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>?,<br>    <span class="hljs-keyword">val</span> user: Date<br>)<br></code></pre></td></tr></table></figure><p>注意，类型转换器只有一个参数，而且必须有返回值。参数和返回值构成了一组转换，并且对于一种类型，必须提供两个方法用于互相转换。至于怎么添加类型转换器，则放在后面再说。</p><h3 id="表的关系"><a href="#表的关系" class="headerlink" title="表的关系"></a>表的关系</h3><p>表的关系通常有三种，一对一，一对多，多对多。</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一是指两张表之间，一条数据只对应一条数据。这种关系比较简单，一般用于对表数据的拓展。两张表可以通过外键进行连接，外键不要单独使用一个列，这样容易行成多对多的关系。而是应该将一张表的主键设为另一张表的外键，从而构成一对一的关系。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 一对一关系，一个人只有一个详细地址，一个详细地址对应一个人</span><br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name: String,<br>    <span class="hljs-keyword">val</span> sex: String<br>)<br><br><span class="hljs-meta">@Entity(</span><br><span class="hljs-meta">    foreignKeys = [ForeignKey(</span><br><span class="hljs-meta">        entity = Person::class,</span><br><span class="hljs-meta">        parentColumns = [<span class="hljs-string">&quot;id&quot;</span>],</span><br><span class="hljs-meta">        childColumns = [<span class="hljs-string">&quot;pid&quot;</span>],</span><br><span class="hljs-meta">        onUpdate = ForeignKey.CASCADE,</span><br><span class="hljs-meta">        onDelete = ForeignKey.CASCADE</span><br><span class="hljs-meta">    )]</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonAddress</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> pid: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> city: String,<br>    <span class="hljs-keyword">val</span> address: String,<br>    <span class="hljs-keyword">val</span> details: String<br>)<br></code></pre></td></tr></table></figure><p>如上面就是设计了两张一对一关系的表，一个<code>Person</code>只能对应一个<code>PersonAddress</code>，同理一个<code>PersonAddress</code>也只能对应一个<code>Person</code>。二者通过外键链接，并且外键也被设置为了主键，同时设置为级联操作，当删除主表<code>Person</code>中的数据后，拓展表<code>PersonAddress</code>中对应的数据也会被删除。这是一个很标准的一对一关系的设计方式。</p><h5 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h5><p>这种有关系的表的查询比较麻烦，需要额外定义一个类，用来存放查询结果。这个类不需要使用@Entity注解，因为它不对应数据库表，只是一个查询结果的容器。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonWithAddress</span>(<br>    <span class="hljs-meta">@Embedded</span><br>    <span class="hljs-keyword">val</span> person: Person,<br>    <span class="hljs-meta">@Relation(parentColumn = <span class="hljs-string">&quot;id&quot;</span>, entityColumn = <span class="hljs-string">&quot;pid&quot;</span>)</span><br>    <span class="hljs-keyword">val</span> address: PersonAddress<br>)<br></code></pre></td></tr></table></figure><p>其中，主要的字段使用<code>@Embedded</code>注解，其他字段使用<code>@Relation</code>来声明两个表之间的关系。其中<code>Relation</code>至少要写两个属性，<code>parentColumn</code>属性是<code>@Embedded</code>修饰类的字段，而	<code>entityColumn</code>属性则是当前类的字段。当查询到<code>Person</code>之后，会根据<code>Person.id</code>字段作为<code>PersonAddress.pid</code>字段去查询结果。所以会经历两个查询过程，因此还需要加上事务的注解<code>@Transaction</code>。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Transaction</span><br><span class="hljs-meta">@Query(<span class="hljs-string">&quot;select * from Person where id = :id&quot;</span>)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queryPerson</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span>: PersonWithAddress<br></code></pre></td></tr></table></figure><p>若是想要查询以<code>PersonAddress</code>为主的话，则需要另外定义一个容器类：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddressWithPerson</span>(<br>    <span class="hljs-meta">@Embedded</span><br>    <span class="hljs-keyword">val</span> address:PersonAddress,<br>    <span class="hljs-meta">@Relation(parentColumn = <span class="hljs-string">&quot;pid&quot;</span>, entityColumn = <span class="hljs-string">&quot;id&quot;</span>)</span><br>    <span class="hljs-keyword">val</span> person:Person<br>)<br><span class="hljs-comment">// 对应的查询语句</span><br><span class="hljs-meta">@Transaction</span><br><span class="hljs-meta">@Query(<span class="hljs-string">&quot;select * from PersonAddress where pid = :id&quot;</span>)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queryAddress</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span>: AddressWithPerson<br></code></pre></td></tr></table></figure><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>一对多关系也是用外键形成的，但是这种情况下，外键不能用主键了，而应该使用一个独立的列。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 一对多关系，一个人有一个城市，但是一个城市可以有多个人</span><br><br><span class="hljs-meta">@Entity(</span><br><span class="hljs-meta">    foreignKeys = [ForeignKey(</span><br><span class="hljs-meta">        entity = City::class,</span><br><span class="hljs-meta">        parentColumns = [<span class="hljs-string">&quot;cityCode&quot;</span>],</span><br><span class="hljs-meta">        childColumns = [<span class="hljs-string">&quot;city&quot;</span>],</span><br><span class="hljs-meta">        onDelete = ForeignKey.CASCADE,</span><br><span class="hljs-meta">        onUpdate = ForeignKey.CASCADE</span><br><span class="hljs-meta">    )]</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> name: String,<br>    <span class="hljs-keyword">val</span> city: <span class="hljs-built_in">Int</span><br>)<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">City</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> cityCode: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> cityName: String<br>)<br></code></pre></td></tr></table></figure><p>同样的道理，这种多表之间的关系都是需要使用独立的类去进行存储的：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonWithCity</span>(<br>    <span class="hljs-meta">@Embedded</span><br>    <span class="hljs-keyword">val</span> person: Person,<br>    <span class="hljs-meta">@Relation(parentColumn = <span class="hljs-string">&quot;city&quot;</span>, entityColumn = <span class="hljs-string">&quot;cityCode&quot;</span>)</span><br>    <span class="hljs-keyword">val</span> city: <span class="hljs-built_in">Int</span><br>)<br><span class="hljs-comment">// 对应的查询语句</span><br><span class="hljs-meta">@Transaction</span><br><span class="hljs-meta">@Query(<span class="hljs-string">&quot;select * from Person where id = :id&quot;</span>)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queryPerson</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span>:PersonWithCity<br><br><br><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CityWithPersons</span>(<br>    <span class="hljs-meta">@Embedded</span><br>    <span class="hljs-keyword">val</span> city: City,<br>    <span class="hljs-meta">@Relation(parentColumn = <span class="hljs-string">&quot;cityCode&quot;</span>, entityColumn = <span class="hljs-string">&quot;city&quot;</span>)</span><br>    <span class="hljs-keyword">val</span> persons: List&lt;Person&gt;<br>)<br><span class="hljs-comment">// 对应的查询语句</span><br><span class="hljs-meta">@Transaction</span><br><span class="hljs-meta">@Query(<span class="hljs-string">&quot;select * from City where cityCode = :id&quot;</span>)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queryCity</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span>:CityWithPersons<br><br></code></pre></td></tr></table></figure><p>注意一点的是，<code>City</code>与<code>Person</code>是多对一的关系，因此<code>CityWithPersons</code>对象的<code>persons</code>属性需要写成<code>List</code>集合。</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>对对多的关系需要使用第三个表来进行关联两个表。这里借用官网的例子，音乐表和播放列表表。关系是一首音乐可以存在多个播放列表中，一个播放列表中也可以有多首音乐。</p><p>首先定义两个表：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Song</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> songId:<span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> songName:String<br>)<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PlayList</span>(<br>    <span class="hljs-meta">@PrimaryKey</span><br>    <span class="hljs-keyword">val</span> playId:<span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> playName:String<br>)<br></code></pre></td></tr></table></figure><p>然后声明第三张表来定义关系，第三张表将前两张表的主键集合在一起，作为一张表，然后设置两个外键分别对应原来的两张表，同时也将这两列作为组合主键，避免数据重复。注意一点，第三张表的两个列名必须和引用的两个表的引用列名相同。：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Entity(</span><br><span class="hljs-meta">    primaryKeys = [<span class="hljs-string">&quot;songId&quot;</span>, <span class="hljs-string">&quot;playId&quot;</span>],</span><br><span class="hljs-meta">    foreignKeys = [</span><br><span class="hljs-meta">        ForeignKey(</span><br><span class="hljs-meta">            entity = Song::class,</span><br><span class="hljs-meta">            parentColumns = [<span class="hljs-string">&quot;songId&quot;</span>],</span><br><span class="hljs-meta">            childColumns = [<span class="hljs-string">&quot;songId&quot;</span>]</span><br><span class="hljs-meta">        ),</span><br><span class="hljs-meta">        ForeignKey(</span><br><span class="hljs-meta">            entity = PlayList::class,</span><br><span class="hljs-meta">            parentColumns = [<span class="hljs-string">&quot;playId&quot;</span>],</span><br><span class="hljs-meta">            childColumns = [<span class="hljs-string">&quot;playId&quot;</span>]</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">    ]</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SongPlayList</span>(<br>    <span class="hljs-keyword">val</span> songId: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">val</span> playId: <span class="hljs-built_in">Int</span><br>)<br></code></pre></td></tr></table></figure><p>这样就完成了两个表的多对多关系的建立，每当有歌被添加到播放列表的时候，就可以向<code>SongPlayList</code>中添加一条数据即可。</p><p>对于查询还是一样要借助一个新的对象进行存储：</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SongRecord</span>(<br>    <span class="hljs-meta">@Embedded</span><br>    <span class="hljs-keyword">val</span> song: Song,<br>    <span class="hljs-meta">@Relation(</span><br><span class="hljs-meta">        parentColumn = <span class="hljs-string">&quot;songId&quot;</span>,</span><br><span class="hljs-meta">        entityColumn = <span class="hljs-string">&quot;playId&quot;</span>,</span><br><span class="hljs-meta">        associateBy = Junction(SongPlayList::class)</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-keyword">val</span> songPlayLists: List&lt;PlayList&gt;<br>)<br><br><span class="hljs-comment">// 对应的查询语句</span><br><span class="hljs-meta">@Transaction</span><br><span class="hljs-meta">@Query(<span class="hljs-string">&quot;select * from Song where songId = :id&quot;</span>)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">querySong</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span>: SongRecord<br></code></pre></td></tr></table></figure><p>和前面基本上是一样的，唯一一点差别就是在<code>@Relation</code>的时候，额外加了一个属性<code>associateBy</code>，用来指示联系两张表的第三张表。</p><h2 id="创建DAO"><a href="#创建DAO" class="headerlink" title="创建DAO"></a>创建DAO</h2><blockquote><p><code>DAO</code>(Data Access Object) 数据访问对象是一个面向对象的数据库接口</p></blockquote><p>说白了<code>DAO</code>就是一个接口，里面定义了多个方法，以对象的方式实现数据库表的增删改查功能。在<code>Room</code>中定义一个<code>Dao</code>异常简单，只需要声明一个接口，然后使用<code>@Dao</code>注解即可，具体的实现都会由<code>Room</code>来帮我们实现。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Dao</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><blockquote><p><code>Dao</code>中的增删改查都是耗时操作，是不允许在主线程调用的（可以在创建数据库对象的时候设置允许主线程调用，但是不推荐这样），在<code>kotlin</code>中可以设置为<code>suspend</code>方法，这样就可以避免手动去进行线程切换了。</p></blockquote><p><code>@Insert</code>用来注解一个方法，该方法用来实现对数据库表数据的插入。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Dao</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SongDao</span> &#123;<br>    <span class="hljs-meta">@Insert()</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">insertSong</span><span class="hljs-params">(song: <span class="hljs-type">Song</span>)</span></span>: <span class="hljs-built_in">Long</span><br><br>    <span class="hljs-meta">@Insert</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">insertSongs</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> songs: <span class="hljs-type">Song</span>)</span></span>: List&lt;<span class="hljs-built_in">Long</span>&gt;<br>    <br>    <span class="hljs-meta">@Insert</span> <br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">insertSongs</span><span class="hljs-params">(songs:<span class="hljs-type">Iterable</span>&lt;<span class="hljs-type">Song</span>&gt;)</span></span>: Array&lt;<span class="hljs-built_in">Long</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Dao</code>中的方法上使用<code>@Insert</code>注解，可以声明该方法为插入方法，参数是要插入的数据。如上例，就是向数据库Song表中插入数据。参数可以是一个对象，也可以是多个。</p><p><code>Insert</code>方法可以没有返回值，有返回值的话则只能是<code>Long</code>类型的。若是主键是单一主键并且类型是整型的话，则返回插入的主键。若是非整型主键或者是组合主键的话，则返回插入的行数，从<strong>1</strong>开始。</p><p><code>@Insert</code>注解还有一个<code>onConflict</code>参数，用于定义当插入数据冲突（要插入的数据的主键在数据库表中已存在）时执行的操作。,一共有五种操作（两种已过时）:</p><ul><li><code>OnConflictStrategy.ABORT</code> 终止插入，并且抛出异常</li><li><code>OnConflictStrategy.REPLACE</code> 覆盖原数据</li><li><code>OnConflictStrategy.IGNORE</code> 忽略这条数据，若是有返回值的话则返回<code>-1</code></li></ul><h3 id="Delete、Update"><a href="#Delete、Update" class="headerlink" title="Delete、Update"></a>Delete、Update</h3><p>使用<code>@Delete</code>来注解一个方法为删除语句，参数仍然是映射对象。注意，删除只关注参数对象对应的主键，其他参数会忽略，只要主键匹配，就会删除。</p><p>删除方法也可以不加返回值，加的话只能使用<code>Int</code>返回值，代表本次删除的个数。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Dao</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SongDao</span> &#123;<br>    <span class="hljs-meta">@Delete</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delSong</span><span class="hljs-params">(song: <span class="hljs-type">Song</span>)</span></span>: <span class="hljs-built_in">Int</span><br>    <br>    <span class="hljs-meta">@Insert</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delSongs</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> songs: <span class="hljs-type">Song</span>)</span></span>: <span class="hljs-built_in">Int</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>而将上述的<code>@Delete</code>改为<code>@Update</code>就成了一个更新语句，这时候会将主键对应的数据的全部列的值都更新成参数的值，并且返回值代表着更新的条数。</p><h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><p><code>Query</code>的难度较高一些，因为这需要我们自己去编写查询的<code>SQL</code>语句。<code>Query</code>注解的查询语句返回值可以是对象，也可以是<code>List</code>集合。注意如果是对象的话记得声明成可空的对象，因此有可能会查不到数据，而查询的是集合的话，则不用担心这点，因为查不到的话会返回一个空集合，而不会返回<code>null</code>。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Dao</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-meta">@Query(<span class="hljs-string">&quot;select * from Song where songId = :songId&quot;</span>)</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">querySong</span><span class="hljs-params">(songId: <span class="hljs-type">Int</span>)</span></span>: Song?<br><br>    <span class="hljs-meta">@Query(<span class="hljs-string">&quot;select * from Song&quot;</span>)</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">querySongs</span><span class="hljs-params">()</span></span>: List&lt;Song&gt;<br>    <br>    <span class="hljs-comment">//返回值还可以使用LiveData或者Flow</span><br>    <span class="hljs-meta">@Query(<span class="hljs-string">&quot;select * from Song&quot;</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">querySongsLive</span><span class="hljs-params">()</span></span>: LiveData&lt;List&lt;Song&gt;&gt;<br>    <br>    <span class="hljs-meta">@Query(<span class="hljs-string">&quot;select * from Song&quot;</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">querySongsFlow</span><span class="hljs-params">()</span></span>: Flow&lt;List&lt;Song&gt;&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Query</code>需要接收一个<code>SQL</code>语句，可以使用冒号加上方法的某个参数将其注入到<code>SQL</code>语句中，如上例的<code>:songId</code>。为了避免线程切换不仅仅可以定义为<code>suspend</code>方法，还可以修改返回值，使用<code>LiveData</code>或者<code>Flow</code>包裹返回值也行，这种情况下不能再使用<code>suspend</code>修饰了，只能是普通方法。并且，<code>LiveData</code>和<code>Flow</code>会持续的监听数据库的变化。比如上例查询所有的<code>Song</code>，当向数据库中插入一条新的<code>Song</code>的时候，返回值<code>LiveData</code>也会拿到新的一个<code>List</code>集合。</p><p>此外，<code>@Query</code>既然能执行<code>SQL</code>语句，那肯定就不只是有查询功能，插入删除修改都是可以的，当使用这些语句的时候，返回值跟前面使用注解的返回值要求是一样的。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Dao</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br> <span class="hljs-meta">@Query(<span class="hljs-string">&quot;insert into Song values(:id, :name)&quot;</span>)</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">insertSong</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>)</span></span><br><br>    <span class="hljs-meta">@Query(<span class="hljs-string">&quot;delete from Song where songId = :id&quot;</span>)</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delSong</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span><br><br>    <span class="hljs-meta">@Query(<span class="hljs-string">&quot;update Song set songName = :name where songId = :id&quot;</span>)</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">update</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>@Query</code>能够完全实现数据库表的增删改查，并且可以更加灵活。比如增加数据的时候只插入某几个列，其他列使用默认值（在<code>kotlin</code>中这是使用<code>@Insert</code>无法实现的）。比如修改数据的时候，只修改某几列，而不是全部修改（使用<code>@Update</code>会全部修改，即使某些列数据没发生改变）。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>当定义完表结构以及<code>Dao</code>后，就需要去创建数据库以及获取<code>Dao</code>实例了。数据库实例需要继承<code>RoomDatabase</code>，并且声明成抽象类，以及获取<code>Dao</code>的几个抽象方法。</p><h3 id="定义数据库"><a href="#定义数据库" class="headerlink" title="定义数据库"></a>定义数据库</h3><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-meta">@Database(</span><br><span class="hljs-meta">    version = 1,</span><br><span class="hljs-meta">    entities = [Song::class, SongPlayList::class, PlayList::class, User::class]</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">@TypeConverters(DateTypeConverter::class)</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDatabase</span> : <span class="hljs-type">androidx.room.RoomDatabase</span>() &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">userDao</span><span class="hljs-params">()</span></span>: UserDao<br>&#125;<br></code></pre></td></tr></table></figure><p>数据库对象需要使用<code>@Database</code>注解，并且声明参数<code>version</code>和<code>entities</code>。<code>version</code>代表的是数据库的版本号，每次数据库表有改动的时候，都需要增加版本号并且添加对应的<code>Migration</code>。<code>entities</code>是一个数组，内容是每个表所对应的实体类。</p><p><code>@TypeConverter</code>是可选的，参数是一个<code>TypeConverter</code>数组，只有添加了类型转换器的时候才需要添加该注解。类型转换器在上面<code>定义表结构-&gt;表的数据类型-&gt;类型转换</code>一节有说过。</p><p>抽象类中还需要声明一些抽象方法，这些方法不需要参数，只要声明返回值为对应的<code>Dao</code>就行。</p><h3 id="创建数据库以及对应的Dao"><a href="#创建数据库以及对应的Dao" class="headerlink" title="创建数据库以及对应的Dao"></a>创建数据库以及对应的Dao</h3><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"> <span class="hljs-keyword">val</span> db = Room.databaseBuilder(<span class="hljs-keyword">this</span>, CustomDatabase::<span class="hljs-keyword">class</span>.java, <span class="hljs-string">&quot;user.sqlite.db&quot;</span>)<br>            .allowMainThreadQueries()<br>            .build()<br><br><span class="hljs-keyword">val</span> userDao = db.userDao()<br></code></pre></td></tr></table></figure><p>使用<code>Builder</code>模式创建<code>Database</code>实例，然后在获取到<code>Dao</code>实例进行数据库的操作即可。其中创建数据库的<code>databaseBuilder</code>方法接收三个参数，第一个参数是<code>Context</code>，最好传入<code>ApplicationContext</code>；第二个参数是数据库对象的具体实现类；第三个参数是数据库文件的名字。</p><p>然后便可以通过多种方法去定义数据库的行为，如设置允许主线程操作，如设置<code>Transaction</code>的线程池，如从某个文件直接读取数据库(数据库文件已存在)等等。</p><h3 id="Migration"><a href="#Migration" class="headerlink" title="Migration"></a>Migration</h3><p>数据库一旦创建，就不能再修改表结构了，也就是说<code>@Entity</code>注解的对象的属性都是不能动的了，不管是删除修改还是添加一个属性，都是不允许的。</p><p>若是需要修改的话，则需要添加相应的<code>Migration</code>，然后操作数据库表，让其与修改后的<code>@Entity</code>实例对应。</p><figure class="kotlin highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="kotlin hljs"><span class="hljs-comment">// 一开始的User类，当前数据库版本为1</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<br>	<span class="hljs-meta">@PrimaryKey</span><br>	<span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>,<br>	<span class="hljs-keyword">val</span> name: String<br>)<br><span class="hljs-meta">@Database(</span><br><span class="hljs-meta">    version = 1,</span><br><span class="hljs-meta">    entities = [User::class]</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDatabase</span> : <span class="hljs-type">androidx.room.RoomDatabase</span>() &#123;<br>    ...<br>&#125;<br><br>------------------------------------------------------------------------------<br><br><span class="hljs-comment">// 因为某些原因需要给User加一个字段sex</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<br>	<span class="hljs-meta">@PrimaryKey</span><br>	<span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>,<br>	<span class="hljs-keyword">val</span> name: String,<br>	<span class="hljs-keyword">val</span> sex: String<br>)<br><span class="hljs-comment">// 此时需要将@Database的version属性改为2或者其他大于1的数</span><br><span class="hljs-meta">@Database(</span><br><span class="hljs-meta">    version = 2,</span><br><span class="hljs-meta">    entities = [User::class]</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDatabase</span> : <span class="hljs-type">androidx.room.RoomDatabase</span>() &#123;<br>    ...<br>&#125;<br><span class="hljs-comment">// 然后创建对应Migration</span><br><span class="hljs-keyword">val</span> MIGRATION_1_2 = <span class="hljs-keyword">object</span> :Migration(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">migrate</span><span class="hljs-params">(database: <span class="hljs-type">SupportSQLiteDatabase</span>)</span></span> &#123;<br>        database.execSQL(<span class="hljs-string">&quot;alter table User add sex Text not null default &#x27;男&#x27; &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//在创建数据库的地方添加进去</span><br>db = Room.databaseBuilder(<span class="hljs-keyword">this</span>, CustomDatabase::<span class="hljs-keyword">class</span>.java, <span class="hljs-string">&quot;user.sqlite.db&quot;</span>)<br>            .allowMainThreadQueries()<br>            .addMigrations(MIGRATION_1_2)<br>            .build()<br></code></pre></td></tr></table></figure><p>注意创建的<code>Migration</code>实例有两个参数，第一个是升级前的数据库版本，第二个参数是升级后的版本。可以在<code>migrate</code>方法中通过<code>database</code>执行<code>sql</code>语句去执行数据库的改变，这需要有一定的<code>SQL</code>语言基础。</p><p>如上例，添加了一个<code>sex</code>列，则在<code>migrate</code>中也使用<code>SQL</code>去添加了一个列来对应。注意若是新增的字段是非空的，则在<code>SQL</code>语句中也要声明为非空的，并且设置默认值（对应的字段上可以不用去声明默认值了）。</p><p>所以每次更改字段都必须升级数据库并且添加Migration，所以在开发阶段，每次修改字段后，直接卸载应用然后重新安装会更加方便。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Room</code>是一个数据库框架，使用它，可以让我们不用再将精力放在各种基本操作中，而是只专注于数据库表以及<code>Dao</code>。</p><p>并且<code>Room</code>的使用非常简单，仅需一些注解就能完成各种任务，与协程和<code>LiveData</code>和<code>Flow</code>紧密相连，使得使用更加方便。</p><p><code>Room</code>使用的是编译时处理注解的技术，不会影响运行的效率。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Thu Aug 05 2021 22:00:55 GMT+0800");let n="Thu Aug 05 2021 22:00:55 GMT+0800";n="2024-07-28 19:47:02 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Third-Libraries/" class="post-footer-category">#&nbsp;Third Libraries</a> <a href="/tags/Jetpack/" class="post-footer-tag">#&nbsp;Jetpack</a></div><div class="nav"><div class="nav-item-prev"><a href="/2021/09/06/use-bsdiff-to-ugrade/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">在Android中使用Bsdiff实现增量更新</div></div></a></div><div class="nav-item-next"><a href="/2021/06/06/di-hilt/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">好用的依赖注入框架-Hilt</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Room%E7%AE%80%E4%BB%8B" class="toc-link"><span class="toc-text">Room简介</span></a></li><li class="toc-item toc-level-2"><a href="#%E4%BE%9D%E8%B5%96%E6%B7%BB%E5%8A%A0" class="toc-link"><span class="toc-text">依赖添加</span></a></li><li class="toc-item toc-level-2"><a href="#%E5%AE%9A%E4%B9%89%E8%A1%A8%E7%BB%93%E6%9E%84" class="toc-link"><span class="toc-text">定义表结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E8%A1%A8%E5%B1%9E%E6%80%A7" class="toc-link"><span class="toc-text">表属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E8%A1%A8%E5%90%8D%E7%A7%B0" class="toc-link"><span class="toc-text">表名称</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%88%97%E5%90%8D" class="toc-link"><span class="toc-text">列名</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%BF%BD%E7%95%A5%E7%9A%84%E5%B1%9E%E6%80%A7" class="toc-link"><span class="toc-text">忽略的属性</span></a></li><li class="toc-item toc-level-4"><a href="#%E4%B8%BB%E9%94%AE" class="toc-link"><span class="toc-text">主键</span></a></li><li class="toc-item toc-level-4"><a href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E5%88%97" class="toc-link"><span class="toc-text">索引和唯一列</span></a></li><li class="toc-item toc-level-4"><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC" class="toc-link"><span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%A4%96%E9%94%AE" class="toc-link"><span class="toc-text">外键</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F" class="toc-link"><span class="toc-text">外键约束</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="toc-link"><span class="toc-text">表的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="toc-link"><span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-5"><a href="#%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1" class="toc-link"><span class="toc-text">嵌套对象</span></a></li><li class="toc-item toc-level-5"><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" class="toc-link"><span class="toc-text">类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a href="#%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB" class="toc-link"><span class="toc-text">表的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E4%B8%80%E5%AF%B9%E4%B8%80" class="toc-link"><span class="toc-text">一对一</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F" class="toc-link"><span class="toc-text">查询方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#%E4%B8%80%E5%AF%B9%E5%A4%9A" class="toc-link"><span class="toc-text">一对多</span></a></li><li class="toc-item toc-level-4"><a href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A" class="toc-link"><span class="toc-text">多对多</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a href="#%E5%88%9B%E5%BB%BADAO" class="toc-link"><span class="toc-text">创建DAO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#Insert" class="toc-link"><span class="toc-text">Insert</span></a></li><li class="toc-item toc-level-3"><a href="#Delete%E3%80%81Update" class="toc-link"><span class="toc-text">Delete、Update</span></a></li><li class="toc-item toc-level-3"><a href="#Query" class="toc-link"><span class="toc-text">Query</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#%E4%BD%BF%E7%94%A8" class="toc-link"><span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%BA%93" class="toc-link"><span class="toc-text">定义数据库</span></a></li><li class="toc-item toc-level-3"><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84Dao" class="toc-link"><span class="toc-text">创建数据库以及对应的Dao</span></a></li><li class="toc-item toc-level-3"><a href="#Migration" class="toc-link"><span class="toc-text">Migration</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-01-02</div><a href="/2024/01/02/navigation/"><div class="recent-posts-item-content">在Compose中使用Navigation</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-06-06</div><a href="/2021/06/06/di-hilt/"><div class="recent-posts-item-content">好用的依赖注入框架-Hilt</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-10-05</div><a href="/2023/10/05/ffmpeg2/"><div class="recent-posts-item-content">FFmpeg解封装与重封装</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-02-20</div><a href="/2024/02/20/generics/"><div class="recent-posts-item-content">Java泛型</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-01-02</div><a href="/2024/01/02/navigation/"><div class="recent-posts-item-content">在Compose中使用Navigation</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>