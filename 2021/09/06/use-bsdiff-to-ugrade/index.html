<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>在Android中使用Bsdiff实现增量更新</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>27</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>15</span> <span>标签</span> </a><a class="author-word-count"><span>11.22</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#%E7%BC%96%E8%AF%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BD%BF%E7%94%A8%E7%9A%84bsdiff" class="toc-link"><span class="toc-text">编译服务端使用的bsdiff</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81" class="toc-link"><span class="toc-text">下载源码</span></a></li><li class="toc-item toc-level-3"><a href="#%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91" class="toc-link"><span class="toc-text">开始编译</span></a></li><li class="toc-item toc-level-3"><a href="#%E7%94%9F%E6%88%90%E5%B7%AE%E5%88%86%E6%96%87%E4%BB%B6" class="toc-link"><span class="toc-text">生成差分文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#%E5%9C%A8Android%E4%B8%AD%E4%BD%BF%E7%94%A8bspatch%E5%90%88%E6%88%90%E5%AE%89%E8%A3%85%E5%8C%85" class="toc-link"><span class="toc-text">在Android中使用bspatch合成安装包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%BC%95%E5%85%A5%E6%BA%90%E6%96%87%E4%BB%B6" class="toc-link"><span class="toc-text">引入源文件</span></a></li><li class="toc-item toc-level-3"><a href="#%E7%BC%96%E5%86%99CMakeLists-txt" class="toc-link"><span class="toc-text">编写CMakeLists.txt</span></a></li><li class="toc-item toc-level-3"><a href="#%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81" class="toc-link"><span class="toc-text">编写代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">5</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="在Android中使用Bsdiff实现增量更新 thumbnail" class="image lozad" src="/img/cover/cover-bsdiff.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">在Android中使用Bsdiff实现增量更新</h1></header><div class="post-meta post-show-meta"><time datetime="2021-09-06T13:07:51.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2021-09-06</span> </time><span class="dot"></span> <a href="/categories/Third-Libraries/" class="post-meta-link">Third Libraries </a><span class="dot"></span> <span>约2.5k 字</span></div><div class="post-content" id="section"><p>在<code>Android</code>中，我们应用内更新软件通常是下载完整的安装包，然后进行安装。但是当安装包很大的时候，每次更新都会让用户不爽，因为不仅会消耗很多流量，而且当用户网络不是很好的时候，更新就会很慢，而且会影响到用户体验，比如下载期间占用带宽导致加载图片缓慢等。因此，用户很可能会拒绝更新。</p><p><code>bsdiff</code>就是一种差量算法，可以根据两个文件间的区别生成一份差量文件，然后根据旧文件和差量文件重新生成新文件。应用在<code>Android</code>中是这样的：用户安装的是<code>v1.0</code>版本，然后当更新<code>v2.0</code>版本时，服务端根据<code>v1.0</code>和<code>v2.0</code>生成一个差量包<code>patch</code>，然后用户提示更新的时候去下载<code>patch</code>，再在本地根据已安装的版本<code>v1.0</code>和<code>patch</code>合成<code>v2.0</code>版本然后进行安装更新。</p><h2 id="编译服务端使用的bsdiff"><a href="#编译服务端使用的bsdiff" class="headerlink" title="编译服务端使用的bsdiff"></a>编译服务端使用的bsdiff</h2><p>在服务端，是可以直接安装<code>bsdiff</code>的，但是为了保持<code>bsdiff</code>版本与应用中的版本的一致，因此采用自己编译的方式。</p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>首先下载<code>bsdiff</code>的源码：<a href="http://www.daemonology.net/bsdiff/" rel="noopener" target="_blank">官网地址</a> ，但是官网下载的时候居然提示403。因此我上传了一份到<code>github</code>上，可以从<a href="https://github.com/pgaofeng/BsPatch/releases/tag/bsdiff4.3" rel="noopener" target="_blank">github下载</a>或者从<a href="https://src.fedoraproject.org/lookaside/pkgs/bsdiff/bsdiff-4.3.tar.gz/e6d812394f0e0ecc8d5df255aa1db22a/" rel="noopener" target="_blank">这里下载</a>。</p><p>然后下载<code>bzip2</code>的源码：从<a href="https://sourceforge.net/projects/bzip2/" rel="noopener" target="_blank">SourceForge下载</a>，因为bsdiff需要使用到bzip2。</p><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p><code>Windows</code>编译是很麻烦的，缺少相应的环境和工具，并且<code>bsdiff</code>中还引用了一些<code>Linux</code>中的头文件。所以这里选择在<code>Linux</code>中编译。</p><p>首先解压<code>bsdiff</code>和<code>bzip2</code>，并将二者置于同一个目录中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.<br>├── bsdiff-4.3<br>│   ├── bsdiff.1<br>│   ├── bsdiff.c<br>│   ├── bspatch.1<br>│   ├── bspatch.c<br>│   └── Makefile<br>├── bzip2-1.0.6<br>...<br></code></pre></td></tr></table></figure><p>然后修改<code>bsdiff</code>中的<code>Makefile</code>，因为<code>bsdiff</code>引用了<code>bzip2</code>的头文件和库文件，所以需要将搜索路径指向我们解压后的<code>bzip2-1.0.6</code>。同时，<code>Makefile</code>中还有一些格式问题，同样需要修改。修改后的Makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile">BZIP2PATH=../bzip2-1.0.6<br>CC=gcc<br><br>CFLAGS          +=      -O3 -lbz2 -L$&#123;BZIP2PATH&#125; -I $&#123;BZIP2PATH&#125;<br>  <br>PREFIX          ?=      /usr/local<br>INSTALL_PROGRAM ?=      $&#123;INSTALL&#125; -c -s -m 555<br>INSTALL_MAN     ?=      $&#123;INSTALL&#125; -c -m 444<br><br><span class="hljs-section">all:            bsdiff bspatch</span><br><span class="hljs-section">bsdiff:         bsdiff.c</span><br>	<span class="hljs-variable">$(CC)</span> bsdiff.c <span class="hljs-variable">$(CFLAGS)</span> -o bsdiff<br><span class="hljs-section">bspatch:        bspatch.c</span><br>	<span class="hljs-variable">$(CC)</span> bspatch.c <span class="hljs-variable">$(CFLAGS)</span> -o bspatch<br><br><span class="hljs-section">install:</span><br>        $&#123;INSTALL_PROGRAM&#125; bsdiff bspatch $&#123;PREFIX&#125;/bin<br>        .<span class="hljs-keyword">ifndef</span> WITHOUT_MAN<br>        $&#123;INSTALL_MAN&#125; bsdiff.1 bspatch.1 $&#123;PREFIX&#125;/man/man1<br>        .<span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>改动不是很多，首先加了一个<code>BZIP2PATH</code>参数并指向<code>bzip2</code>的路径，然后在<code>CFLAGS</code>中指定库文件搜索目录<code>-L$&#123;BZIP2PATH&#125;</code>和头文件搜索路径<code>-I $&#123;BZIP2PATH&#125;</code>为<code>bzip2</code>路径。其次是指定了编译器为<code>gcc</code>，并且给<code>bsdiff</code>和<code>bspatch</code>添加了明确的生成的命令。最后是在<code>install</code>命令中的<code>.ifndef</code>和<code>.endif</code>前加了个<code>tab</code>缩进。</p><p>在<code>CFLAGS</code>中，使用<code>-lbz2</code>链接了<code>bz2</code>库，所以需要先生成<code>libbz2.a</code>。切到<code>bzip2-1.0.6</code>目录中，然后执行命令：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 因为只需要libbz2.a，所以其他的不需要编译</span><br>make libbz2.a<br></code></pre></td></tr></table></figure><p>此时在<code>bzip2-1.0.6</code>中可以看到生成了<code>libbz2.a</code>文件，然后切回<code>bsdiff-4.3</code>目录中执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">make<br></code></pre></td></tr></table></figure><p>这时候，在<code>bsdiff-4.3</code>目录中就会生成<code>bsdiff</code>和<code>bspatch</code>两个可执行文件了。实际上我们是不需要<code>bspatch</code>这个可执行文件的，因为合成步骤是在手机上完成的，服务端只需要使用<code>bsdiff</code>去生成<code>patch</code>差分文件即可。</p><p>所以可以使用命令：<code>make bsdiff</code>仅生成<code>bsdiff</code>可执行文件。</p><h3 id="生成差分文件"><a href="#生成差分文件" class="headerlink" title="生成差分文件"></a>生成差分文件</h3><p>使用刚才编译出的<code>bsdiff</code>去生成差分文件，后接三个参数，第一个是旧版本的文件，第二个是新版本的文件，第三个是生成的差分文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bsdiff app-v1.apk app-v2.apk patch<br></code></pre></td></tr></table></figure><p>执行上述命令后就会生成<code>patch</code>文件，这个<code>patch</code>文件应该是小于<code>app-v2.apk</code>的。当更新时，用户只需要下载<code>patch</code>文件即可。以上就是整个服务端需要做的事了，就是编译<code>bsdiff</code>，然后生成差分文件。</p><h2 id="在Android中使用bspatch合成安装包"><a href="#在Android中使用bspatch合成安装包" class="headerlink" title="在Android中使用bspatch合成安装包"></a>在Android中使用bspatch合成安装包</h2><p><code>bspatch</code>是用于合成安装包的可执行文件。前面使用<code>bsdiff</code>将旧版本和新版本比较产生<code>patch</code>文件，这里的<code>bspatch</code>就是将旧版本和<code>patch</code>合并成新版本文件，与<code>bsdiff</code>是一个对应的过程，也是<code>Android</code>上主要使用的方法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 参数顺序和bsdiff是一样的</span><br>./bspatch apk-v1.apk apk-v2.apk patch<br></code></pre></td></tr></table></figure><h3 id="引入源文件"><a href="#引入源文件" class="headerlink" title="引入源文件"></a>引入源文件</h3><p>在<code>Android</code>中使用也是比较简单的，首先新建一个<code>native</code>项目或者<code>nativelib</code>。然后在<code>src/main/cpp</code>目录下，创建一个目录<code>bzip2-1.0.6</code>。将对应的<code>bzip2</code>源文件放在这里。</p><p>注意，并不需要放入<code>bzip2</code>解压后的所有文件，而是生成<code>libbz2.a</code>相关的源文件即可。可以在<code>bzip2-1.0.6</code>解压后的目录中查看Makefile文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OBJS= blocksort.o  \<br>      huffman.o    \<br>      crctable.o   \<br>      randtable.o  \<br>      compress.o   \<br>      decompress.o \<br>      bzlib.o<br><br><span class="hljs-section">libbz2.a: <span class="hljs-variable">$(OBJS)</span></span><br>        rm -f libbz2.a<br>        <span class="hljs-variable">$(AR)</span> cq libbz2.a <span class="hljs-variable">$(OBJS)</span><br>        <br><span class="hljs-section">blocksort.o: blocksort.c</span><br>        @cat words0<br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c blocksort.c<br><span class="hljs-section">huffman.o: huffman.c</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c huffman.c<br><span class="hljs-section">crctable.o: crctable.c</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c crctable.c<br><span class="hljs-section">randtable.o: randtable.c</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c randtable.c<br><span class="hljs-section">compress.o: compress.c</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c compress.c<br><span class="hljs-section">decompress.o: decompress.c</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c decompress.c<br><span class="hljs-section">bzlib.o: bzlib.c</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c bzlib.c<br></code></pre></td></tr></table></figure><p>上面是从<code>Makefile</code>中截取的一部分，从中可以看出我们需要<code>blocksort.c、huffman.c、crctable.c、randtable.c、compress.c、decompress.c、bzlib.c</code>七个文件，同时还需要两个头文件<code>bzlib.h</code>和<code>bzlib_private.h</code>。也就是一共<strong>9</strong>个文件，放入上述新建的<code>zip2-1.0.6</code>目录中。然后将<code>bsdiff</code>解压后的<code>bspatch.c</code>放入<code>src/main/cpp</code>中。</p><p>现在的目录结构应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.<br>├── src<br>│   ├── main<br>│   	├── cpp<br>│   		├── bzip2-1.0.6<br>|			├── bspatch.c<br>│   		├── nativelib.cpp<br>│   		└── CMakeLists.txt<br>├<br>...<br></code></pre></td></tr></table></figure><p>其中<code>nativelib.cpp</code>是新建<code>module</code>的时候自动生成的，可以修改成其他文件名，比如这里我就修改成了<code>bspatch_merge.cpp</code>。</p><h3 id="编写CMakeLists-txt"><a href="#编写CMakeLists-txt" class="headerlink" title="编写CMakeLists.txt"></a>编写CMakeLists.txt</h3><p>然后编写<code>CMakeLists.txt</code>规则，将<code>bzip2</code>的源文件以及<code>bspatch</code>的源文件都添加进去：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>.<span class="hljs-number">2</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-string">&quot;bspatch&quot;</span>)<br><br><span class="hljs-keyword">file</span>(GLOB bzip_sources <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bzip2-<span class="hljs-number">1.0</span>.<span class="hljs-number">6</span>/*.c)<br><br><span class="hljs-keyword">add_library</span>(<br>    bspatch<br>    SHARED<br><br>    bspatch.c<br>    bspatch_merge.cpp<br>    <span class="hljs-variable">$&#123;bzip_sources&#125;</span><br>)<br><br><br><span class="hljs-keyword">find_library</span>(<br>    log-lib<br>    log<br>)<br><br><br><span class="hljs-keyword">target_link_libraries</span>(<br>    bspatch<br>    <span class="hljs-variable">$&#123;log-lib&#125;</span><br>)<br></code></pre></td></tr></table></figure><p>在<code>bspatch.c</code>中，入口方法也就是<code>main</code>函数，因为在<code>Linux</code>下最终是将<code>bspatch.c</code>编译成可执行文件的。而在<code>Android</code>中，我们最终是将它编译成一个共享库<code>so</code>，因此最好将<code>main</code>函数重命名一下，避免以后添加其他库的时候又有<code>main</code>函数导致冲突。这里将其改为<code>patch_main</code>。<br>并且，还需要将<code>bspatch.c</code>中引用的头文件<code>#include&lt;bzlib.h&gt;</code>改为<code>#include &quot;bzip2-1.0.6/bzlib.h&quot;</code></p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>然后将<code>NativeLib</code>类重命名，改为<code>PatchUtils</code>，并定义成一个单例类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> PatchUtils &#123;<br><br>	<span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-comment">// 这里的名字必须与CMakeLists.txt中的add_library中定义的一致</span><br>        System.loadLibrary(<span class="hljs-string">&quot;bspatch&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注意，该方法是一个耗时操作，不要放到主线程中去。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 根据旧文件和差分包文件合并成新的文件</span><br><span class="hljs-comment">     * [newFile] 合并后的文件，应该是一个具体的文件路径</span><br><span class="hljs-comment">     * [oldFile] 旧文件的路径，应该是一个具体的文件路径</span><br><span class="hljs-comment">     * [patch]   差分包文件，应该是一个具体的文件路径</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 合并成功则返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bsPatch</span><span class="hljs-params">(newFile: <span class="hljs-type">String</span>, oldFile: <span class="hljs-type">String</span>, patch: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时<code>bsPatch</code>方法应该是报红色错误的，鼠标放在上面根据提示可以直接生成<code>jni</code>方法，选择生成文件位置的时候记得选择<code>bspatch.c</code>中。或者不让他生成，直接在<code>bspatch.c</code>中手写即可，这样的话需要注意方法中的包名和类名要保持一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jni.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">patch_main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span>;<br>&#125;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-function">JNIEXPORT jboolean JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_study_bspatch_PatchUtils_bsPatch</span><span class="hljs-params">(JNIEnv *env, jobject thiz, jstring new_file,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          jstring old_file, jstring patch_file)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newFile = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(new_file, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldFile = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(old_file, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *patchFile = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(patch_file, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">char</span> *argv[] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(oldFile), <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(newFile),<br>                    <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(patchFile)&#125;;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">patch_main</span>(<span class="hljs-number">4</span>, argv);<br><br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(old_file, oldFile);<br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(new_file, newFile);<br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(patch_file, patchFile);<br><br>    <span class="hljs-keyword">return</span> res == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先通过<code>extern</code>关键字引入<code>bspatch.c</code>中的<code>patch_main</code>方法，然后调用。在可执行文件中，我们使用<code>./bspatch old.apk new.apk patch</code>命令去生成新文件，而对应的方法中，参数实际上是4个，因为第一个参数是函数本身，这里是需要注意的。</p><p>到这里就已经完成了<code>Android</code>中的引入了，使用的时候直接调用<code>PatchUtils.bsPatch</code>方法即可。当前安装的<code>apk</code>可以通过<code>context.applicationInfo.sourceDir</code>去获取。</p><p>详细代码上传至<a href="https://github.com/pgaofeng/BsPatch" rel="noopener" target="_blank">github仓库</a>上了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用<code>bsdiff</code>进行安装包的增量更新并不难，甚至可以说是非常简单，因为我们实际上在<code>Android</code>中仅仅是去调用<code>bspatch</code>中的<code>main</code>方法去合成而已。同样的，Linux编译<code>bsdiff</code>也很简单，只是稍微修改一下<code>Makefile</code>就行了。</p><p>使用<code>bsdiff</code>可以有效的降低更新时下载的安装包的体积，因为只需要下载对应的<code>patch</code>分包即可，而不需要下载完整的安装包文件，这也是我们最终的目的。</p><p>但是，实际使用中却很麻烦，因为每次更新后，都需要和之前的所有旧版本<code>apk</code>生成对应的<code>patch</code>分包，然后在获取更新信息的时候，根据传递的版本参数返回对应的<code>patch</code>下载地址。</p><p>这只是一个渠道包的情况，实际上我们线上每个应用商店上传的包都是不同的渠道包，而各个应用商店大概有十来个。也就是说，每次升级，至少要产生十几个<code>patch</code>分包，并且这还只是和一个旧版本<code>apk</code>产生的，而实际中，我们又非常多的旧版本，这也就意味着，<code>patch</code>分包的文件数量将会非常多…</p><p>当然，可以编写脚本文件来管理….</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Mon Sep 06 2021 21:07:51 GMT+0800");let n="Mon Sep 06 2021 21:07:51 GMT+0800";n="2024-07-28 19:47:02 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Third-Libraries/" class="post-footer-category">#&nbsp;Third Libraries</a> <a href="/tags/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/" class="post-footer-tag">#&nbsp;增量更新</a> <a href="/tags/bsdiff/" class="post-footer-tag">#&nbsp;bsdiff</a></div><div class="nav"><div class="nav-item-prev"><a href="/2021/11/02/coordinatorlayout-behavior/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">CoordinatorLayout的秘密之Behavior</div></div></a></div><div class="nav-item-next"><a href="/2021/08/05/database-room/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">将Room的使用方式塞到脑子里</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#%E7%BC%96%E8%AF%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BD%BF%E7%94%A8%E7%9A%84bsdiff" class="toc-link"><span class="toc-text">编译服务端使用的bsdiff</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81" class="toc-link"><span class="toc-text">下载源码</span></a></li><li class="toc-item toc-level-3"><a href="#%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91" class="toc-link"><span class="toc-text">开始编译</span></a></li><li class="toc-item toc-level-3"><a href="#%E7%94%9F%E6%88%90%E5%B7%AE%E5%88%86%E6%96%87%E4%BB%B6" class="toc-link"><span class="toc-text">生成差分文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#%E5%9C%A8Android%E4%B8%AD%E4%BD%BF%E7%94%A8bspatch%E5%90%88%E6%88%90%E5%AE%89%E8%A3%85%E5%8C%85" class="toc-link"><span class="toc-text">在Android中使用bspatch合成安装包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%BC%95%E5%85%A5%E6%BA%90%E6%96%87%E4%BB%B6" class="toc-link"><span class="toc-text">引入源文件</span></a></li><li class="toc-item toc-level-3"><a href="#%E7%BC%96%E5%86%99CMakeLists-txt" class="toc-link"><span class="toc-text">编写CMakeLists.txt</span></a></li><li class="toc-item toc-level-3"><a href="#%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81" class="toc-link"><span class="toc-text">编写代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2021-08-05</div><a href="/2021/08/05/database-room/"><div class="recent-posts-item-content">将Room的使用方式塞到脑子里</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-06-06</div><a href="/2021/06/06/di-hilt/"><div class="recent-posts-item-content">好用的依赖注入框架-Hilt</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-02-20</div><a href="/2021/02/20/use-okhttp-2/"><div class="recent-posts-item-content">OkHttp3整体源码分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-01-27</div><a href="/2021/01/27/use_okhttp/"><div class="recent-posts-item-content">OkHttp3的简单使用</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-08-27</div><a href="/2023/08/27/overscroll/"><div class="recent-posts-item-content">View自定义回弹动效</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-07-11</div><a href="/2023/07/11/coroutine-2/"><div class="recent-posts-item-content">Kotlin协程的实现</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-06-05</div><a href="/2023/06/05/flow-2/"><div class="recent-posts-item-content">SharedFlow、StateFlow、SafeFlow的区别</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-05-22</div><a href="/2023/05/22/flow/"><div class="recent-posts-item-content">协程数据流Flow</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>