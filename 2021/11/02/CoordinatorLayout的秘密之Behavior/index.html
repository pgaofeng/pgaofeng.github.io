<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>CoordinatorLayout的秘密之Behavior | 没有感情的代码机器</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/img/blog.svg"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"><script type="text/javascript" src="https://code.jquery.com/jquery-3.7.1.min.js"></script><meta name="generator" content="Hexo 7.0.0"></head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script><script>hljs.addPlugin({
    "before:highlightBlock": ({ block }) => {
         block.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ /]*>/g, '\n');
    },
    "after:highlightBlock": ({ result }) => {
          result.value = result.value.replace(/\n/g, "<br>");
    }
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script type="text/javascript" src="/plugins/clipboard/clipboard.use.js" async> </script><script type="text/javascript" src="/js/ready.js" async></script><script type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js"></script><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">PGAOFENG</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">没有感情的代码机器</a></h1></div><p class="m-desc">不写bug的程序员,<br>不是一个好的程序员！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li class="m-sch"></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">CoordinatorLayout的秘密之Behavior</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2021/11/02/CoordinatorLayout%E7%9A%84%E7%A7%98%E5%AF%86%E4%B9%8BBehavior/">2021-11-02</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/Android/">Android</a>&nbsp;&bull;&nbsp;<a href="/categories/Android/Behavior/">Behavior</a></span></div></div><div class="p-content"><p><img src="/img/cover-behavior.webp" alt="cover-behavior.webp"></p>
<p>在源码的注释的第一行中有这样一句话：<code>CoordinatorLayout is a super-powered FrameLayout.</code> 也就是什么都不做的话，是可以将他当做一个简单的<code>FrameLayout</code>来使用的，当然实际上我们肯定不会这样去使用的。从名字可以看到，<code>CoordinatorLayout</code>是一个协调布局、协作布局。即作为一个控制者，处理子View之间的交互关系。</p>
<p><code>CoordinatorLayout</code>是用于操控子View的行为模式的，它将操控的能力全部抽取出来，组成一个静态内部类<code>Behavior</code>，通过<code>Behavior</code>来实现操控能力，也更方便拓展。因此，<code>CoordinatorLayout</code>必须搭配<code>Behavior</code>来使用，否则失去操控能力的它就变得及其简单，也就是源码注释中说的<code>super-powered FrameLayout</code>。</p>
<h2 id="Behavior的能力"><a href="#Behavior的能力" class="headerlink" title="Behavior的能力"></a>Behavior的能力</h2><p><code>CoordinatorLayout</code>将其所支持的各种功能都抽象出来，作为一个插件标准，所有人都可以依据这个插件标准，来使用它的各种能力。这个插件标准就是<code>Behavior</code></p>
<p>说白了Android原生View之间的各种花样也不过布局绘制、事件操作等。而<code>CoordinatorLayout</code>所实现的就是一些常用的功能，如<strong>依赖关系</strong>、<strong>测量布局</strong>、<strong>Touch事件</strong>、<strong>嵌套滑动</strong>。</p>
<h3 id="如何使用设置Behavior"><a href="#如何使用设置Behavior" class="headerlink" title="如何使用设置Behavior"></a>如何使用设置Behavior</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Behavior</span>&lt;V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span>&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Behavior</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Behavior</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Behavior</code>有两个构造方法，一个是空参数的构造方法，一个是双参数的构造方法。对于熟悉自定义<code>View</code>的我们而言，双参数的构造方法一看就是对应从<code>xml</code>中实例化出来的。事实确实如此，空参数的构造方法一般都是手动去创建实例然后设置，而双参数的一般都是直接在<code>xml</code>中设置。</p>
<p>注意：</p>
<ul>
<li><p>**一个子<code>View</code>只能设置一个<code>Behavior</code>**。</p>
</li>
<li><p><strong>泛型V表示的是该Behavior可用于的类型，例如设置为<code>ImageView</code>，则实例化的<code>Behavior</code>只能用于<code>ImageView</code>。</strong></p>
</li>
</ul>
<h4 id="xml中设置"><a href="#xml中设置" class="headerlink" title="xml中设置"></a>xml中设置</h4><p>直接在<code>xml</code>中通过<code>app:layout_behavior=&quot;xxx&quot;</code>给某个子view设置<code>Behavior</code>，其中<code>xxx</code>表示的是<code>Behavior</code>的类名。可以是缩略的如<code>.MyBehavior</code>，也可以是完整的如<code>com.xx.test.MyBehavior</code>。<strong>建议使用完整包名</strong>，毕竟当在<code>xml</code>中重定义<code>package</code>的时候，使用缩略名称会导致出错。</p>
<p>当通过xml声明的方式去设置<code>Behavior</code>的时候，会走双参数的构造方法，此时，可以通过xml属性向其设置参数，使用方式和自定义View的自定义属性是一样的。</p>
<ul>
<li>1，在<code>attrs.xml</code>中定义属性和名称，和自定义<code>view</code>的做法一致</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MovableButton_Behavior&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;string&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>2，在<code>xml</code>中设置这个属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/image&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">&quot;.behavior.AttrBehavior&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:sex</span>=<span class="hljs-string">&quot;aaaa&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>在<code>Behavior</code>构造方法中读取属性</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AttrBehavior</span>(<br>    context: Context,<br>    attributeSet: AttributeSet<br>) : CoordinatorLayout.Behavior&lt;View&gt;(context, attributeSet) &#123;<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        context.obtainStyledAttributes(attributeSet, R.styleable.MovableButton_Behavior).use &#123;<br>            <span class="hljs-keyword">val</span> sex = it.getString(R.styleable.MovableButton_Behavior_sex)<br>            println(<span class="hljs-string">&quot;xml中设置的app:sex属性值为：<span class="hljs-variable">$sex</span>&quot;</span>)<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="直接创建实例"><a href="#直接创建实例" class="headerlink" title="直接创建实例"></a>直接创建实例</h4><p>若是不在xml中设置的话，则需要手动创建，然后设置给对应的View。这种方式稍微复杂一点点：需要首先拿到想要设置的Behavior的View，然后获取其布局属性<code>CoordinatorLayout.LayoutParams</code>，然后通过<code>setBehavior</code>方式设置。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setContentView(R.layout.activity_main)<br>    <span class="hljs-keyword">val</span> textView:TextView = findViewById(R.id.textView)<br>    <span class="hljs-keyword">val</span> params = textView.layoutParams<br>    <span class="hljs-keyword">if</span> (params <span class="hljs-keyword">is</span> CoordinatorLayout.LayoutParams) &#123;<br>        <span class="hljs-comment">// 设置Behavior</span><br>        params.behavior = AttrBehavior()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="通过默认的Behavior设置"><a href="#通过默认的Behavior设置" class="headerlink" title="通过默认的Behavior设置"></a>通过默认的Behavior设置</h4><p>使用默认的设置，就是没有使用前两种方式设置的话才会使用默认的。以前是通过注解的方式去设置，这种方式需要自定义View，然后在其类名上通过<code>@DefaultBehavior</code>进行注解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@DefaultBehavior(AttrBehavior::class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovableButton</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context,<br>    attr: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyle: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : AppCompatButton(context, attr, defStyle)<br></code></pre></td></tr></table></figure>

<p>注意：注解方式已经被标记为<code>Deprecated</code>，不再推荐使用了，现在推荐使用接口的方式来实现，即自定义的View通过实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AttachedBehavior</span> &#123;<br>    <span class="hljs-meta">@NonNull</span> Behavior <span class="hljs-title function_">getBehavior</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Behavior的功能"><a href="#Behavior的功能" class="headerlink" title="Behavior的功能"></a>Behavior的功能</h3><p><code>CoordinatorLayout</code>抽取的比较狠，它将所有的操作都抽取到了<code>Behavior</code>中，本身基本上没有什么特殊功能了。也就是说如果离了<code>Behavior</code>，它就是一个<code>FrameLayout</code>了。</p>
<h4 id="测量和布局"><a href="#测量和布局" class="headerlink" title="测量和布局"></a>测量和布局</h4><p>一个<code>View</code>的显示，通常经历三个步骤：测量、布局、绘制。而在<code>Behavior</code>中也能实现前两个步骤，这是因为<code>CoordinatorLayout</code>将其对子<code>View</code>的测量和布局的过程放在了<code>Behavior</code>中。它本身对于子View的布局就是单纯的叠加，也就是<code>FrameLayout</code>那样，如果想要特殊的测量和布局的话，则需要在<code>Behavior</code>中自己去实现了。</p>
<p>测量和布局对应的方法名称和<code>View</code>的方法非常类似，直接在<code>Behavior</code>中重写这两个方法实现自定义测量和布局，然后返回<code>true</code>即可。注意，<strong>必须返回true</strong>，否则当前自定义不会生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">onMeasureChild</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> parentWidthMeasureSpec,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> widthUsed,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> parentHeightMeasureSpec, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> heightUsed</span><br><span class="hljs-params">)</span><br>    <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">onLayoutChild</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> layoutDirection</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p>相对而言，自定义测量<code>onMeasureChild</code>用的较少，因为默认情况下父布局会像<code>FrameLayout</code>那样去测量子<code>View</code>，这种测量方式基本上已经够用了，而<code>onLayoutChild</code>用的会多一些。</p>
<p>查看下面的实例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LayoutBehavior</span>(<br>    context: Context,<br>    attr: AttributeSet<br>) : Behavior&lt;ImageView&gt;(context, attr) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayoutChild</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        parent: <span class="hljs-type">CoordinatorLayout</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        child: <span class="hljs-type">ImageView</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        layoutDirection: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">var</span> target: Button? = <span class="hljs-literal">null</span><br>        <span class="hljs-comment">// 遍历子View，查找第一个类型为Button的子View</span><br>        <span class="hljs-keyword">for</span> (index <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.parent.childCount) &#123;<br>            <span class="hljs-keyword">if</span> (parent.getChildAt(index) <span class="hljs-keyword">is</span> Button) &#123;<br>                target = parent.getChildAt(index) <span class="hljs-keyword">as</span> Button<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 将应用了Behavior的子View放置在第一个Button的右下方</span><br>            child.layout(<br>                target.right,<br>                target.bottom,<br>                target.right + child.measuredWidth,<br>                target.bottom + child.measuredHeight<br>            )<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后在<code>xml</code>中，使用这个<code>Behavior</code>即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;HardcodedText&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;30dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#00FF00d&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">&quot;com.example.viewdemo.LayoutBehavior&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后运行即可看到<code>ImageView</code>被放置在了<code>Button</code>的右下角：</p>
<p><img src="/img/behavior-layout.png" alt="behavior-layout.png"></p>
<h4 id="布局依赖"><a href="#布局依赖" class="headerlink" title="布局依赖"></a>布局依赖</h4><p><code>Behavior</code>可以实现两个子<code>View</code>之间的布局依赖的关系，当被依赖的<code>View</code>发生位置尺寸的变化或者被移除时，另一个<code>View</code>也会触发相应的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">layoutDependsOn</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View dependency</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p>首先，在<code>Behavior</code>中通过<code>layoutDependsOn</code>方法来确定依赖关系。方法的第三个参数就是需要依赖的View，该方法会调用多次，也就是说<code>Behavior</code>会遍历除了<code>child</code>外的其他<code>view</code>，然后通过这个方法去判断其是否是child的依赖。</p>
<p>例如<code>parent</code>有三个子<code>View</code>，其中有一个<code>View</code>设置了<code>Behavior</code>，那么<code>layoutDependsOn</code>方法会被调用两次，其中<code>parent</code>和<code>child</code>参数不变，每次变的是<code>dependency</code>参数。当返回true时，会记录该View，作为其依赖项，因此，<strong>依赖关系是一对多的</strong>。</p>
<blockquote>
<p>注意，在Behavior中，都是用parent代表父布局，child代表设置了Behavior的子View</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onDependentViewChanged</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View dependency</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p><code>onDependentViewChanged</code>则是依赖发生时调用的方法了，可以在这个方法中去声明<code>child</code>对依赖的响应行为。同样的，若是在这个方法中修改了<code>child</code>的尺寸或者位置，则需要返回<code>true</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDependentViewRemoved</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View dependency</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p><code>onDependentViewRemoved</code>方法是发生在被依赖的<code>View</code>从父布局中移除的时候，也就是<code>child</code>失去了一个依赖的时候调用。</p>
<p>示例：</p>
<p>首先定义一个可移动的按钮<code>MovableButton</code>，因为依赖事件发生的前提是被依赖的<code>View</code>位置或者尺寸发生变化，因此这里需要有一个可以移动位置的<code>View</code>。下面定义一个<code>MovableButton</code>，并没有什么实质内容。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 一个简单view，可以跟随手指而动</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovableButton</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context,<br>    attributeSet: AttributeSet? = <span class="hljs-literal">null</span><br>) : AppCompatButton(context, attributeSet) &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mInitX = <span class="hljs-number">0F</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mInitY = <span class="hljs-number">0F</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mEventX = <span class="hljs-number">0F</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mEventY = <span class="hljs-number">0F</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event: <span class="hljs-type">MotionEvent</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">when</span> (event?.actionMasked) &#123;<br>            MotionEvent.ACTION_DOWN -&gt; &#123;<br>                mInitX = x<br>                mInitY = y<br>                mEventX = event.rawX<br>                mEventY = event.rawY<br>            &#125;<br>            MotionEvent.ACTION_MOVE -&gt; &#123;<br>                x = mInitX + event.rawX - mEventX<br>                y = mInitY + event.rawY - mEventY<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后开始写<code>Behavior</code>，在<code>Behavior</code>中确定依赖关系并且定义相应的操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BelowBehavior</span>(<br>    context: Context,<br>    attributeSet: AttributeSet<br>) : CoordinatorLayout.Behavior&lt;View&gt;(context, attributeSet) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">layoutDependsOn</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        parent: <span class="hljs-type">CoordinatorLayout</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        child: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dependency: <span class="hljs-type">View</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    	<span class="hljs-comment">// 设置只有MovableButton才能作为被依赖View</span><br>        <span class="hljs-keyword">return</span> dependency <span class="hljs-keyword">is</span> MovableButton<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDependentViewChanged</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        parent: <span class="hljs-type">CoordinatorLayout</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        child: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dependency: <span class="hljs-type">View</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    	<span class="hljs-comment">// 让child一直处在被依赖的View下面</span><br>        child.y = dependency.height + dependency.translationY<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <br>     <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDependentViewRemoved</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        parent: <span class="hljs-type">CoordinatorLayout</span>, child: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dependency: <span class="hljs-type">View</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        <span class="hljs-comment">// 当被依赖的view被移除的时候，将child的位置重置在界面顶部</span><br>        child.y = <span class="hljs-number">0F</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意一点的是，在<code>layoutDependsOn</code>中确定依赖的条件是很简单的，只要<code>View</code>是<code>MovableButton</code>即可。实际中的条件应该更复杂一些的，因为简单的条件很容易形成多个依赖的<code>View</code>。</p>
<p>然后是在<code>xml</code>中使用<code>Behavior</code>，注意后面都是在<code>xml</code>中使用<code>Behavior</code>，因为比较简单：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.example.viewdemo.MovableButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;HardcodedText&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;30dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#00FF00&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">&quot;com.example.viewdemo.BelowBehavior&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>最后是效果图如下：</p>
<p><img src="/img/behavior-dependen.webp" alt="behavior-dependency.gif"></p>
<h4 id="事件拦截处理"><a href="#事件拦截处理" class="headerlink" title="事件拦截处理"></a>事件拦截处理</h4><p>在<code>View</code>的事件分发中，事件都是先分发给最里层的子<code>View</code>的，当子<code>View</code>决定不处理<code>touch</code>事件的时候，外层的父布局才会得到处理事件的机会。但这也不是一定的，因为父布局中有一个方法可以用来拦截事件，这样事件就会直接交给父布局进行处理，而不会传递给子<code>View</code>了。</p>
<p><code>CoordinatorLayout</code>作为一个父布局(<code>ViewGroup</code>)一定也是有这个拦截的功能的，但是同样的，它本身也没去实现拦截的机制，而是将这个功能抽取到<code>Behavior</code>中，由<code>Behavior</code>去决定<code>CoordinatorLayout</code>是否拦截此次的事件。当决定拦截了事件后，同样的<code>CoordinatorLayout</code>也不去处理这些事件，而是将这些事件传递给决定拦截事件的这些<code>Behavior</code>中，由<code>Behavior</code>去处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> MotionEvent ev</span><br><span class="hljs-params">)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> MotionEvent ev</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p>和<code>ViewGroup</code>一样的方法，通过<code>onInterceptTouchEvent</code>进行拦截，然后在<code>onTouchEvent</code>中去处理。<code>Behavior</code>是服务child的，因此这里的事件拦截也仅是为了child而拦截的。让child在事件分发之前就能提前拦截到触摸事件。</p>
<h4 id="嵌套滑动"><a href="#嵌套滑动" class="headerlink" title="嵌套滑动"></a>嵌套滑动</h4><p><code>Behavior</code>还有一个比较常用的就是嵌套滑动。嵌套滑动的设计能够将一次事件流交给多个<code>View</code>去处理，从而可以让滑动更加流畅更加符合我们的期望。它使用两套接口来实现这种功能，分别是<code>NestedScrollingChild3</code>和<code>NestedScrollingParent3</code>，对应着子<code>View</code>和父<code>View</code>，当然也可以同时实现这两个接口，这样就可以为所欲为了。</p>
<p>虽然<code>CoordinatorLayout</code>也实现了<code>NestedScrollingParent3</code>接口，但是它并不是像传统的那种嵌套滑动一样来处理滑动事件，而是将滑动事件委托给了<code>Behavior</code>，也就是在嵌套滑动中，实际上是<code>Behavior</code>来作为<code>parent</code>处理滑动事件的。也就是说，<code>CoordinatorLayout</code>中的嵌套滑动并不需要嵌套，同时，由于在嵌套滑动中作为<code>parent</code>的是<code>Behavior</code>，所以实际上想要作为<code>parent</code>的子<code>View</code>只需要设置<code>Behavior</code>即可，而不用去实现<code>NestedScrollingParent3</code>接口。</p>
<p>总之，**<code>CoordinatorLayout</code>使用嵌套滑动逻辑实现了一套不是嵌套滑动的嵌套滑动**。</p>
<blockquote>
<p>注意，嵌套滑动必须由<code>NestedScrollingChild3</code>发起，<code>RecyclerView</code>就实现了这个接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onStartNestedScroll</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View directTargetChild, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View target,</span><br><span class="hljs-params">    <span class="hljs-meta">@ScrollAxis</span> <span class="hljs-type">int</span> axes, </span><br><span class="hljs-params">    <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p>这是嵌套滑动开始的方法，当发生嵌套滑动的时候，会先调用这个方法，判断<code>Behavior</code>是否需要参与此次的滑动，返回<code>true</code>表示参与这次滑动，才会有后续的方法调用，否则后续的事件都不会再回调到这个<code>Behavior</code>中。</p>
<p>其中前两个参数不用说了，第三个参数<code>directTargetChild</code>是发生滑动的<code>View</code>在<code>CoordinatorLayout</code>中的直接子布局，而<code>target</code>表示的是发生滑动的那个<code>View</code>。当<code>target</code>直接出现在<code>CoordinatorLayout</code>中的时候，这时候的<code>directTargetChild</code>和<code>target</code>是同一个对象。如下布局中，<code>directTargetChild</code>就是<code>FrameLayout</code>，而<code>target</code>是<code>RecyclerView</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout...</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout...</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">androidx.recyclerview.widget.RecyclerView...</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br>    ...<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>最后两个参数是一个是滚动的方向，一个是滚动的类型。<code>axes</code>表示滑动的方向，有水平和垂直两种类型，取值为<code>ViewCompat#SCROLL_AXIS_HORIZONTAL</code>和<code>ViewCompat#SCROLL_AXIS_VERTICAL</code>。而<code>type</code>表示滑动的类型，有触摸滚动和非触摸滚动（惯性滚动），取值为<code>ViewCompat#TYPE_TOUCH</code>和<code>ViewCompat#TYPE_NON_TOUCH</code>。当<code>Behavior</code>想要参与此次的嵌套滑动的时候，需要返回<code>true</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNestedScrollAccepted</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View directTargetChild, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View target,</span><br><span class="hljs-params">    <span class="hljs-meta">@ScrollAxis</span> <span class="hljs-type">int</span> axes, </span><br><span class="hljs-params">    <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p><code>onNestedScrollAccepted</code>的参数和<code>onStartNestedScroll</code>是一样的，这个方法是当<code>onStartNestedScroll</code>返回<code>true</code>的时候调用的，他与<code>onStartNestedScroll</code>是绑定在一起的，每次<code>onStartNestedScroll</code>返回<code>true</code>都会调用一次这个方法。可以在该方法中去处理嵌套滑动的前置准备，如初始化状态等；当然，也可以选择在<code>onStartNestedScroll</code>就初始化状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNestedPreScroll</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View target, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> dx, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> dy, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> <span class="hljs-type">int</span>[] consumed,</span><br><span class="hljs-params">    <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type</span><br><span class="hljs-params">)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNestedScroll</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View target, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> dxConsumed, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> dyConsumed, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> dxUnconsumed,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> dyUnconsumed, </span><br><span class="hljs-params">    <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> <span class="hljs-type">int</span>[] consumed</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p>上面两个方法才是真正滑动的时候回调的方法。在发生嵌套滑动并且<code>Behavior</code>接受了这次滑动后，会先调用<code>onNestedPreScroll</code>方法。注意这个方法是发生在<code>Behavior</code>中的，也就是说，当有滑动事件的时候，是优先传递给<code>Behavior</code>去处理的。其中参数<code>dx</code>和<code>dy</code>表示的是滑动的距离，而数组<code>consumed</code>的长度为2，表示的是<code>Behavior</code>消耗的滑动距离。<code>consumed[0]</code>为对<code>dx</code>的消耗，<code>consumed[1]</code>为对<code>dy</code>的消耗，当<code>Behavior</code>消耗滑动后，需要手动的将消耗的多少填充到数组中。</p>
<p>当<code>Behavior</code>处理完后，剩余的事件会传递给<code>target</code>去处理，当然这时候的处理跟我们无关了，是由<code>target</code>本身的逻辑去处理了。而当<code>target</code>滚动结束后，剩下的事件又会传递到<code>parent</code>中进而传递给<code>Behavior</code>的<code>onNestedScroll</code>方法。该方法的中间四个参数没什么可说的，从名字就可以看出是<code>dx</code>和<code>dy</code>的已消耗的和未消耗的值。<code>consumed</code>数组也是一样的，存放消耗的事件。注意的是，此时<code>consumed</code>数据可能是已经有值的，因此我们消耗后，需要进行叠加而不是赋值。例如消耗<code>deltaY</code>，则应该<code>consumed[1] += deltaY</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onNestedPreFling</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View target, </span><br><span class="hljs-params">    <span class="hljs-type">float</span> velocityX, </span><br><span class="hljs-params">    <span class="hljs-type">float</span> velocityY</span><br><span class="hljs-params">)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onNestedFling</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> V child, </span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> View target, </span><br><span class="hljs-params">    <span class="hljs-type">float</span> velocityX, </span><br><span class="hljs-params">    <span class="hljs-type">float</span> velocityY,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> consumed</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p>当子<code>View</code>发生惯性滑动也就是<code>fling</code>的时候，同样是先传递给<code>Behavior</code>。也就是<code>onNestedPreFling</code>方法，<code>Behavior</code>需要在这个方法中去判断是否需要消耗这次的惯性滑动，若是需要的话则返回<code>true</code>。然后就是再交还给子<code>View</code>去进行判断是否需要显示<code>overScroll</code>，然后再通过<code>onNestedFling</code>传递回<code>Behavior</code>中进行真正的惯性滑动处理。其中参数<code>consumed</code>表示嵌套子<code>View</code>(发起滚动的子<code>View</code>)是否消耗此次惯性滑动，若是<code>Behavior</code>需要消耗此次滚动，则需要返回<code>true</code>。</p>
<p><em>这是<code>NestedScrollingParent</code>中的机制，而在<code>NestedScrollingParent2/3</code>中，已经取消了这种惯性滑动的处理方式，而是采用<code>Child</code>去消耗滑动，产生的滑动再次分发的形式。<strong>因此，实际上这两个方法都不用重写的，直接保持默认的实现就行了</strong>。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStopNestedScroll</span><span class="hljs-params">(</span><br><span class="hljs-params">     <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span><br><span class="hljs-params">     <span class="hljs-meta">@NonNull</span> V child, </span><br><span class="hljs-params">     <span class="hljs-meta">@NonNull</span> View target, </span><br><span class="hljs-params">     <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-type">int</span> type</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p>在滚动结束后，会调用<code>onStopNestedScroll</code>方法，可以在这个方法中去做一些收尾工作。所以嵌套滑动一共涉及到七个方法，滑动刚开始的两个方法，滑动过程中的两个方法，惯性滑动的两个方法，以及收尾的一个方法。并且，滑动事件的顺序都是<code>子View-&gt;Behavior-&gt;子View-&gt;Behavior</code>。因此滑动过程和惯性滑动过程都是两个方法，一个是第一次开始处理，一个是子<code>View</code>处理后剩下的再去处理。</p>
<p>下面实现一个示例，给<code>RecyclerView</code>添加一个Header：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;150dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#00FFFF&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Header&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">&quot;.NestedBehavior&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.recyclerview.widget.RecyclerView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/recyclerView&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layoutManager</span>=<span class="hljs-string">&quot;androidx.recyclerview.widget.LinearLayoutManager&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">&quot;.ToBottomBehavior&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:listitem</span>=<span class="hljs-string">&quot;@layout/item_text&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>整体布局如上所示，要实现添加Header的效果，需要两步，一是将<code>RecyclerView</code>放置在Header的下面，一是跟随滑动。由于<code>CoordinatorLayout</code>的默认布局效果是堆叠的方式，所以需要我们自己去进行布局，这里定义一个<code>ToBottomBehavior</code>，作用与<code>RecyclerView</code>，用于让其一直处于Header的下方：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ToBottomBehavior</span>(context: Context,attr: AttributeSet) : Behavior&lt;RecyclerView&gt;(context, attr) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayoutChild</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        parent: <span class="hljs-type">CoordinatorLayout</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        child: <span class="hljs-type">RecyclerView</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        layoutDirection: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">if</span> (parent.childCount &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-comment">// 将RecyclerView放置在Header的下面</span><br>        <span class="hljs-keyword">val</span> first = parent.getChildAt(<span class="hljs-number">0</span>)<br>        child.layout(<span class="hljs-number">0</span>, first.measuredHeight, first.measuredWidth, child.measuredHeight)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">layoutDependsOn</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        parent: <span class="hljs-type">CoordinatorLayout</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        child: <span class="hljs-type">RecyclerView</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dependency: <span class="hljs-type">View</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> dependency <span class="hljs-keyword">is</span> TextView<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDependentViewChanged</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        parent: <span class="hljs-type">CoordinatorLayout</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        child: <span class="hljs-type">RecyclerView</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dependency: <span class="hljs-type">View</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-comment">// 当Header的 位置发生变化时，继续挪动RecyclerView，让其一直在Header下方</span><br>        child.layout(<br>            <span class="hljs-number">0</span>,<br>            (dependency.bottom + dependency.translationY).toInt(),<br>            child.measuredWidth,<br>            child.measuredHeight<br>        )<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后再定义一个<code>NestedBehavior</code>，让Header跟随RecyclerView进行滑动：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NestedBehavior</span>(<br>    context: Context,<br>    attr: AttributeSet? = <span class="hljs-literal">null</span><br>) : CoordinatorLayout.Behavior&lt;View&gt;(context, attr) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStartNestedScroll</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        coordinatorLayout: <span class="hljs-type">CoordinatorLayout</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        child: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        directTargetChild: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        target: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        axes: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        type: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-comment">// 只拦截纵向的滚动</span><br>        <span class="hljs-keyword">return</span> axes == ViewCompat.SCROLL_AXIS_VERTICAL<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNestedPreScroll</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        coordinatorLayout: <span class="hljs-type">CoordinatorLayout</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        child: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        target: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dx: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dy: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        consumed: <span class="hljs-type">IntArray</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        type: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        <span class="hljs-comment">// 注意，手指向上滑动的时候，dy大于0。向下的时候dy小于0。</span><br>        <span class="hljs-keyword">val</span> translationY = child.translationY<br>        <span class="hljs-keyword">if</span> (-translationY &gt;= child.measuredHeight || dy &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// child已经滚动到屏幕外了，或者向下滚动，就不去消耗滚动了</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 还差这么desireHeight距离将会移出屏幕外</span><br>        <span class="hljs-keyword">val</span> desireHeight = translationY + child.measuredHeight<br>        <span class="hljs-keyword">if</span> (dy &lt;= desireHeight) &#123;<br>            <span class="hljs-comment">// 将dy全部消耗掉</span><br>            child.translationY = translationY - dy<br>            consumed[<span class="hljs-number">1</span>] = dy<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 消耗一部分的的dy</span><br>            child.translationY = translationY - desireHeight<br>            consumed[<span class="hljs-number">1</span>] = desireHeight.toInt()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNestedScroll</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        coordinatorLayout: <span class="hljs-type">CoordinatorLayout</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        child: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        target: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dxConsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dyConsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dxUnconsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dyUnconsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        type: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        consumed: <span class="hljs-type">IntArray</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        <span class="hljs-keyword">val</span> translationY = child.translationY<br>        <span class="hljs-keyword">if</span> (translationY &gt;= <span class="hljs-number">0</span> || dyUnconsumed &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 手指向上滚动或者child已经滚出了屏幕，不去处理</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (dyUnconsumed &gt; translationY) &#123;<br>            <span class="hljs-comment">// 全部消耗</span><br>            consumed[<span class="hljs-number">1</span>] += dyUnconsumed<br>            child.translationY = translationY - dyUnconsumed<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 消耗一部分</span><br>            consumed[<span class="hljs-number">1</span>] += child.translationY.toInt()<br>            child.translationY = <span class="hljs-number">0F</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后随便设置一下RecyclerView的Adapter等，效果如下：</p>
<p><img src="/img/behavior-nested.webp" alt="behavior-nested.webp"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先，<code>Behavior</code>是一个插件，它是<code>CoordinatorLayout</code>抽取出来的一个标准。<code>CoordinatorLayout</code>将本身的各种能力抽取到了<code>Behavior</code>中，在需要的时候去加载它从而实现某些交互。</p>
<p>其次，<code>Behavior</code>一共有四种能力：<strong>测量布局，位置依赖，事件拦截，嵌套滑动</strong>。其中依赖和嵌套滑动用的是最多的，然后是布局和测量，最后才是touch。</p>
<p>当学会了<code>Behavior</code>的各个方法的使用后，就可以设计出各种花里胡哨的操作了，也就学会了Behavior了。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:penggaofeng1@163.com">Rmfone</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2021/11/02/CoordinatorLayout%E7%9A%84%E7%A7%98%E5%AF%86%E4%B9%8BBehavior/">https://pgaofeng.github.io/2021/11/02/CoordinatorLayout的秘密之Behavior/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">其他声明：</span><span class="p-copytight-value">本站所有文章均可随意转载，但请注明出处，文章原稿：<a target="_blank" rel="noopener" href="https://github.com/pgaofeng/NoteBook/tree/main/source/_posts">点击跳转Github</a></span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/View/">View</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Behavior%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-number">1.</span> <span class="toc-text">Behavior的能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%AE%BE%E7%BD%AEBehavior"><span class="toc-number">1.1.</span> <span class="toc-text">如何使用设置Behavior</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xml%E4%B8%AD%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.1.1.</span> <span class="toc-text">xml中设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">直接创建实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E9%BB%98%E8%AE%A4%E7%9A%84Behavior%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.1.3.</span> <span class="toc-text">通过默认的Behavior设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Behavior%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">Behavior的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E5%92%8C%E5%B8%83%E5%B1%80"><span class="toc-number">1.2.1.</span> <span class="toc-text">测量和布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E4%BE%9D%E8%B5%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">布局依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA%E5%A4%84%E7%90%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">事件拦截处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">嵌套滑动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2021/11/22/Android%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E4%B9%8B%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8/">&lt; Android滑动事件之嵌套滑动</a><a class="next" href="/2021/09/06/%E5%9C%A8Android%E4%B8%AD%E4%BD%BF%E7%94%A8Bsdiff%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/">在Android中使用Bsdiff实现增量更新 &gt;</a></div></section><footer><p>最近更新：2024-01-17 22:00:52 | 本文作者：<a href="/." rel="nofollow">没有感情的代码机器</a><br> </p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script></body></html>