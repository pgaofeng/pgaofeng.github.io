<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Android进程间通信-AIDL</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>25</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>15</span> <span>标签</span> </a><a class="author-word-count"><span>10.79</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Binder%E7%9A%84%E5%AA%92%E4%BB%8B" class="toc-link"><span class="toc-text">Binder的媒介</span></a></li><li class="toc-item toc-level-2"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF" class="toc-link"><span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-2"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF" class="toc-link"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-2"><a href="#AIDL%E6%94%AF%E6%8C%81%E7%9A%84%E7%B1%BB%E5%9E%8B" class="toc-link"><span class="toc-text">AIDL支持的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="toc-link"><span class="toc-text">默认数据类型</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%89%8B%E5%8A%A8%E5%AE%9A%E4%B9%89Parcelable" class="toc-link"><span class="toc-text">手动定义Parcelable</span></a></li><li class="toc-item toc-level-3"><a href="#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Parcelable" class="toc-link"><span class="toc-text">自动生成Parcelable</span></a></li><li class="toc-item toc-level-3"><a href="#%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6" class="toc-link"><span class="toc-text">属性修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#in" class="toc-link"><span class="toc-text">in</span></a></li><li class="toc-item toc-level-4"><a href="#out" class="toc-link"><span class="toc-text">out</span></a></li><li class="toc-item toc-level-4"><a href="#inout" class="toc-link"><span class="toc-text">inout</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">3</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">5</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">5</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Android进程间通信-AIDL thumbnail" class="image lozad" src="/img/cover/cover-aidl.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Android进程间通信-AIDL</h1></header><div class="post-meta post-show-meta"><time datetime="2021-03-12T04:09:40.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2021-03-12</span> </time><span class="dot"></span> <a href="/categories/Android-Framework/" class="post-meta-link">Android Framework </a><span class="dot"></span> <span>约2.9k 字</span></div><div class="post-content" id="section"><p><code>Android</code>进程间通信通常使用的<code>Binder</code>的方式，而<code>Binder</code>则是以<code>C/S</code>模式实现的，即<code>Binder</code>的主体作为服务端提供服务，<code>Binder</code>的引用端作为客户端请求服务。但是<code>Binder</code>是在<code>Framework</code>层使用<code>C++</code>实现的，为了方便<code>Android应用端</code>的开发，对<code>Native</code>层的<code>Binder</code>进行包装实现了<code>Java</code>层的<code>Binder</code>，并又进一步提供了<code>AIDL</code>的实现方式来简化进程间调用，这就是本篇文章所记录的内容。</p><h2 id="Binder的媒介"><a href="#Binder的媒介" class="headerlink" title="Binder的媒介"></a>Binder的媒介</h2><p>作为<code>C/S</code>架构的实现，<code>Binder</code>需要客户端和服务端。服务端也就是<code>Binder</code>的主体，需要注册在<code>ServiceManager</code>中；客户端会通过<code>Binder</code>的名字获取到对应<code>Binder</code>的代理，然后就可以进行通信了。但是在应用层开发中，我们肯定不能直接注册<code>Binder</code>的，因此需要匿名<code>Binder</code>的实现，而匿名<code>Binder</code>应用最广泛的就是四大组件的<code>Service</code>了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerService</span> : <span class="hljs-type">Service</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBind</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span>: IBinder? &#123;<br>        <span class="hljs-comment">// 在这里返回Binder实体作为服务端</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>bindService</code>方式启动的服务，可以实现<code>onBind</code>方法来返回<code>Binder</code>实体作为服务端对象。当服务被绑定后，该<code>Service</code>进程会被拉起来，此时该<code>Service</code>进程就是服务端了。绑定者所在的进程会拿到<code>IBinder</code>的代理对象，然后两个进程就通过<code>IBinder</code>来进行进程间的交互。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>前面说了<code>Binder</code>获取的方式，后面则是<code>Binder</code>的实现了。为了简化<code>Binder</code>的实现，<code>Android</code>提供了<code>AIDL</code>的方式来封装各种Binder通用的操作，让开发者仅需关注具体的业务功能即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">plugins &#123;<br>    ...<br>&#125;<br><br>android &#123;<br>    ...<br>    buildFeatures &#123;<br>        aidl = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br>dependencies &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>首先需要在<code>build.gradle.kts</code>中开启<code>AIDL</code>的支持，即在<code>android</code>闭包下新增<code>buildFeatures</code>闭包，然后声明<code>aidl=true</code>，<code>groovy</code>语法也是一样的。然后在源码的同级目录下新增<code>aidl</code>目录<code>app\src\main\aidl</code>，该目录就是存放<code>AIDL</code>文件的目录。</p><p>如果直接通过<code>右键-new-AIDL-new aidlFile</code>创建<code>AIDL</code>文件的话，会在<code>aidl</code>目录下生成一个和当前应用同样的包名目录，然后新的<code>AIDL</code>文件则是在这个目录下。实际上，这个包名是不必和应用的包名一致的，可以随意定义。<code>AIDL</code>文件不会有任何<code>IDE</code>提示的，需要我们完全手写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aidl">app\src\main\aidl\com\server\aidl\IServer.aidl<br><br>package com.server.aidl;<br><br>interface IServer &#123;<br>    // 定义了一个方法，服务端提供文本<br>    String getTextFromServer();<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来需要点击AS的<code>build -&gt; make project</code>触发文件的生成，AS会根据<code>AIDL</code>文件去生成对应的Binder类，然后我们继承该类即可。生成的文件在<code>app\build\generated\aidl_source_output_dir\debug\out\com\server\aidl\IServer.java</code>中，当然我们不需要关注他在哪，我们直接使用即可。新建一个类继承<code>IServer.Stub</code>，然后实现方法即可。如果提示找不到这个类的话，尝试<code>clean</code>一下再重新<code>build</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Binder的实体，作为服务端使用，继承IServer.Stub后只需要关注需要实现的方法即可</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> : <span class="hljs-type">IServer.Stub</span>()&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTextFromServer</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是服务端返回的文本&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在Service中的onBind将该对象返回即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerService</span> : <span class="hljs-type">Service</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBind</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span>: IBinder? &#123;<br>        <span class="hljs-keyword">return</span> Server()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意在<code>manifest</code>中声明时，<code>exported</code>属性必须设置成<code>true</code>并且定义<code>intent-filter</code>，因为我们是要在另一个app中绑定该服务的。另外，在<code>exported</code>设为<code>true</code>后，还需要通过权限进行控制，这里偷懒就不加权限了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    &lt;<span class="hljs-attr">application</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ServerService&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.server.action&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>至此，服务端所做的工作已经完成了。总结下来就是创建一个<code>aidl</code>文件并声明所支持的接口方 法，然后<code>build</code>生成对应的类，然后再继承生成的<code>xxx.Stub</code>类实现支持的接口方法即可。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端要做的工作更简单了，首先创建一个新的项目，然后在<code>build.gradle.kts</code>中开启<code>aidl</code>的支持，然后将服务端创建的<code>aidl</code>复制到客户端的目录下。注意：<strong>复制过来的<code>AIDL</code>文件的包名必须和服务端保持一致</strong>。然后Build一下生成具体的代码。</p><p>接下来就是在客户端中绑定服务端的Service，然后拿到<code>IBinder</code>对象，然后就可以进行交互了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mBtnRequest: Button<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mTextView: TextView<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mServer: IServer? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mConnection = <span class="hljs-keyword">object</span> : ServiceConnection &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>?, service: <span class="hljs-type">IBinder</span>?)</span></span> &#123;<br>            <span class="hljs-comment">// 绑定服务后拿到IServer，后续就通过IServer进行进程间交互</span><br>            mServer = IServer.Stub.asInterface(service)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>?)</span></span> &#123;<br>            mServer = <span class="hljs-literal">null</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        enableEdgeToEdge()<br>        setContentView(R.layout.activity_main)<br>        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;<br>            <span class="hljs-keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())<br>            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)<br>            insets<br>        &#125;<br>        <span class="hljs-keyword">init</span>()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>        mBtnRequest = findViewById(R.id.btn_request)<br>        mTextView = findViewById(R.id.text)<br>        mBtnRequest.setOnClickListener &#123;<br>            <span class="hljs-comment">// 点击后通过IServer获取到服务端返回的字串</span><br>            mTextView.text = mServer?.textFromServer ?: <span class="hljs-string">&quot;default&quot;</span><br>        &#125;<br>        <span class="hljs-keyword">val</span> intent = Intent().also &#123;<br>            <span class="hljs-comment">// 服务端Service的action</span><br>            it.action = <span class="hljs-string">&quot;com.example.server.action&quot;</span><br>            <span class="hljs-comment">// 服务端Service所在的app的包名</span><br>            it.`<span class="hljs-keyword">package</span>` = <span class="hljs-string">&quot;com.example.serverdemo&quot;</span><br>        &#125;<br>        bindService(intent, mConnection, BIND_AUTO_CREATE)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        unbindService(mConnection)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>服务端很简单，在<code>Activity</code>启动时绑定服务端的服务，然后拿到<code>IBinder</code>通过生成的<code>IServer.Stub.asInterface</code>转换成<code>IServer</code>，然后就可以直接进行交互了。因为我们是在客户端app中绑定服务端app的，在<code>Android 11</code>以后需要在<code>Manifest</code>中声明要绑的包名，否则无法绑定成功。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span></span><br><span class="hljs-tag">    &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">必须声明服务端的包名</span> <span class="hljs-attr">--</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">queries</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.serverdemo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">queries</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">    &lt;/<span class="hljs-attr">application</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="AIDL支持的类型"><a href="#AIDL支持的类型" class="headerlink" title="AIDL支持的类型"></a>AIDL支持的类型</h2><p>前面的示例说明了<code>AIDL</code>的交互方式，从代码层面上看，在客户端拿到<code>IServer</code>后，可以直接调用方法进行交互，即以同步的方式进行跨进程的调用。既然实际是跨进程调用的，那么实现上肯定是有一些限制的。如参数的类型，就不是全部类型都能使用的。</p><h3 id="默认数据类型"><a href="#默认数据类型" class="headerlink" title="默认数据类型"></a>默认数据类型</h3><p>基本数据类型：<code>byte</code>, <code>char</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>boolean</code>， 以及基本类型对应的数组</p><p>字串类型：<code>CharSequence</code>, <code>String</code>， 以及字串类型对应的数组</p><p>集合类型：<code>List</code>, <code>Map</code>, 最新的版本中集合类型已经不局限于<code>ArrayList</code>和<code>HashMap</code>了</p><p>除了以上类型外，如果想要传递自定义的类型，则需要实现<code>Parcelable</code>接口。</p><h3 id="手动定义Parcelable"><a href="#手动定义Parcelable" class="headerlink" title="手动定义Parcelable"></a>手动定义Parcelable</h3><p>首先在代码目录中创建一个<code>User</code>类，然后实现<code>Parcelable</code>接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 注意包名！</span><br><span class="hljs-keyword">package</span> com.example.server<br><br><span class="hljs-keyword">import</span> android.os.Parcel<br><span class="hljs-keyword">import</span> android.os.Parcelable<br><br><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<br>    <span class="hljs-keyword">val</span> name:String,<br>    <span class="hljs-keyword">val</span> age:<span class="hljs-built_in">Int</span><br>):Parcelable &#123;<br>    <span class="hljs-keyword">constructor</span>(parcel: Parcel) : <span class="hljs-keyword">this</span>(<br>        parcel.readString().toString(),<br>        parcel.readInt()<br>    ) &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">writeToParcel</span><span class="hljs-params">(parcel: <span class="hljs-type">Parcel</span>, flags: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        parcel.writeString(name)<br>        parcel.writeInt(age)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">describeContents</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> CREATOR : Parcelable.Creator&lt;User&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createFromParcel</span><span class="hljs-params">(parcel: <span class="hljs-type">Parcel</span>)</span></span>: User &#123;<br>            <span class="hljs-keyword">return</span> User(parcel)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newArray</span><span class="hljs-params">(size: <span class="hljs-type">Int</span>)</span></span>: Array&lt;User?&gt; &#123;<br>            <span class="hljs-keyword">return</span> arrayOfNulls(size)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在aidl目录中新建一个<code>User.aidl</code>，<strong>注意该文件的包名必须和<code>User</code>类的包名保持一致</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// User.aidl</span><br><br><span class="hljs-keyword">package</span> com.example.server;<br>parcelable User;<br></code></pre></td></tr></table></figure><p>然后实际使用的地方也需要进行<strong>导包</strong>，注意as不会提示导包，必须要手动输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.server.aidl;<br><span class="hljs-comment">// 必须进行import!!</span><br><span class="hljs-keyword">import</span> com.example.okhttpdemo3.User;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IServer</span> &#123;<br>    String <span class="hljs-title function_">getTextFromServer</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherTypes</span><span class="hljs-params">(</span><br><span class="hljs-params">        in User user</span><br><span class="hljs-params">    )</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自动生成Parcelable"><a href="#自动生成Parcelable" class="headerlink" title="自动生成Parcelable"></a>自动生成Parcelable</h3><p>前面手动生成<code>Parcelable</code>的地方，<code>User</code>类定义在了代码目录中，因此当复制<code>aidl</code>文件到客户端的时候，必须要把<code>User</code>类的文件也同时复制过去，并且包名路径要完全一致，这无疑是很麻烦的。因此可以使用<code>aidl</code>自动生成<code>Parcelable</code>的方式来实现<code>User</code>类。</p><p>1，删除前面定义的<code>User</code>类文件</p><p>2，修改<code>User.aidl</code>内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// User.aidl</span><br><br><span class="hljs-keyword">package</span> com.example.server;<br>parcelable User &#123;<br>   <span class="hljs-type">int</span> age;<br>   String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样<code>build</code>之后会自动生成一个<code>User</code>类，不需要再写那些复杂的逻辑了。</p><h3 id="属性修饰符"><a href="#属性修饰符" class="headerlink" title="属性修饰符"></a>属性修饰符</h3><p>在前面的自定义<code>Parcelable</code>时，可以看到在<code>AIDL</code>使用自定义<code>Parcelable</code>类型的时候，加上了属性修饰符<code>in</code>。实际上，除了<code>byte</code>, <code>char</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>boolean</code>, <code>CharSequence</code>, <code>String</code>外，其他的类型作为参数时都必须添加属性修饰符。</p><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p>数据从客户端传递到服务端，也是最常用的调用方式。也就是数据作为参数从客户端传入，可以理解为值传递，就是在服务端对这个参数进行修改的话，是影响不到客户端的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.server.aidl;<br><span class="hljs-comment">// 必须进行import!!</span><br><span class="hljs-keyword">import</span> com.example.okhttpdemo3.User;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IServer</span> &#123;<br>    String <span class="hljs-title function_">getTextFromServer</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherTypes</span><span class="hljs-params">(</span><br><span class="hljs-params">        // 定义成in类型</span><br><span class="hljs-params">        in User user</span><br><span class="hljs-params">    )</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 服务端的Binder实体</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> : <span class="hljs-type">IServer.Stub</span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> TAG = <span class="hljs-string">&quot;Server&quot;</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTextFromServer</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;服务端返回的字串&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">otherType</span><span class="hljs-params">(user: <span class="hljs-type">User</span>?)</span></span> &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;user.name = <span class="hljs-subst">$&#123;user?.name&#125;</span>, user.age = <span class="hljs-subst">$&#123;user?.age&#125;</span>&quot;</span>)<br>        <span class="hljs-comment">// 在服务端将传递的参数的值变化下</span><br>        user?.age = <span class="hljs-number">80</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端调用</span><br>mBtnRequest.setOnClickListener &#123;<br>    <span class="hljs-keyword">val</span> user = User().also &#123;<br>        it.name = <span class="hljs-string">&quot;张三&quot;</span><br>        it.age = <span class="hljs-number">23</span><br>    &#125;<br>    mServer?.otherType(user)<br>     Log.d(TAG, <span class="hljs-string">&quot;after call, name = <span class="hljs-subst">$&#123;user.name&#125;</span>, age = <span class="hljs-subst">$&#123;user.age&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>打印的结果值如下，可以看到即使在服务端修改了<code>User</code>的字段，实际上客户端的<code>User</code>仍没有发生变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">com.example.serverdemo    D  user.name = 张三, user.age = 23<br>com.example.clientdemo    D  after call, name = 张三, age = 23<br></code></pre></td></tr></table></figure><h4 id="out"><a href="#out" class="headerlink" title="out"></a>out</h4><p>数据由服务端流向客户端，这种方式服务端无法获取到<code>User</code>的数据，但是对<code>User</code>的修改却能反馈到客户端中去。将前面<code>aidl</code>文件中的<code>in</code>修改为<code>out</code>后，在分别<code>build</code>并运行后，输入的<code>log</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">com.example.serverdemo    D  user.name = null, user.age = 0<br>com.example.clientdemo    D  after call, name = null, age = 80<br></code></pre></td></tr></table></figure><p>可以看到，在客户端实际传入的是一个有内容的User，但是在服务端中是无法读取到User的内容的。但是在服务端修改User后，客户端的User也修改了，并且客户端的原始内容被清空了。因此，out修饰符就是提供一个对象，用于接收服务端对该对象的修改。</p><h4 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h4><p>数据双向流通，即服务端能获取到客户端传入的内容，客户端也能收到服务端对该内容的修改。将前面<code>aidl</code>文件中的<code>in</code>修改为<code>out</code>后，在分别<code>build</code>并运行后，输入的<code>log</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">com.example.serverdemo    D  user.name = 张三, user.age = 23<br>com.example.clientdemo    D  after call, name = 张三, age = 80<br></code></pre></td></tr></table></figure><p>可以看到，服务端能读取到User的内容，并且对User内容的修改也能反馈到客户端。这种修饰符修饰下，对跨进程调用的方法，表现形式是和本进程内的调用java方法一样的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>AIDL</code>是<code>Android</code>提供的跨进程调用的工具，实际上<code>AIDL</code>文件是不会被打包到app中的，只是根据其内容来生成代码文件，将跨进程那一套通用的逻辑都自动生成了，方便我们只关注业务逻辑部分。从使用上来说，<code>AIDL</code>一般在系统应用中才用的比较多，因为很多系统应用间都需要互相交互，使用<code>AIDL</code>无疑是非常方便的。而对于普通应用，一般是大体量的app会将本身分成多个进程，然后去使用<code>AIDL</code>实现进程间交互。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Fri Mar 12 2021 12:09:40 GMT+0800");let n="Fri Mar 12 2021 12:09:40 GMT+0800";n="2024-09-08 16:30:53 +0800";var a=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-a)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Android-Framework/" class="post-footer-category">#&nbsp;Android Framework</a> <a href="/tags/Binder/" class="post-footer-tag">#&nbsp;Binder</a> <a href="/tags/AIDL/" class="post-footer-tag">#&nbsp;AIDL</a></div><div class="nav"><div class="nav-item-prev"><a href="/2021/04/10/view/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">View的绘制流程</div></div></a></div><div class="nav-item-next"><a href="/2021/02/20/use-okhttp-2/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">OkHttp3整体源码分析</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Binder%E7%9A%84%E5%AA%92%E4%BB%8B" class="toc-link"><span class="toc-text">Binder的媒介</span></a></li><li class="toc-item toc-level-2"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF" class="toc-link"><span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-2"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF" class="toc-link"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-2"><a href="#AIDL%E6%94%AF%E6%8C%81%E7%9A%84%E7%B1%BB%E5%9E%8B" class="toc-link"><span class="toc-text">AIDL支持的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="toc-link"><span class="toc-text">默认数据类型</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%89%8B%E5%8A%A8%E5%AE%9A%E4%B9%89Parcelable" class="toc-link"><span class="toc-text">手动定义Parcelable</span></a></li><li class="toc-item toc-level-3"><a href="#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Parcelable" class="toc-link"><span class="toc-text">自动生成Parcelable</span></a></li><li class="toc-item toc-level-3"><a href="#%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6" class="toc-link"><span class="toc-text">属性修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#in" class="toc-link"><span class="toc-text">in</span></a></li><li class="toc-item toc-level-4"><a href="#out" class="toc-link"><span class="toc-text">out</span></a></li><li class="toc-item toc-level-4"><a href="#inout" class="toc-link"><span class="toc-text">inout</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-01-14</div><a href="/2023/01/14/sp-wp-refbase/"><div class="recent-posts-item-content">Android智能指针</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-04-20</div><a href="/2022/04/20/binder-1/"><div class="recent-posts-item-content">Binder和服务</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-10-02</div><a href="/2022/10/02/ams/"><div class="recent-posts-item-content">App管理服务-ActivityManagerService</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-09-21</div><a href="/2022/09/21/system_server/"><div class="recent-posts-item-content">Java服务总管-system_server进程</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-08-12</div><a href="/2022/08/12/zygote/"><div class="recent-posts-item-content">Java进程祖先-zygote服务</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-06-05</div><a href="/2023/06/05/flow-2/"><div class="recent-posts-item-content">SharedFlow、StateFlow、SafeFlow的区别</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-05-22</div><a href="/2023/05/22/flow/"><div class="recent-posts-item-content">协程数据流Flow</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-04-29</div><a href="/2023/04/29/coroutine-context/"><div class="recent-posts-item-content">协程上下文CoroutineContext</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-03-15</div><a href="/2023/03/15/coroutine-1/"><div class="recent-posts-item-content">Kotlin协程的使用</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>