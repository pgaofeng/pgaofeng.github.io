<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Flutter动画</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.1.1" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>45</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>18.72</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#%E5%8A%A8%E7%94%BB" class="toc-link"><span class="toc-text">动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#Animatable" class="toc-link"><span class="toc-text">Animatable</span></a></li><li class="toc-item toc-level-3"><a href="#Animation" class="toc-link"><span class="toc-text">Animation</span></a></li><li class="toc-item toc-level-3"><a href="#Tween" class="toc-link"><span class="toc-text">Tween</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#ReverseTween" class="toc-link"><span class="toc-text">ReverseTween</span></a></li><li class="toc-item toc-level-4"><a href="#ColorTween" class="toc-link"><span class="toc-text">ColorTween</span></a></li><li class="toc-item toc-level-4"><a href="#SizeTween" class="toc-link"><span class="toc-text">SizeTween</span></a></li><li class="toc-item toc-level-4"><a href="#RectTween" class="toc-link"><span class="toc-text">RectTween</span></a></li><li class="toc-item toc-level-4"><a href="#IntTween-StepTween" class="toc-link"><span class="toc-text">IntTween &amp; StepTween</span></a></li><li class="toc-item toc-level-4"><a href="#ConstantTween" class="toc-link"><span class="toc-text">ConstantTween</span></a></li><li class="toc-item toc-level-4"><a href="#CurveTween" class="toc-link"><span class="toc-text">CurveTween</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#AnimationController" class="toc-link"><span class="toc-text">AnimationController</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E7%A4%BA%E4%BE%8B" class="toc-link"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#CurvedAnimation" class="toc-link"><span class="toc-text">CurvedAnimation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E7%A4%BA%E4%BE%8B-1" class="toc-link"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a href="#Curve" class="toc-link"><span class="toc-text">Curve</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E7%94%BB" class="toc-link"><span class="toc-text">使用动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#ImplicitlyAnimatedWidget" class="toc-link"><span class="toc-text">ImplicitlyAnimatedWidget</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">10</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Flutter动画 thumbnail" class="image lozad" src="/img/cover/cover-flutter-animation.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Flutter动画</h1></header><div class="post-meta post-show-meta"><time datetime="2025-01-01T14:03:47.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2025-01-01</span> </time><span class="dot"></span> <a href="/categories/Flutter/" class="post-meta-link">Flutter </a><span class="dot"></span> <span>约6.7k 字</span></div><div class="post-content" id="section"><p>动画也是<code>UI</code>组成的一部分，好的动画能够给用户更好的体验（动效工程师的要求，不得不做）。动画的本质其实就是一组不同的图像，连续不断的进行播放，从而体现出动态效果。例如要实现一个圆形的逐渐变大的动画效果，实际上就是将它的半径逐渐变大，然后在每一帧绘制时按照半径进行绘制就实现了。</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>在<code>Android</code>中，做动画其实也是生成一组连续变化的数值，然后设置给对应的<code>View</code>，我们最常用的就是<code>ValueAnimator</code>或<code>ObjectAnimator</code>，他们本身即是动画的控制器，又是动画的执行者。而在<code>Flutter</code>中，将动画分为了两个部分：<code>Animatable</code>和<code>Animation</code>。</p><p><code>Animatable</code>：控制动画的值，即对于动画数值的计算</p><p><code>Animation</code>：控制动画的执行，即开始暂停等操作</p><h3 id="Animatable"><a href="#Animatable" class="headerlink" title="Animatable"></a>Animatable</h3><p>在<code>Flutter</code>中，通过这种形式做动画的叫做补间动画，因为它的实现类就是<code>Tween</code>。它所做的，就是根据动画的进度来计算实际的值。例如需要在1秒钟之内将某个圆的半径逐渐从0扩大到60，那么对于刷新率为60帧的手机，将会在每次刷新时计算新值，也就是每16ms这个值增加1。</p><p>要实现每<code>16ms</code>计算一次，就必须要能够知道什么时候屏幕刷新，即需要一个<code>vsync</code>信号，每次收到信号后开始计算，这样对于不同屏幕刷新率的手机而言，动画也是通用的。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animatable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">// 转换方法，根据t计算新值，t是动画的进度，值从0到1.0</span><br>  T transform(<span class="hljs-built_in">double</span> t);<br><br>  <span class="hljs-comment">// 根据进度获取值，与transform一样，参数是进度取值0~1，不要重写这个方法</span><br>  T evaluate(Animation&lt;<span class="hljs-built_in">double</span>&gt; animation) =&gt; transform(animation.value);<br><br>  <span class="hljs-comment">// 构建一个动画</span><br>  Animation&lt;T&gt; animate(Animation&lt;<span class="hljs-built_in">double</span>&gt; parent) &#123;<br>    <span class="hljs-keyword">return</span> _AnimatedEvaluation&lt;T&gt;(parent, <span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是摘抄的部分的<code>Animatable</code>的源码，它定义了常用的三个方法。一个是<code>transform</code>接收的是一个<code>double</code>的值，这个参数就是动画的进度。实际上的计算过程是<code>Animation</code>接收<code>vsync</code>信号触发计算，然后根据时间计算出当前动画的进度，再交由给<code>Animatable</code>计算新值。如果我们想要实现自定义的计算逻辑，只需要重写这个方法即可。</p><p><code>eveluate</code>用于评估当前动画对应的进度的值，它的参数是一个<code>Animation</code>，实际的逻辑就是直接调用了<code>transform</code>方法。一般不要重写这个方法。</p><p><code>animate</code>方法代表构建一个动画，它接受一个<code>Animation</code>对象，然后将二者进行组合，这样整个动画就完整了：有计算新值的<code>Animatable</code>部分，有控制动画执行暂停的<code>Animation</code>部分。</p><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p><code>Animation</code>控制动画的执行，接收<code>vsync</code>信号，根据时间计算进度值等。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animation</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Listenable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ValueListenable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">// 值变化监听</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> addListener(VoidCallback listener);<br>  <span class="hljs-keyword">void</span> removeListener(VoidCallback listener);<br>  <span class="hljs-comment">// 状态变化监听</span><br>  <span class="hljs-keyword">void</span> addStatusListener(AnimationStatusListener listener);<br>  <span class="hljs-keyword">void</span> removeStatusListener(AnimationStatusListener listener);<br> <br>  <span class="hljs-comment">// 动画值</span><br>  <span class="hljs-meta">@override</span><br>  T <span class="hljs-keyword">get</span> value;<br>    <br>  <span class="hljs-comment">// 状态</span><br>  AnimationStatus <span class="hljs-keyword">get</span> status;<br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> isDismissed =&gt; status.isDismissed;<br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> isCompleted =&gt; status.isCompleted;<br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> isAnimating =&gt; status.isAnimating;<br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> isForwardOrCompleted =&gt; status.isForwardOrCompleted;<br><br>  <span class="hljs-comment">// 驱动一个Animatable</span><br>  <span class="hljs-meta">@optionalTypeArgs</span><br>  Animation&lt;U&gt; drive&lt;U&gt;(Animatable&lt;U&gt; child) &#123;<br>    <span class="hljs-keyword">assert</span>(<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> Animation&lt;<span class="hljs-built_in">double</span>&gt;);<br>    <span class="hljs-keyword">return</span> child.animate(<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Animation&lt;<span class="hljs-built_in">double</span>&gt;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Animation</code>实际上是一个老朋友，也是我们在状态管理中常用的<code>Listenable</code>，并且还是一个特殊的<code>ValueListenable</code>，其中的<code>value</code>也就是我们实际的动画值。</p><p>然后就是老一套添加和移除监听，比较特殊的是它还额外增加了对于动画状态的添加和移除监听。</p><p>最后是<code>drive</code>方法，翻译过来就是驱动，通过<code>Animation</code>来驱动一个<code>Animatable</code>，从而完成值的变化。看它的实现其实就是直接调用了<code>Animatable</code>的<code>animate</code>方法。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="dart hljs">Animation&lt;T&gt; animate(Animation&lt;<span class="hljs-built_in">double</span>&gt; parent) &#123;<br>    <span class="hljs-keyword">return</span> _AnimatedEvaluation&lt;T&gt;(parent, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>就是通过<code>_AnimatedEvaluation</code>将二者合并起来：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// AnimationWithParentMixin提供了Animation的实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_AnimatedEvaluation</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Animation</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">with</span> <span class="hljs-title">AnimationWithParentMixin</span>&lt;<span class="hljs-title">double</span>&gt; </span>&#123;<br>  _AnimatedEvaluation(<span class="hljs-keyword">this</span>.parent, <span class="hljs-keyword">this</span>._evaluatable);<br><br>  <span class="hljs-comment">// 混入类定义的参数，用于实现Animation的</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">final</span> Animation&lt;<span class="hljs-built_in">double</span>&gt; parent;<br><br>  <span class="hljs-comment">// Animatable计算新值</span><br>  <span class="hljs-keyword">final</span> Animatable&lt;T&gt; _evaluatable;<br><br>  <span class="hljs-comment">// 获取值</span><br>  <span class="hljs-meta">@override</span><br>  T <span class="hljs-keyword">get</span> value =&gt; _evaluatable.evaluate(parent);<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然新的<code>_AnimatedEvaluation</code>也是继承了<code>Animation</code>，但它的实现由<code>AnimationWithParentMixin</code>混入进行实现，实现逻辑其实就是定义一个<code>parent</code>，然后方法全部由<code>parent</code>实现，类似于代理模式，即<code>Animation</code>的示例由<code>parent</code>代理实现。</p><p>而<code>parent</code>则是通过构造方法传入的，它们也没做什么，就是获取值的时候是走的<code>evaluate</code>方法。</p><h3 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h3><p>其实到这里整个逻辑就很清晰了，<code>Animation</code>通过调用<code>Animatable#evaluate</code>来计算新值。**也就是说<code>Animatable</code>实际上与<code>Android</code>动画中的估值器是一样的。**继续回到<code>Animatable</code>，它的一个重要实现就是<code>Tween</code>，也称为补间动画：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tween</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span>?&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Animatable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 定义了开始与结束的值，通过构造方法传入</span><br>  T? begin;<br>  T? end;<br>  Tween(&#123;<span class="hljs-keyword">this</span>.begin, <span class="hljs-keyword">this</span>.end&#125;);<br><br>  <span class="hljs-comment">// 计算方法</span><br>  <span class="hljs-meta">@override</span><br>  T transform(<span class="hljs-built_in">double</span> t) &#123;<br>    <span class="hljs-comment">// 进度为0和1的时候代表动画的开始与结束，直接返回对应的值</span><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0.0</span>) &#123;<br>      <span class="hljs-keyword">return</span> begin <span class="hljs-keyword">as</span> T;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1.0</span>) &#123;<br>      <span class="hljs-keyword">return</span> end <span class="hljs-keyword">as</span> T;<br>    &#125;<br>    <span class="hljs-comment">// 其他值通过lerp计算</span><br>    <span class="hljs-keyword">return</span> lerp(t);<br>  &#125;<br><br>  <span class="hljs-meta">@protected</span><br>  T lerp(<span class="hljs-built_in">double</span> t) &#123;<br>    ...<br>    <span class="hljs-comment">// 根据进度计算新值</span><br>    <span class="hljs-keyword">return</span> (begin <span class="hljs-keyword">as</span> <span class="hljs-built_in">dynamic</span>) + ((end <span class="hljs-keyword">as</span> <span class="hljs-built_in">dynamic</span>) - (begin <span class="hljs-keyword">as</span> <span class="hljs-built_in">dynamic</span>)) * t <span class="hljs-keyword">as</span> T;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Tween</code>定义了两个属性，<code>begin</code>和<code>end</code>代表着动画的起始值与终点值，而计算过程就更加简单了直接根据进度<code>t</code>来计算：<code>lerp(t) = begin + (end - begin) * t</code>，也就是普通的线性计算。这里注意<code>lerp</code>其实前面加了很多的<code>assert</code>，因为它是直接线性计算的，但是它的泛型又只是限定为<code>Object</code>，因此如果要想使用<code>Tween</code>，则必须传入的是实现了<code>+、-、*</code>三个操作符的对象（通常是基本变量）。否则的话，就需要继承自<code>Tween</code>然后自己实现<code>lerp</code>函数。</p><h4 id="ReverseTween"><a href="#ReverseTween" class="headerlink" title="ReverseTween"></a>ReverseTween</h4><p><code>Tween</code>的子类之一，反转的<code>Tween</code>。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseTween</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span>?&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Tween</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 传入一个Tween</span><br>  ReverseTween(<span class="hljs-keyword">this</span>.parent) : <span class="hljs-keyword">super</span>(begin: parent.end, end: parent.begin);<br>  <span class="hljs-keyword">final</span> Tween&lt;T&gt; parent;<br><br>  <span class="hljs-comment">// 计算时将值反转</span><br>  <span class="hljs-meta">@override</span><br>  T lerp(<span class="hljs-built_in">double</span> t) =&gt; parent.lerp(<span class="hljs-number">1.0</span> - t);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ColorTween"><a href="#ColorTween" class="headerlink" title="ColorTween"></a>ColorTween</h4><p>用于实现颜色变化的<code>Tween</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorTween</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tween</span>&lt;<span class="hljs-title">Color</span>?&gt; </span>&#123;<br>  <span class="hljs-comment">// 限定了泛型类型为color</span><br>  ColorTween(&#123;<span class="hljs-keyword">super</span>.begin, <span class="hljs-keyword">super</span>.end&#125;);<br><br>  <span class="hljs-comment">// 走的是Color的lerp，其实就是对它的RGBA通道根据进度进行计算</span><br>  <span class="hljs-meta">@override</span><br>  Color? lerp(<span class="hljs-built_in">double</span> t) =&gt; Color.lerp(begin, end, t);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SizeTween"><a href="#SizeTween" class="headerlink" title="SizeTween"></a>SizeTween</h4><p>用于实现对<code>Size</code>变化的<code>Tween</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SizeTween</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tween</span>&lt;<span class="hljs-title">Size</span>?&gt; </span>&#123;<br>  <span class="hljs-comment">// 限定泛型为Size</span><br>  SizeTween(&#123;<span class="hljs-keyword">super</span>.begin, <span class="hljs-keyword">super</span>.end&#125;);<br><br>  <span class="hljs-comment">// 对Size的宽高同时根据进度进行计算</span><br>  <span class="hljs-meta">@override</span><br>  Size? lerp(<span class="hljs-built_in">double</span> t) =&gt; Size.lerp(begin, end, t);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="RectTween"><a href="#RectTween" class="headerlink" title="RectTween"></a>RectTween</h4><p>用于实现对<code>Rect</code>变化的<code>Tween</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RectTween</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tween</span>&lt;<span class="hljs-title">Rect</span>?&gt; </span>&#123;<br>  <span class="hljs-comment">// 限定泛型为Rect</span><br>  RectTween(&#123;<span class="hljs-keyword">super</span>.begin, <span class="hljs-keyword">super</span>.end&#125;);<br><br>  <span class="hljs-comment">// 对Rect的left、top、right、bottom根据进度进行计算</span><br>  <span class="hljs-meta">@override</span><br>  Rect? lerp(<span class="hljs-built_in">double</span> t) =&gt; Rect.lerp(begin, end, t);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="IntTween-StepTween"><a href="#IntTween-StepTween" class="headerlink" title="IntTween &amp; StepTween"></a>IntTween &amp; StepTween</h4><p>用于实现对<code>int</code>变化的<code>Tween</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntTween</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tween</span>&lt;<span class="hljs-title">int</span>&gt; </span>&#123;<br>  IntTween(&#123;<span class="hljs-keyword">super</span>.begin, <span class="hljs-keyword">super</span>.end&#125;);<br><br>  <span class="hljs-comment">// 对结果值四舍五入</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">int</span> lerp(<span class="hljs-built_in">double</span> t) =&gt; (begin! + (end! - begin!) * t).round();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StepTween</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tween</span>&lt;<span class="hljs-title">int</span>&gt; </span>&#123;<br>  StepTween(&#123;<span class="hljs-keyword">super</span>.begin, <span class="hljs-keyword">super</span>.end&#125;);<br><br>  <span class="hljs-comment">// 对结果值取整</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">int</span> lerp(<span class="hljs-built_in">double</span> t) =&gt; (begin! + (end! - begin!) * t).floor();<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个<code>Tween</code>逻辑都一样，也都是取的<code>int</code>泛型，它们的区别就是一个是对结果值四舍五入，一个是对结果值取整。如果想保留原始值，则需要用<code>DoubleTween</code>（<strong>不存在这个</strong>，因为默认的<code>Tween</code>就可以直接传入<code>double</code>）。</p><h4 id="ConstantTween"><a href="#ConstantTween" class="headerlink" title="ConstantTween"></a>ConstantTween</h4><p>对常量做变化的<code>Tween</code>（实际上没有任何变化，这个类有什么使用场景呢？）。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstantTween</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Tween</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 只接收一个参数</span><br>  ConstantTween(T value) : <span class="hljs-keyword">super</span>(begin: value, end: value);<br><br>  <span class="hljs-comment">// 直接返回</span><br>  <span class="hljs-meta">@override</span><br>  T lerp(<span class="hljs-built_in">double</span> t) =&gt; begin <span class="hljs-keyword">as</span> T;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CurveTween"><a href="#CurveTween" class="headerlink" title="CurveTween"></a>CurveTween</h4><p>实现了一个曲线<code>Curve</code>的变化：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 注意继承的是Animatable，而不是Tween</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurveTween</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animatable</span>&lt;<span class="hljs-title">double</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 构造方法传入curve</span><br>  CurveTween(&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.curve&#125;);<br><br>  Curve curve;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">double</span> transform(<span class="hljs-built_in">double</span> t) &#123;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0.0</span> || t == <span class="hljs-number">1.0</span>) &#123;<br>      <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-comment">// 返回curve的值</span><br>    <span class="hljs-keyword">return</span> curve.transform(t);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这个<code>CurveTween</code>比较特殊，因为它代表的本身就是一个曲线。前面的各种<code>Tween</code>中值的变化跟进度<code>t</code>都是线性的，而<code>Curve</code>本身代表的一个曲线，或者说是一个函数，这个函数可以是线性的也可以是非线性的，具体根据它内部的<code>transform</code>实现。</p><p>但是这个<code>Curve</code>又是一个特殊的曲线，它要求当进度为0时，值为0，进度为1时，值为1。也就是说，我使用<code>CurveTween</code>时，整个值的变化肯定是从0到1，但是具体中间值如何就不一定了，可能是0到1之间的数，也可能大于1或者小于0。</p><h3 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h3><p>前面看了<code>Animatable</code>的一些实现类，其实就是各种<code>Tween</code>，它们主要逻辑就是通过进度<code>t</code>来计算出一个新值。那么回到<code>Animation</code>中，看下进度<code>t</code>是如何被获取到的。<code>AnimationController</code>就是它的一个实现类：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimationController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animation</span>&lt;<span class="hljs-title">double</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">with</span></span><br><span class="hljs-class">        <span class="hljs-title">AnimationEagerListenerMixin</span>,</span><br><span class="hljs-class">        <span class="hljs-title">AnimationLocalListenersMixin</span>,</span><br><span class="hljs-class">        <span class="hljs-title">AnimationLocalStatusListenersMixin</span> </span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Animation</code>本质上也是一个泛型类，因为它是继承自<code>Listenable</code>并且实现了<code>ValueListenable</code>的。这里的<code>AnimationController</code>也可以看出，它是作为动画的控制器来实现的，因此它将泛型固定成了<code>double</code>，而这个<code>double</code>类型的值，就是它当前动画的进度。</p><p>这里先不看具体的实现，先看下它混入的三个混入类：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">mixin</span> AnimationEagerListenerMixin &#123;<br>  <span class="hljs-comment">// 注册监听者前调用</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> didRegisterListener() &#123;&#125;<br>  <span class="hljs-comment">// 移除监听者后调用</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> didUnregisterListener() &#123;&#125;<br><br>  <span class="hljs-comment">//回收资源</span><br>  <span class="hljs-meta">@mustCallSuper</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个混入类没什么可看的，主要做的就是定义几个方法用于注册和反注册时的回调，当然它的实现全部是空实现。然后看下一个：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">mixin</span> AnimationLocalListenersMixin &#123;<br>  <span class="hljs-comment">// 存储监听者</span><br>  <span class="hljs-keyword">final</span> HashedObserverList&lt;VoidCallback&gt; _listeners = HashedObserverList&lt;VoidCallback&gt;();<br><br>  <span class="hljs-comment">// 这两个方法的实现在AnimationEagerListenerMixin混入类中</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> didRegisterListener();<br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> didUnregisterListener();<br><br>  <span class="hljs-comment">// 注册一个监听</span><br>  <span class="hljs-keyword">void</span> addListener(VoidCallback listener) &#123;<br>    didRegisterListener();<br>    _listeners.add(listener);<br>  &#125;<br><br>  <span class="hljs-comment">// 移除一个监听</span><br>  <span class="hljs-keyword">void</span> removeListener(VoidCallback listener) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> removed = _listeners.remove(listener);<br>    <span class="hljs-keyword">if</span> (removed) &#123;<br>      didUnregisterListener();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 清空监听</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> clearListeners() &#123;<br>    _listeners.clear();<br>  &#125;<br><br>  <span class="hljs-comment">// 通知所有的监听者</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-meta">@pragma</span>(<span class="hljs-string">&#x27;vm:notify-debugger-on-exception&#x27;</span>)<br>  <span class="hljs-keyword">void</span> notifyListeners() &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;VoidCallback&gt; localListeners = _listeners.toList(growable: <span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> VoidCallback listener <span class="hljs-keyword">in</span> localListeners) &#123;<br>      InformationCollector? collector;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (_listeners.contains(listener)) &#123;<br>          listener();<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (exception, stack) <br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>AnimationLocalListenersMixin</code>混入类中，实现的是监听者的注册与反注册和通知逻辑，其实就是实现的<code>Listenable</code>的逻辑。当混入这个类后，在<code>AnimationController</code>中就不需要重新实现这些逻辑了。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">mixin</span> AnimationLocalStatusListenersMixin &#123;<br>  <span class="hljs-comment">// 存储状态监听者</span><br>  <span class="hljs-keyword">final</span> ObserverList&lt;AnimationStatusListener&gt; _statusListeners =<br>      ObserverList&lt;AnimationStatusListener&gt;();<br><br>  <span class="hljs-comment">// 这两个方法的实现在AnimationEagerListenerMixin混入类中</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> didRegisterListener();<br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> didUnregisterListener();<br><br>  <span class="hljs-comment">// 添加状态监听者</span><br>  <span class="hljs-keyword">void</span> addStatusListener(AnimationStatusListener listener) &#123;<br>    didRegisterListener();<br>    _statusListeners.add(listener);<br>  &#125;<br><br>  <span class="hljs-comment">// 移除状态监听者</span><br>  <span class="hljs-keyword">void</span> removeStatusListener(AnimationStatusListener listener) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> removed = _statusListeners.remove(listener);<br>    <span class="hljs-keyword">if</span> (removed) &#123;<br>      didUnregisterListener();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 清空状态监听者</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> clearStatusListeners() &#123;<br>    _statusListeners.clear();<br>  &#125;<br><br>  <span class="hljs-comment">// 通知所有的状态监听者</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-meta">@pragma</span>(<span class="hljs-string">&#x27;vm:notify-debugger-on-exception&#x27;</span>)<br>  <span class="hljs-keyword">void</span> notifyStatusListeners(AnimationStatus status) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;AnimationStatusListener&gt; localListeners = _statusListeners.toList(growable: <span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> AnimationStatusListener listener <span class="hljs-keyword">in</span> localListeners) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (_statusListeners.contains(listener)) &#123;<br>          listener(status);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (exception, stack) &#123;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这三个混入类是共同作用的，它们实现了<code>Animation</code>中的监听者逻辑、状态监听者逻辑，以及引入了这两个监听者在添加和移除时的回调函数。通过混入类的定义，可以将<code>Animation</code>的实现拆分，使得功能界限更加清晰，提高了复用性，也可以让<code>AnimationController</code>只关注它要关注的部分。</p><p>重新回到<code>Animation</code>，它定义了内容中，处理值监听与状态监听的逻辑由混入类完成了，就还剩值处理与状态处理，以及进度的计算，这部分逻辑都是在<code>AnimationController</code>中实现的。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimationController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animation</span>&lt;<span class="hljs-title">double</span>&gt; </span>&#123;<br>  <br>  <span class="hljs-comment">// 构造方法传入vsync</span><br>  AnimationController(&#123;<br>    ...<br>    <span class="hljs-keyword">required</span> TickerProvider vsync, <span class="hljs-comment">// vsync信号</span><br>  &#125;) : <span class="hljs-keyword">assert</span>(upperBound &gt;= lowerBound),<br>    ...<br>    <span class="hljs-comment">// 构建ticker</span><br>    _ticker = vsync.createTicker(_tick);<br>    ...<br>  <br>  <span class="hljs-comment">// vsync信号到达的时候触发的回调</span><br>  <span class="hljs-keyword">void</span> _tick(<span class="hljs-built_in">Duration</span> elapsed) &#123;<br>    _lastElapsedDuration = elapsed;<br>    <span class="hljs-comment">// 计算两次vsync的间隔时长</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> elapsedInSeconds =<br>        elapsed.inMicroseconds.toDouble() / <span class="hljs-built_in">Duration</span>.microsecondsPerSecond;<br>    <span class="hljs-comment">// 计算进度值，进度值由_simulation计算</span><br>    _value = clampDouble(_simulation!.x(elapsedInSeconds), lowerBound, upperBound);<br>    <span class="hljs-keyword">if</span> (_simulation!.isDone(elapsedInSeconds)) &#123;<br>      <span class="hljs-comment">// 更新状态</span><br>      _status = (_direction == _AnimationDirection.forward)<br>          ? AnimationStatus.completed<br>          : AnimationStatus.dismissed;<br>      stop(canceled: <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">// 通知观察者们进度值发生了变化</span><br>    notifyListeners();<br>    <span class="hljs-comment">// 检查状态值是否变化，变化的话通知状态观察者们状态发生了变化</span><br>    _checkStatusChanged();<br>  &#125;<br> <br>&#125;   <br></code></pre></td></tr></table></figure><p>对于进度的计算，实际上就是注册<code>vsync</code>信号的监听，当<code>vsync</code>信号到达时会触发对应的回调，从而在回调中处理进度计算逻辑。这里需要通过构造方法传入<code>TickerProvider</code>实例，从而调用它的<code>createTicker</code>方法创建一个<code>Ticker</code>并传入回调方法，当<code>Ticker#start</code>时，就会进行注册，每当接收到<code>vsync</code>信号后就会触发回调方法。</p><p><code>TickerProvider</code>的提供基本上都是通过<code>SingleTickerProviderStateMixin</code>或者<code>TickerProviderStateMixin</code>的混入来实现的，即我们正常只需要在<code>State</code>上混入这两个类中的一个就可以了。它们限定了混入的类必须是<code>State</code>类，也是基于此 ，动画通常需要在有状态组件中的<code>State</code>里面实现。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">mixin</span> TickerProviderStateMixin&lt;T <span class="hljs-keyword">extends</span> StatefulWidget&gt; <span class="hljs-keyword">on</span> State&lt;T&gt; <span class="hljs-keyword">implements</span> TickerProvider &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果我们使用<code>GetX</code>框架的话，它也为我们提供了<code>GetTickerProviderStateMixin</code>和<code>GetSingleTickerProviderStateMixin</code>这两个混入类，它们限定的混入基类是<code>GetxController</code>，这样我们就可以在<code>Controller</code>中作动画的实现了。</p><p>而在回调方法中，值的计算实际上又是交由<code>_simulation.x()</code>来进行计算的。所以先看下<code>Simulation</code>：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Simulation</span> </span>&#123;<br>  Simulation(&#123;<span class="hljs-keyword">this</span>.tolerance = Tolerance.defaultTolerance&#125;);<br>  <span class="hljs-comment">// 距离</span><br>  <span class="hljs-built_in">double</span> x(<span class="hljs-built_in">double</span> time);<br>  <span class="hljs-comment">// 变化的距离</span><br>  <span class="hljs-built_in">double</span> dx(<span class="hljs-built_in">double</span> time);<br>  <span class="hljs-comment">// 是否已经结束</span><br>  <span class="hljs-built_in">bool</span> isDone(<span class="hljs-built_in">double</span> time);<br>  <span class="hljs-comment">// 存储信息，距离+时间+速度</span><br>  Tolerance tolerance;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">String</span> toString() =&gt; objectRuntimeType(<span class="hljs-keyword">this</span>, <span class="hljs-string">&#x27;Simulation&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>它是在动画开启时构建实例的，即在<code>AnimationController.formard()</code>时创建的：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimationController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animation</span>&lt;<span class="hljs-title">double</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">// 启动动画</span><br>  TickerFuture forward(&#123;<span class="hljs-built_in">double?</span> from&#125;) &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> _animateToInternal(upperBound);<br>  &#125;<br>    <br>  TickerFuture _animateToInternal(<br>    <span class="hljs-built_in">double</span> target, &#123;<br>    <span class="hljs-built_in">Duration?</span> duration,<br>    Curve curve = Curves.linear,<br>  &#125;) &#123;<br>    ...<br>    <span class="hljs-built_in">Duration?</span> simulationDuration = duration;<br>    <span class="hljs-keyword">return</span> _startSimulation(<br>      <span class="hljs-comment">// 这里创建的Simulation实例</span><br>      _InterpolationSimulation(_value, target, simulationDuration, curve, scale),<br>    );<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在启动动画的逻辑<code>forward</code>中，最终会创建一个<code>_InterpolationSimulation</code>的示例来执行动画。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_InterpolationSimulation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Simulation</span> </span>&#123;<br>  _InterpolationSimulation(<span class="hljs-keyword">this</span>._begin, <span class="hljs-keyword">this</span>._end, <span class="hljs-built_in">Duration</span> duration, <span class="hljs-keyword">this</span>._curve, <span class="hljs-built_in">double</span> scale)<br>    : <span class="hljs-keyword">assert</span>(duration.inMicroseconds &gt; <span class="hljs-number">0</span>),<br>      _durationInSeconds = (duration.inMicroseconds * scale) / <span class="hljs-built_in">Duration</span>.microsecondsPerSecond;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> _durationInSeconds;<span class="hljs-comment">// 时长</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> _begin;<span class="hljs-comment">// 开始值</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> _end;<span class="hljs-comment">// 结束值</span><br>  <span class="hljs-keyword">final</span> Curve _curve;<span class="hljs-comment">// Curve曲线</span><br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">double</span> x(<span class="hljs-built_in">double</span> timeInSeconds) &#123;<br>    <span class="hljs-comment">// 根据时长计算进度</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> t = clampDouble(timeInSeconds / _durationInSeconds, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (t) &#123;<br>      <span class="hljs-number">0.0</span> =&gt; _begin,<br>      <span class="hljs-number">1.0</span> =&gt; _end,<br>      <span class="hljs-comment">// 根据进度计算值</span><br>      _ =&gt; _begin + (_end - _begin) * _curve.transform(t),<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">double</span> dx(<span class="hljs-built_in">double</span> timeInSeconds) &#123;<br>    <span class="hljs-comment">// 1e-3</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> epsilon = tolerance.time;<br>    <span class="hljs-comment">// 取当前时间点的前后各1e-3的时间段内的进度值变化，可近似理解为速度</span><br>    <span class="hljs-keyword">return</span> (x(timeInSeconds + epsilon) - x(timeInSeconds - epsilon)) / (<span class="hljs-number">2</span> * epsilon);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> isDone(<span class="hljs-built_in">double</span> timeInSeconds) =&gt; timeInSeconds &gt; _durationInSeconds;<br>&#125;<br></code></pre></td></tr></table></figure><p>即在<code>Simulation</code>中，还是以时间为单位，计算进度。但这样的进度其实是属于线性进度，于是它又通过<code>Curve</code>将线性进度转换成<code>Curve</code>对应的曲线进度。到这里，能够拿到进度后，获取值就简单了，直接将进度传入<code>Animatable</code>中由其根据进度计算新值。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="dart hljs">AnimationController(&#123;<br>    <span class="hljs-built_in">double?</span> value, <span class="hljs-comment">// 初始进度</span><br>    <span class="hljs-keyword">this</span>.duration, <span class="hljs-comment">// 动画时长</span><br>    <span class="hljs-keyword">this</span>.reverseDuration, <span class="hljs-comment">// 反转动画时长</span><br>    <span class="hljs-keyword">this</span>.debugLabel, <span class="hljs-comment">// 调试标签</span><br>    <span class="hljs-keyword">this</span>.lowerBound = <span class="hljs-number">0.0</span>, <span class="hljs-comment">// 进度下限</span><br>    <span class="hljs-keyword">this</span>.upperBound = <span class="hljs-number">1.0</span>, <span class="hljs-comment">// 进度上线</span><br>    <span class="hljs-keyword">this</span>.animationBehavior = AnimationBehavior.normal,<span class="hljs-comment">// 动画行为</span><br>    <span class="hljs-keyword">required</span> TickerProvider vsync, <span class="hljs-comment">// vsync信号</span><br>&#125;)   <br></code></pre></td></tr></table></figure><p>在构造方法中，我们可以传入的参数非常多，都是与动画相关的，一般情况下我们只需要传<code>duration</code>时长、<code>vsync</code>提供者即可。简单总结下，<code>AnimationController</code>就是一个简单的动画控制器，它的主要作用就是监听<code>vsync</code>信号，然后在收到信号后计算进度值，所以它变化的一直都是进度值，即0~1范围内进行变化，如果想要对应到具体的值，则需要再配合<code>Animatable</code>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 定义一个动画控制器，时长2秒</span><br><span class="hljs-keyword">final</span> animCtrl = AnimationController(<br>  duration: <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>),<br>  vsync: <span class="hljs-keyword">this</span>,<br>);<br><span class="hljs-comment">// 定义一个int值变化的动画</span><br><span class="hljs-keyword">final</span> intAnimation = IntTween(begin: <span class="hljs-number">10</span>, end: <span class="hljs-number">100</span>).animate(animCtrl);<br><span class="hljs-comment">// 定义一个Color值变化的动画</span><br><span class="hljs-keyword">final</span> colorAnimation = ColorTween(<br>  begin: Colors.red,<br>  end: Colors.blue,<br>).animate(animCtrl);<br><br>animCtrl<br>  <span class="hljs-comment">// 添加值监听，每次进度变化后都可以通过value获取值</span><br>  ..addListener(() &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;int = <span class="hljs-subst">$&#123;intAnimation.value&#125;</span>, color = <span class="hljs-subst">$&#123;colorAnimation.value&#125;</span>&#x27;</span>);<br>  &#125;)<br>  <span class="hljs-comment">// 添加状态监听：dismiss,forward,reverse,complete等</span><br>  ..addStatusListener((status) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;status change to <span class="hljs-subst">$&#123;status&#125;</span>&#x27;</span>);<br>  &#125;)<br>  ..forward();<span class="hljs-comment">// 开始执行动画</span><br></code></pre></td></tr></table></figure><p>其实在整个动画逻辑中，<code>AnimtionController</code>作为动画控制器能够响应时间的线性变化，它内部的<code>Curve</code>作为估值器来根据时间的线性变化计算出进度的变化，<code>Animatable</code>作为插值器根据进度的变化来计算出值的变化。</p><p><code>AnimationController</code>内部的<code>Curve</code>默认是线性的，并且没有暴露给我们自定义，因此我们需要通过别的方式引入<code>Curve</code>。</p><h3 id="CurvedAnimation"><a href="#CurvedAnimation" class="headerlink" title="CurvedAnimation"></a>CurvedAnimation</h3><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurvedAnimation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animation</span>&lt;<span class="hljs-title">double</span>&gt; <span class="hljs-title">with</span> <span class="hljs-title">AnimationWithParentMixin</span>&lt;<span class="hljs-title">double</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// parent是控制器</span><br>  CurvedAnimation(&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.parent, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.curve, <span class="hljs-keyword">this</span>.reverseCurve&#125;) &#123;<br>    ...<br>  &#125;<br>  ...<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> value &#123;<br>    <span class="hljs-keyword">final</span> Curve? activeCurve = _useForwardCurve ? curve : reverseCurve;<br>    <span class="hljs-comment">// 拿到控制器的进度值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> t = parent.value;<br>    <span class="hljs-keyword">if</span> (activeCurve == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0.0</span> || t == <span class="hljs-number">1.0</span>) &#123;<br>      <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-comment">// 通过curve转换</span><br>    <span class="hljs-keyword">return</span> activeCurve.transform(t);<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只看获取<code>value</code>的方法，其实也没做什么，就是在拿到进度值后，再通过<code>Curve</code>进行转换，这样我们就可以使用自定义的<code>Curve</code>了。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">final</span> animCtrl = AnimationController(<br>  duration: <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>),<br>  vsync: <span class="hljs-keyword">this</span>,<br>);<br><span class="hljs-comment">// 注意这里定义了一个CurvedAnim</span><br><span class="hljs-keyword">final</span> curvedAnim = CurvedAnimation(parent: animCtrl, curve: Curves.linear);<br><br><span class="hljs-keyword">final</span> intAnimation = IntTween(begin: <span class="hljs-number">10</span>, end: <span class="hljs-number">100</span>).animate(curvedAnim);<span class="hljs-comment">// 让它们与CurvedAnim关联</span><br><br><span class="hljs-keyword">final</span> colorAnimation = ColorTween(<br>  begin: Colors.red,<br>  end: Colors.blue,<br>).animate(curvedAnim);<span class="hljs-comment">// 让它们与CurvedAnim关联</span><br><br>animCtrl<br>  ..addListener(() &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;int = <span class="hljs-subst">$&#123;intAnimation.value&#125;</span>, color = <span class="hljs-subst">$&#123;colorAnimation.value&#125;</span>&#x27;</span>);<br>  &#125;)<br>  ..addStatusListener((status) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;status change to <span class="hljs-subst">$&#123;status&#125;</span>&#x27;</span>);<br>  &#125;)<br>  ..forward();<br></code></pre></td></tr></table></figure><p>其实变化的部分就是在<code>animCtrl</code>之后又定义了一个<code>CurvedAnim</code>，并且其他<code>Animatable</code>直接与<code>curvedAnim</code>关联，而不是直接与<code>animCtrl</code>关联。</p><h4 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h4><p><code>Curve</code>是一个曲线类，它内部实际上定义的是一个函数，这个函数的输入<code>x</code>的取值范围是<code>0 ≤ X ≤ 1</code>，输出值<code>f(x)</code>的起点是0，终点是1，但是中间值可能会小于0或者大于1。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Curve</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParametricCurve</span>&lt;<span class="hljs-title">double</span>&gt; </span>&#123;<br>  ...<br>  <span class="hljs-comment">// 重点是这个方法</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">double</span> transform(<span class="hljs-built_in">double</span> t) &#123;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0.0</span> || t == <span class="hljs-number">1.0</span>) &#123;<br>      <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.transform(t);<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>它内部已经为我们定义了很多的<code>Curve</code>，我们可以通过<code>Curves</code>来直接使用：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="dart hljs">[Curves.fastLinearToSlowEaseIn]<br>[Curves.ease]<br>[Curves.easeIn]<br>[Curves.easeInToLinear]<br>[Curves.easeInSine]<br>[Curves.easeInQuad]<br>[Curves.easeInCubic]<br>[Curves.easeInQuart]<br>[Curves.easeInQuint]<br>[Curves.easeInExpo]<br>[Curves.easeInCirc]<br>[Curves.easeInBack]<br>[Curves.easeOut]<br>[Curves.linearToEaseOut]<br>[Curves.easeOutSine]<br>[Curves.easeOutQuad]<br>[Curves.easeOutCubic]<br>[Curves.easeOutQuart]<br>[Curves.easeOutQuint]<br>[Curves.easeOutExpo]<br>[Curves.easeOutCirc]<br>[Curves.easeOutBack]<br>[Curves.easeInOut]<br>[Curves.easeInOutSine]<br>[Curves.easeInOutQuad]<br>[Curves.easeInOutCubic]<br>[Curves.easeInOutQuart]<br>[Curves.easeInOutQuint]<br>[Curves.easeInOutExpo]<br>[Curves.easeInOutCirc]<br>[Curves.easeInOutBack]<br>[Curves.fastOutSlowIn]<br>[Curves.slowMiddle]<br></code></pre></td></tr></table></figure><p>实际上我们用这些并不多，线性的可能用的比较多一些，其他的就需要看动效工程师给我们的参数来自定义<code>Curve</code>了。</p><h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><p>其实前面的几个实例已经表明了如何去使用动画，只是没有实际应用到界面中去，这里简单展示一个用法：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 定义一个有状态组件，这是为了混入Ticker</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAnimationWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyAnimationWidget(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyAnimationWidget&gt; createState() =&gt; _MyAnimationWidgetState();<br>&#125;<br><br><span class="hljs-comment">// 在State上混入TickerProviderStateMixin，用于提供vsync</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyAnimationWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyAnimationWidget</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">TickerProviderStateMixin</span> </span>&#123;<br>  <span class="hljs-comment">// 动画要变的属性</span><br>  <span class="hljs-built_in">double</span> _size = <span class="hljs-number">100</span>;<br>  Color _color = Colors.blue;<br><br>  <br>  <span class="hljs-keyword">void</span> _startAnim() &#123;<br>    <span class="hljs-comment">// 定义一个动画控制器</span><br>    <span class="hljs-keyword">final</span> animCtrl = AnimationController(<br>      duration: <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>),<br>      vsync: <span class="hljs-keyword">this</span>,<br>    );<br>    <span class="hljs-keyword">final</span> curveAnim = CurvedAnimation(parent: animCtrl, curve: Curves.linear);<br>    <span class="hljs-keyword">final</span> sizeAnim = Tween&lt;<span class="hljs-built_in">double</span>&gt;(begin: <span class="hljs-number">100</span>, end: <span class="hljs-number">300</span>).animate(curveAnim);<br>    <span class="hljs-keyword">final</span> colorAnimation = ColorTween(<br>      begin: Colors.blue,<br>      end: Colors.red,<br>    ).animate(curveAnim);<br>    animCtrl<br>      ..addListener(() &#123;<br>        <span class="hljs-comment">// 在监听回调里，通过setState更新数据并触发重建，从而响应动画</span><br>        setState(() &#123;<br>          _size = sizeAnim.value;<br>          _color = colorAnimation.value!;<br>        &#125;);<br>      &#125;)<br>      ..forward();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Container(<br>      <span class="hljs-comment">// 使用状态属性</span><br>      width: _size,<br>      height: _size,<br>      color: _color,<br>      <span class="hljs-comment">// 点击按钮时执行动画</span><br>      child: TextButton(onPressed: _startAnim, child: Text(<span class="hljs-string">&#x27;Animation&#x27;</span>)),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式属于比较底层的用法，主要就是触发动画去对状态值做一个逐渐变化的效果，然后触发刷新使界面进行响应，由此形成动画。并且，还需要在每个动画执行的地方自定义一个有状态组件，非常麻烦。而<code>Flutter</code>则帮我们内置了很多常用的组件可以让我们直接进行动画，也就是常说的隐式动画：</p><h4 id="ImplicitlyAnimatedWidget"><a href="#ImplicitlyAnimatedWidget" class="headerlink" title="ImplicitlyAnimatedWidget"></a>ImplicitlyAnimatedWidget</h4><p>隐式动画说的就是<code>ImplicitlyAnimatedWidget</code>，其实就是将动画的执行细节封装在了内部，这样我们其实只需要传入几个关键的属性就能完成动画的执行效果，而不需要重头去写<code>AnimationController</code>、<code>Tween</code>或者<code>CurvedAnimation</code>了。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImplicitlyAnimatedWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> ImplicitlyAnimatedWidget(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-keyword">this</span>.curve = Curves.linear,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.duration,<br>    <span class="hljs-keyword">this</span>.onEnd,<br>  &#125;);<br>  <span class="hljs-keyword">final</span> Curve curve;<span class="hljs-comment">// curve</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Duration</span> duration;<span class="hljs-comment">// 时长</span><br>  <span class="hljs-keyword">final</span> VoidCallback? onEnd;<span class="hljs-comment">// 动画结束时的回调</span><br><br>  <span class="hljs-meta">@override</span><br>  ImplicitlyAnimatedWidgetState&lt;ImplicitlyAnimatedWidget&gt; createState<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是使用隐式动画实际上只需要传入<code>curve</code>和时长即可，其他的都由隐式动画组件内部进行操作。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImplicitlyAnimatedWidgetState</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImplicitlyAnimatedWidget</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class">    // 混入这个类来提供<span class="hljs-title">vsync</span></span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">SingleTickerProviderStateMixin</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">// 构建controller  </span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> AnimationController controller = AnimationController(<br>    duration: widget.duration,<br>    debugLabel: kDebugMode ? widget.toStringShort() : <span class="hljs-keyword">null</span>,<br>    vsync: <span class="hljs-keyword">this</span>,<br>  );<br><br>  <span class="hljs-comment">// 使用animation时，会通过_createCurve来构建</span><br>  Animation&lt;<span class="hljs-built_in">double</span>&gt; <span class="hljs-keyword">get</span> animation =&gt; _animation;<br>  <span class="hljs-keyword">late</span> CurvedAnimation _animation = _createCurve();<br><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// 初始化时添加状态监听，这是为了onEnd回调</span><br>    controller.addStatusListener((AnimationStatus status) &#123;<br>      <span class="hljs-keyword">if</span> (status.isCompleted) &#123;<br>        widget.onEnd?.call();<br>      &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 构建Tween</span><br>    _constructTweens();<br>    <span class="hljs-comment">// 更新Tween，这个是空实现</span><br>    didUpdateTweens();<br>  &#125;<br><br>  <span class="hljs-comment">// 父组件setState时，会走到这里来</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> didUpdateWidget(T oldWidget) &#123;<br>    <span class="hljs-keyword">super</span>.didUpdateWidget(oldWidget);<br>    <span class="hljs-keyword">if</span> (widget.curve != oldWidget.curve) &#123;<br>      _animation.dispose();<br>      _animation = _createCurve();<br>    &#125;<br>    controller.duration = widget.duration;<br>    <span class="hljs-comment">// 重新构建tween，如果target与tween的end值不一致，说明需要执行动效</span><br>    <span class="hljs-keyword">if</span> (_constructTweens()) &#123;<br>      forEachTween((<br>        Tween&lt;<span class="hljs-built_in">dynamic</span>&gt;? tween,<br>        <span class="hljs-built_in">dynamic</span> targetValue,<br>        TweenConstructor&lt;<span class="hljs-built_in">dynamic</span>&gt; constructor,<br>      ) &#123;<br>        <span class="hljs-keyword">return</span> tween<br>          <span class="hljs-comment">// 将起始值改为当前的值，这样后续执行动画就能接着执行，而不会重新开始</span><br>          ?..begin = tween.evaluate(_animation)<br>          ..end = targetValue;<br>      &#125;);<br>      controller.forward(from: <span class="hljs-number">0.0</span>);<br>      didUpdateTweens();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 根据curve构建CurvedAnimation</span><br>  CurvedAnimation _createCurve() &#123;<br>    <span class="hljs-keyword">return</span> CurvedAnimation(parent: controller, curve: widget.curve);<br>  &#125;<br><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    _animation.dispose();<br>    controller.dispose();<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-built_in">bool</span> _constructTweens() &#123;<br>    <span class="hljs-built_in">bool</span> shouldStartAnimation = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 调用forEachTween来构建tween</span><br>    forEachTween((<br>      Tween&lt;<span class="hljs-built_in">dynamic</span>&gt;? tween,<br>      <span class="hljs-built_in">dynamic</span> targetValue,<br>      TweenConstructor&lt;<span class="hljs-built_in">dynamic</span>&gt; constructor,<br>    ) &#123;<br>      <span class="hljs-keyword">if</span> (targetValue != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 构建Tween</span><br>        tween ??= constructor(targetValue);<br>        <span class="hljs-comment">// 目标值与end值不一致，则需要重新执行动画</span><br>        <span class="hljs-keyword">if</span> (targetValue != (tween.end ?? tween.begin)) &#123;<br>          shouldStartAnimation = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          tween.end ??= tween.begin;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        tween = <span class="hljs-keyword">null</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> tween;<br>    &#125;);<br>    <span class="hljs-comment">// 是否需要重新执行动画</span><br>    <span class="hljs-keyword">return</span> shouldStartAnimation;<br>  &#125;<br><br>  <span class="hljs-comment">// 遍历所有的Tween或者生成新的Tween</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> forEachTween(TweenVisitor&lt;<span class="hljs-built_in">dynamic</span>&gt; visitor);<br><br>  <span class="hljs-comment">// Tween发生了变化的回调,通常在这里面将tween进行驱动</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> didUpdateTweens() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所有的动画逻辑<code>ImplicitlyAnimatedWidgetState</code>进行封装，包括动画的开始与执行，界面刷新时的重新设置的处理逻辑等，如果我们需要做动效，则只需要继承它们即可。</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-comment">// 构建一个用于显示和隐藏动画的组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisibleWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImplicitlyAnimatedWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> _<span class="hljs-keyword">show</span>; <span class="hljs-comment">// 当前组件是否显示</span><br>  <span class="hljs-keyword">final</span> Widget child;<span class="hljs-comment">// 子组件</span><br><br>  <span class="hljs-keyword">const</span> VisibleWidget(&#123;<br>    <span class="hljs-keyword">super</span>.key,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">super</span>.duration,<br>    <span class="hljs-keyword">required</span> <span class="hljs-built_in">bool</span> <span class="hljs-keyword">show</span>,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.child,<br>  &#125;) : _<span class="hljs-keyword">show</span> = <span class="hljs-keyword">show</span>;<br><br>  <span class="hljs-meta">@override</span><br>  ImplicitlyAnimatedWidgetState&lt;VisibleWidget&gt; createState() &#123;<br>    <span class="hljs-keyword">return</span> _VisibleState();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 主要逻辑都在State中</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_VisibleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImplicitlyAnimatedWidgetState</span>&lt;<span class="hljs-title">VisibleWidget</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 做显示的Tween</span><br>  Tween&lt;<span class="hljs-built_in">double</span>&gt;? visibleTween;<br>  <span class="hljs-comment">// 组合在一块的动画</span><br>  <span class="hljs-keyword">late</span> Animation&lt;<span class="hljs-built_in">double</span>&gt; visibleAnim;<br><br>  <span class="hljs-comment">// 遍历每一个tween</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> forEachTween(TweenVisitor&lt;<span class="hljs-built_in">dynamic</span>&gt; visitor) &#123;<br>    <span class="hljs-comment">// 使用visitor参数遍历每一个tween</span><br>    visibleTween = visitor.call(<br>        <span class="hljs-comment">// 原Tween，如果是空，则会使用第三个参数来构建Tween</span><br>        visibleTween,<br>        <span class="hljs-comment">// Tween的目标值，如果与老的Tween数据不一致，则会更新Tween</span><br>        widget._<span class="hljs-keyword">show</span> ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>,<br>        <span class="hljs-comment">// 构建新的Tween，注意这里构建时只传入了一个参数，这是因为要在第一次构建时能够直接</span><br>        <span class="hljs-comment">// 显示出目标值</span><br>        (<span class="hljs-built_in">dynamic</span> target) =&gt; Tween&lt;<span class="hljs-built_in">double</span>&gt;(begin: target),<br>    ) <span class="hljs-keyword">as</span> Tween&lt;<span class="hljs-built_in">double</span>&gt;?;<br>  &#125;<br>    <br> <br>  <span class="hljs-comment">// 在Tween更新时，将tween与animController进行关联</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> didUpdateTweens() &#123;<br>    visibleAnim = animation.drive(visibleTween!);<br>  &#125;<br>    <br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 通过ListenableBuilder监听Animation的变化，它会在每次变化时刷新builder</span><br>    <span class="hljs-keyword">return</span> ListenableBuilder(<br>      listenable: visibleAnim,<br>      builder: (_, _) &#123;<br>        <span class="hljs-comment">// 通过Opacity控制透明度</span><br>        <span class="hljs-keyword">return</span> Opacity(opacity: visibleAnim.value, child: widget.child);<br>      &#125;,<br>    );<br>  &#125;<br>    <br>  <span class="hljs-comment">// 或者不用ListenableBuilder </span><br>  <span class="hljs-comment">// @override</span><br>  <span class="hljs-comment">//Widget build(BuildContext context) &#123;</span><br>  <span class="hljs-comment">//   return Opacity(opacity: visibleAnim.value, child: widget.child);</span><br>  <span class="hljs-comment">//&#125;</span><br><br>  <span class="hljs-comment">// 可以在构建Animation的时候添加监听，然后setState触发刷新 </span><br>  <span class="hljs-comment">// @override</span><br>  <span class="hljs-comment">//void didUpdateTweens() &#123;</span><br>  <span class="hljs-comment">//  visibleAnim = animation.drive(visibleTween!)</span><br>  <span class="hljs-comment">//      ..addListener(() &#123;setState(() &#123;&#125;);&#125;);</span><br>  <span class="hljs-comment">// &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就定义好了一个用于做渐隐渐现的动画效果，使用起来也很简单，当然也是需要基于有状态组件的，因为它的状态仍是由外部传递进来的，而不是自己处理的：</p><figure class="dart highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAnimationWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyAnimationWidget(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;MyAnimationWidget&gt; createState() =&gt; _MyAnimationWidgetState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyAnimationWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyAnimationWidget</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 内部控制一个属性</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">show</span> = <span class="hljs-keyword">true</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        <span class="hljs-comment">// 前面封装的组件</span><br>        VisibleWidget(<br>          duration: <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>),<br>          <span class="hljs-comment">// 传入状态值</span><br>          <span class="hljs-keyword">show</span>: <span class="hljs-keyword">show</span>,<br>          child: Container(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>, color: Colors.red),<br>        ),<br>        ElevatedButton(<br>          onPressed: () &#123;<br>            <span class="hljs-comment">// 点击按钮时通过setState更新状态值，此时就会执行动画</span><br>            setState(() &#123;<br>              <span class="hljs-keyword">show</span> = !<span class="hljs-keyword">show</span>;<br>            &#125;);<br>          &#125;,<br>          child: Text(<span class="hljs-string">&#x27;Button&#x27;</span>),<br>        ),<br>      ],<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，其实这些基本动画的组件都被内置到<code>Flutter</code>中了，它们都是以<code>Animated</code>开头的组件，如：<code>AnimatedOpacity</code>、<code>AnimatedPadding</code>等等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里关于<code>Flutter</code>的动画部分就已经讲完了，它的核心逻辑就是<code>AnimationController</code>来接收<code>vsync</code>信号并记录当前动画应该要执行的进度值，然后通过<code>Tween</code>来定义动画的初始值和目标值，最后通过<code>controller.drive</code>或者<code>tween.animate</code>方法将二者进行关联形成一个新的<code>Animation</code>，然后就能通过读取这个新的<code>Animation</code>的<code>value</code>来获取到动画的值了。</p><p>基于此，<code>Flutter</code>还封装了很多常用的组件并且帮我们实现了对应的动画效果，使得我们可以快速使用。它们在命名上采用<code>Animated</code>开头，如<code>AnimatedOpacity</code>等，这一类的组件基本上都是封装好的带动画的组件。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Wed Jan 01 2025 22:03:47 GMT+0800");let n="Wed Jan 01 2025 22:03:47 GMT+0800";n="2025-11-13 17:33:51 +0800";var a=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-a)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Flutter/" class="post-footer-category">#&nbsp;Flutter</a> <a href="/tags/Flutter/" class="post-footer-tag">#&nbsp;Flutter</a></div><div class="nav"><div class="nav-item-prev"></div><div class="nav-item-next"><a href="/2024/12/20/flutter-getx-source/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">GetX原理分析</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#%E5%8A%A8%E7%94%BB" class="toc-link"><span class="toc-text">动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#Animatable" class="toc-link"><span class="toc-text">Animatable</span></a></li><li class="toc-item toc-level-3"><a href="#Animation" class="toc-link"><span class="toc-text">Animation</span></a></li><li class="toc-item toc-level-3"><a href="#Tween" class="toc-link"><span class="toc-text">Tween</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#ReverseTween" class="toc-link"><span class="toc-text">ReverseTween</span></a></li><li class="toc-item toc-level-4"><a href="#ColorTween" class="toc-link"><span class="toc-text">ColorTween</span></a></li><li class="toc-item toc-level-4"><a href="#SizeTween" class="toc-link"><span class="toc-text">SizeTween</span></a></li><li class="toc-item toc-level-4"><a href="#RectTween" class="toc-link"><span class="toc-text">RectTween</span></a></li><li class="toc-item toc-level-4"><a href="#IntTween-StepTween" class="toc-link"><span class="toc-text">IntTween &amp; StepTween</span></a></li><li class="toc-item toc-level-4"><a href="#ConstantTween" class="toc-link"><span class="toc-text">ConstantTween</span></a></li><li class="toc-item toc-level-4"><a href="#CurveTween" class="toc-link"><span class="toc-text">CurveTween</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#AnimationController" class="toc-link"><span class="toc-text">AnimationController</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E7%A4%BA%E4%BE%8B" class="toc-link"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#CurvedAnimation" class="toc-link"><span class="toc-text">CurvedAnimation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E7%A4%BA%E4%BE%8B-1" class="toc-link"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a href="#Curve" class="toc-link"><span class="toc-text">Curve</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E7%94%BB" class="toc-link"><span class="toc-text">使用动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#ImplicitlyAnimatedWidget" class="toc-link"><span class="toc-text">ImplicitlyAnimatedWidget</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-12-20</div><a href="/2024/12/20/flutter-getx-source/"><div class="recent-posts-item-content">GetX原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-09-10</div><a href="/2024/09/10/flutter-state/"><div class="recent-posts-item-content">Flutter状态管理</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-08-16</div><a href="/2024/08/16/flutter-canvas/"><div class="recent-posts-item-content">Flutter自定义绘制CustomPaint</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2025-01-01</div><a href="/2025/01/01/flutter-animation/"><div class="recent-posts-item-content">Flutter动画</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-12-20</div><a href="/2024/12/20/flutter-getx-source/"><div class="recent-posts-item-content">GetX原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>