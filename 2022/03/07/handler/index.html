<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Handler从Java到Native</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>33</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>15</span> <span>标签</span> </a><a class="author-word-count"><span>12.83</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" class="toc-link"><span class="toc-text">简单介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#Handler" class="toc-link"><span class="toc-text">Handler</span></a></li><li class="toc-item toc-level-3"><a href="#Message" class="toc-link"><span class="toc-text">Message</span></a></li><li class="toc-item toc-level-3"><a href="#Looper" class="toc-link"><span class="toc-text">Looper</span></a></li><li class="toc-item toc-level-3"><a href="#MessageQueue" class="toc-link"><span class="toc-text">MessageQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#Java%E5%B1%82%E6%BA%90%E7%A0%81" class="toc-link"><span class="toc-text">Java层源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%B0%8F%E7%BB%93" class="toc-link"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#Native%E5%B1%82%E6%BA%90%E7%A0%81" class="toc-link"><span class="toc-text">Native层源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%B0%8F%E7%BB%93-1" class="toc-link"><span class="toc-text">小结</span></a></li></ol></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Handler从Java到Native thumbnail" class="lozad image" src="/img/cover/cover-handler.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Handler从Java到Native</h1></header><div class="post-meta post-show-meta"><time datetime="2022-03-07T04:33:47.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2022-03-07</span> </time><span class="dot"></span> <a href="/categories/Android-Framework/" class="post-meta-link">Android Framework </a><span class="dot"></span> <span>约8.4k 字</span></div><div class="post-content" id="section"><p><code>Handler</code>是我们非常熟悉的一个组件，它的主要作用就是进行线程间的交互，通常是主线程与其他工作线程间的交互。这套消息机制在应用开发中用的是最多的，我们使用它来实现切换主线程、发送延时消息等。它主要由<code>Handler</code>、<code>Looper</code>、<code>MessageQueue</code>三个组件组成，其中<code>Handler</code>负责发送和处理消息，<code>Looper</code>负责循环读取消息，<code>MessageQueue</code>负责存储消息。</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>整套消息机制我们应该非常熟悉了，具体的使用就不再赘述，这里只简单介绍下各个组件的作用。本文基于<code>Android 13</code>源码。</p><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p><code>Handler</code>负责发送消息和处理消息，发送的消息主要是普通消息和<code>Runnable</code>消息，通常使用<code>post</code>、<code>postAtTime</code>、<code>postDelayed</code>发送<code>Runnable</code>消息，通过<code>sendEmptyMessage</code>、<code>sendMessage</code>、<code>sendMessageAtTime</code>、<code>sendMessageDelayed</code>发送普通消息。</p><p>这些消息被发送时，都会在消息上指明<code>target</code>为当前<code>Handler</code>，而等到消息执行时，就会将消息指派给它对应的<code>Handler</code>进行处理。</p><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p><code>Message</code>是消息的载体，对于普通消息，可以直接通过它的<code>what</code>属性进行区分，通过<code>arg1</code>和<code>arg2</code>承载简单的数据，通过<code>obj</code>承载复杂的对象数据；对于<code>Runnable</code>消息，通过它的<code>callback</code>属性进行承载。同时，<code>Message</code>是被设计成单链表结构的，以及一个消息池，被用过的<code>Message</code>就会被放在消息池中等待复用，消息池就是一个单链表结构。因此如果我们创建<code>Message</code>的时候，最好通过<code>Message.obtain</code>方法创建而不是直接<code>new</code>以复用<code>Message</code>。</p><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p><code>Looper</code>是一个消息机制中的驱动模块，它会循环读取消息队列中的消息，然后将其分发给对应的<code>Handler</code>进行处理。当消息队列为空或者没有可执行的消息时，它会阻塞当前线程，当有了可执行的消息时会被唤醒继续循环读取。</p><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>消息队列<code>MessageQueue</code>，主要作用是存储消息，各个<code>Handler</code>发送的消息都会进入消息队列，并且按照消息的执行时间进行排序，时间靠前的排在前面。当<code>Looper</code>获取消息时，从前向后读取消息，如果消息的执行时间在当前时间之后，就会阻塞一直到执行时间后恢复。</p><h2 id="Java层源码"><a href="#Java层源码" class="headerlink" title="Java层源码"></a>Java层源码</h2><p>我们知道<code>Handler</code>是可以跨线程进行交互的，那么如何跨线程呢？首先线程间的数据本身就是可以共享的，我们可以在某个线程中定义一个数据结构，然后在另一个线程中向这个数据结构中写入数据，这样两个线程就可以交换数据了。生产者消费者模式就是这个原理，而<code>Handler</code>消息机制，本质上也是这个原理。</p><p>在<code>Handler</code>消息机制中，<code>MessageQueue</code>就是这个共享的数据结构，它存在于<code>Looper</code>中，也就是说如果我们想要在某个线程中启用<code>Handler</code>消息机制，则必须创建一个<code>Looper</code>。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>  mQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(quitAllowed);<br>  mThread = Thread.currentThread();<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Looper</code>的构造方法中会创建一个<code>MessageQueue</code>来接受数据，但是它是私有方法，无法直接创建，我们正常是通过<code>prepare</code>方法创建。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Looper&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">()</span> &#123;<br>  prepare(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>  <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>  &#125;<br>  sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><p>从<code>prepare</code>中可以看到，如果当前线程中已经创建过了<code>Looper</code>，则直接抛出异常，否则创建<code>Looper</code>并存入到<code>ThreadLocal</code>中，使得一个线程中只存在一个<code>Looper</code>，从而保障了一个线程只有一个<code>MessageQueue</code>。<code>ThreadLocal</code>是线程局部变量，它通常会被定义成静态变量供多个线程存储和获取变量的，本质上就是拿到线程的<code>ThreadLocalMap</code>，然后往里面存数据就行了，这个不需要过多的了解。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取到当前线程对应的Looper</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>    &#125;<br><br>     me.mInLoop = <span class="hljs-literal">true</span>;<br><br>     <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@Nullable</span> Looper <span class="hljs-title function_">myLooper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sThreadLocal.get();<br>&#125;<br></code></pre></td></tr></table></figure><p>创建完<code>Looper</code>之后，就通过<code>loop()</code>去循环读取<code>MessageQueue</code>中的消息了。注意<code>loop</code>是个死循环，当前线程的逻辑会一直卡在这里无法再做别的事情了。因此，我们必须在<code>prepare</code>和<code>loop</code>之间创建一个或多个<code>Handler</code>，然后将<code>Handler</code>提供出去以便其他线程向当前线程中发送消息，通常的写法如下：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Handler mHandler;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.run();<br>        Looper.prepare();<br>        mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.myLooper());<br>        Looper.loop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是主线程不是我们启动的，我们又该如何获取到<code>Handler</code>，如何创建<code>Looper</code>，然后向主线程发消息呢？</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Looper sMainLooper;<br><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMainLooper</span><span class="hljs-params">()</span> &#123;<br>  prepare(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;<br>    <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The main Looper has already been prepared.&quot;</span>);<br>    &#125;<br>    sMainLooper = myLooper();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主线程走的是另一个方法<code>prepareMainLooper</code>，当应用的主线程启动后，会调用<code>prepareMainLooper</code>创建<code>Looper</code>，并赋值给静态变量<code>sMainLooper</code>。因此对于应用而言，<code>sMainLooper</code>是不会为空的，我们也可以通过它来创建<code>Handler</code>。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mMainHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper);<br></code></pre></td></tr></table></figure><p>然后便是<code>Handler</code>了，由于<code>Handler</code>是用于发送消息的，所以<code>Handler</code>必须能够获取到<code>Looper</code>以便向它的<code>MessageQueue</code>中发送消息。因此，<code>Handler</code>构造方法中，必须传入<code>Looper</code>。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// 空参数构造方法，不建议使用</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 未提供Looper的构造方法，不建议使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>  ...<br>  <span class="hljs-comment">// 没有传入looper，直接从当前线程中获取Looper</span><br>  mLooper = Looper.myLooper();<br>  <span class="hljs-comment">// 当前线程没有启用Looper，直接抛异常</span><br>  <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>      <span class="hljs-string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()<br>          \+ <span class="hljs-string">&quot; that has not called Looper.prepare()&quot;</span>);<br>  &#125;<br>  mQueue = mLooper.mQueue;<br>  mCallback = callback;<br>  mAsynchronous = async;<br>  mIsShared = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 构造方法中传入Looper，推荐使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper)</span> &#123;<br>  <span class="hljs-built_in">this</span>(looper, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 不允许app使用</span><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper, <span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>  <span class="hljs-built_in">this</span>(looper, callback, async, <span class="hljs-comment">/* shared= */</span> <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 不允许app使用</span><br><span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper, <span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> shared)</span> &#123;<br>  mLooper = looper;<br>  mQueue = looper.mQueue;<br>  mCallback = callback;<br>  mAsynchronous = async;<br>  mIsShared = shared;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于空参数的构造方法，则直接从当前线程获取<code>Looper</code>，获取不到直接抛异常。当然，不带<code>Looper</code>的构造方法已经被标记为<code>Deprecated</code>了，再去掉其他的<code>hide</code>的方法等，我们实际使用中通常用的是<code>public Handler(@NonNull Looper looper)</code>这个构造方法。<br><code>Handler</code>有很多的发送消息的方法，但最终都是走到了同一个方法中去发送数据。并且最终也是通过<code>queue.enqueueMessage</code>加入到消息队列中。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,</span><br><span class="hljs-params">      <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>    <span class="hljs-comment">// 消息的target赋值为当前handler，最终message会交给target执行的handler执行</span><br>    msg.target = <span class="hljs-built_in">this</span>;<br>    msg.workSourceUid = ThreadLocalWorkSource.getUid();<br><br>    <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>       msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然<code>Handler</code>有很多的发送消息的方法，但最终也是调用了<code>queue.enqueueMessage</code>将消息传入到消息队列中。所以，它的这些方法只是为了方便我们使用而已，将一些参数进行拆分，方便我们快速编码。不管发送时传入的参数是什么，最终都会被构建成一个<code>Message</code>对象，这个<code>Message</code>就是消息的载体，它代表了一个消息。因为消息会有很多很多，为了避免频繁的创建和销毁，它被设计成一个单链表结构，并设计了一个消息池，消息池中存放的是用于重复利用的<code>Message</code>，他们以单链表的形式存在。因此，我们如果要直接发送<code>Message</code>的话，切记不要直接<code>new</code>，而是应该通过<code>Message.obtain</code>方法从消息池中获取，以达成重复利用的目的。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Parcelable</span> &#123;<br>    <span class="hljs-comment">// 用于区分消息类型，用户自定义</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> what;<br><br>    <span class="hljs-comment">// 消息可携带简单参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> arg1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> arg2;<br><br>    <span class="hljs-comment">// 消息可携带复杂对象</span><br>    <span class="hljs-keyword">public</span> Object obj;<br><br>    <span class="hljs-comment">// 标记当前消息是否正在被使用</span><br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-comment">/*package*/</span> <span class="hljs-type">int</span> flags;<br><br>    <span class="hljs-comment">// 消息具体的需要被执行的时间点，消息队列中以此参数排序</span><br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-meta">@VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-keyword">when</span>;<br><br>    <span class="hljs-comment">// 消息应该由哪个Handler处理执行</span><br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-comment">/*package*/</span> Handler target;<br><br>    <span class="hljs-comment">// 当前消息是一个可执行的代码块逻辑</span><br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-comment">/*package*/</span> Runnable callback;<br><br>    <span class="hljs-comment">// 单链表指针</span><br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-comment">/*package*/</span> Message next;<br>&#125;<br></code></pre></td></tr></table></figure><p>消息的结构比较简单，一个用于区分消息的参数，三个用于携带数据的参数，以及一个用于存储可执行代码块的参数，这里不需要详细解释，接下来继续看消息进入消息队列的逻辑。注意这里的消息队列<code>MessageQueue</code>只是名字叫做消息队列，它的结构实际不是一个队列的数据结构，而是一个以消息执行时间排序的<code>Message</code>为节点的单链表结构。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> <span class="hljs-keyword">when</span>)</span> &#123;<br>    <span class="hljs-comment">// 必须有target，正常发送的消息都有</span><br>    <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// message已经被用过了，没有被回收</span><br>        <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 正在退出looper，直接回收msg</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>              msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>            Log.w(TAG, e.getMessage(), e);<br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 标记为已使用的状态，并设置消息的执行时机</span><br>        msg.markInUse();<br>        msg.<span class="hljs-keyword">when</span> = <span class="hljs-keyword">when</span>;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>        <span class="hljs-comment">// 是否需要唤醒Looper</span><br>        <span class="hljs-type">boolean</span> needWake;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || <span class="hljs-keyword">when</span> == <span class="hljs-number">0</span> || <span class="hljs-keyword">when</span> &lt; p.<span class="hljs-keyword">when</span>) &#123;<br>            <span class="hljs-comment">// 队列中无数据，插入到表头</span><br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-literal">null</span> &amp;&amp; msg.isAsynchronous();<br>            Message prev;<br>            <span class="hljs-comment">// 遍历消息队列，按时间顺序插入消息</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || <span class="hljs-keyword">when</span> &lt; p.<span class="hljs-keyword">when</span>) &#123;<br>                    <span class="hljs-comment">// 需要执行的消息比当前消息早，则插入到它前面</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                    needWake = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 插入到消息的前面</span><br>            msg.next = p;<br>            prev.next = msg;<br>        &#125;<br>        <span class="hljs-comment">// 唤醒Looper</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>           nativeWake(mPtr);<br>        &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>整体看下来，在消息入队列时做了两件事：一是按照<code>Message.when</code>的时间顺序将新的<code>Message</code>插入到消息队列中，一是决定是否唤醒<code>Looper</code>线程。如果消息队列中没有消息并且当前<code>Looper</code>线程是阻塞的，则唤醒<code>Looper</code>。另外如果消息队列中有消息，但是<code>Looper</code>是阻塞的并且当前的消息是异步消息，则也唤醒<code>Looper</code>。</p><p>前面我们看到的<code>MessageQueue</code>插入数据的逻辑，实际上是发生在<code>Handler.sendMessage</code>所在的线程。因为我们开启<code>Looper</code>循环后，<code>Looper</code>所在的线程就会一直循环从<code>MessageQueue中</code>取数据，取不到时就会阻塞。因此，在<code>MQ</code>收到消息后，会选择是否唤起<code>Looper</code>来处理新来的消息。重新看回<code>Looper.loop</code>方法：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，<code>Looper</code>开启后就会一直死循环读取，而读取的逻辑则是发生在<code>loopOnce</code>中：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me,</span><br><span class="hljs-params">            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> &#123;<br>    <span class="hljs-comment">// 从消息队列中获取一个消息，可能会阻塞</span><br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> me.mQueue.next();<br>    <span class="hljs-comment">// 按照正常逻辑，msg不可能为空，因为获取不到消息时会阻塞，只有looper退出时才会返回null</span><br>    <span class="hljs-comment">// 当msg为空，也就代表着loop方法的结束，整个消息机制的结束。</span><br>    <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过Looper#setMessageLogging可以设置日志打印类，可以打印出每个消息的执行情况，</span><br>    <span class="hljs-comment">// 我们可以通过这个记录每个Message的执行实际，执行耗时等信息，可用于监控线程是否卡顿</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Printer</span> <span class="hljs-variable">logging</span> <span class="hljs-operator">=</span> me.mLogging;<br>    <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>        logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span><br>                + msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>    &#125;<br>    <span class="hljs-comment">// 这个类才是监控消息执行的，在消息执行前、执行后、以及发生异常时，都会有回调到</span><br>    <span class="hljs-comment">// observer中，这个类可以帮助我们监控消息队列的执行情况，比前面的logging更好用。</span><br>    <span class="hljs-comment">// 但是，它是hide的，我们正常情况下无法使用</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Observer</span> <span class="hljs-variable">observer</span> <span class="hljs-operator">=</span> sObserver;<br>    ...<br>    <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 消息执行前的回调</span><br>        token = observer.messageDispatchStarting();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 取出消息对应的handler，通过dispatchMessage处理消息</span><br>        msg.target.dispatchMessage(msg);<br>        <span class="hljs-comment">// 消息执行后的回调</span><br>        <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>            observer.messageDispatched(token, msg);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception exception) &#123;<br>        <span class="hljs-comment">// 异常时的回调</span><br>        <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>            observer.dispatchingThrewException(token, msg, exception);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> exception;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-comment">// 消息执行后的logging打印</span><br>    <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>        logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br>    &#125;<br>    <span class="hljs-comment">// 回收消息，会将消息状态重置，并标记未使用，然后放回到消息池中等待复用</span><br>    msg.recycleUnchecked();<br>    <span class="hljs-comment">// 返回true，因此在looper中会再次调用到loopOnce方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面的<code>loopOnce</code>从名字也能看出来是循环一次的意思，实际它的逻辑也是如此。首先通过<code>MessageQueue.next</code>取出一个消息，注意该消息一定不为空，因为取不到消息的时候会阻塞住，直到取到消息才会返回，当然如果<code>Looper</code>被退出的话是会返回<code>null</code>的，然后就是通过<code>Message</code>对应的<code>target</code>去<code>dispatchMessage</code>。从这里也能看到线程是如何切换的了，首先在其他线程通过<code>Handler</code>发送消息，这个消息会是一个数据或者一个代码块<code>Runnable</code>，然后被包装成<code>Message</code>，最终在<code>Looper</code>线程中通过<code>Handler.dispatchMessage</code>处理。</p><p>因此我们接下来的关注点有两点：一是<code>MessageQueue.next</code>是如何取消息的，一是<code>Handler.dispatchMessage</code>是如何处理消息的，先看<code>next</code>：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="java hljs">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// native的指针，用于阻塞和唤醒的</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// idleHandler的个数，用来控制避免重复执行的</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 阻塞时间，当没有消息时取值为-1，表示一直阻塞；有消息时但是不能执行，说明该消息的</span><br>    <span class="hljs-comment">// 执行时间是在未来的，因此取值为msg.when - now</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 这里也是一个死循环，说明如果取不到数据，是会继续循环去取，直到取到message为止，</span><br>    <span class="hljs-comment">// 因此说这个方法的返回值不会为null，除非Looper被quit才会返回null。</span><br>    <span class="hljs-keyword">for</span> (; ; ) &#123;<br>        <span class="hljs-comment">// 阻塞一段时间nextPollTimeoutMillis，第一次的时候该值为0不会被阻塞，</span><br>        <span class="hljs-comment">// 后续就可能会被阻塞住，直到第一个消息的执行时间点到达</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-comment">// target为空，说明msg是一个消息屏障</span><br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 遇到消息屏障后，该屏障后的所有普通消息不再执行，但是异步消息还是会执行的，</span><br>                <span class="hljs-comment">// 因此这里使用循环查找消息屏障后的第一个异步消息返回</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    prevMsg = msg;<br>                    msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 找到了消息，注意msg的初始值是mMessage，也就是消息队列的第一个值，因此</span><br>                <span class="hljs-comment">// 走到这里说明拿到了一个可能是正常消息，也可能是异步消息的消息</span><br>                <span class="hljs-keyword">if</span> (now &lt; msg.<span class="hljs-keyword">when</span>) &#123;<br>                    <span class="hljs-comment">// 消息的执行时间未到，则计算需要阻塞的时间</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.<span class="hljs-keyword">when</span> - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 找到了消息并且可以执行，标记为非阻塞状态</span><br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// 将消息从消息队列中取出来</span><br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    msg.markInUse();<br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 未找到消息，则将阻塞时间设置为一直阻塞</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 只有Looper.quit时，才会返回null</span><br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                dispose();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            ...<br>        &#125;<br><br>        <span class="hljs-comment">// 执行pendingIntent</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];<br>            mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>        &#125;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的逻辑比较长，详细的注释也在其中了。这里有一段逻辑是当<code>Message</code>的<code>target</code>为空时，后面只会去取<code>isAsynchronous</code>的异步消息，这里这种<code>target</code>为空的消息被称为消息屏障，它的作用就是屏蔽它之后的消息，但是无法屏蔽异步消息。整体逻辑就是：取第一个<code>Message</code>，如果是消息屏障的话，继续找它后面的异步消息，反正就是找到最近的一个消息，然后消息不能执行的话就阻塞，否则就返回。</p><p>最后还有一个<code>IdleHandler</code>，它是空闲消息，当消息队列处于空闲状态时才会执行。空闲状态是指：消息队列中没有消息、消息队列中有消息但是未到执行时间、消息队列中有消息但是被消息屏障给屏蔽了并且没有可执行的异步消息。注意这里的<code>next</code>方法中取消息的逻辑是一个死循环：先取消息，没有可执行的消息时会计算需要阻塞的时长，然后再去执行<code>IdleHandler</code>消息；然后再到循环时，会再次找消息并计算阻塞时长，然后受<code>pendingIdleHandlerCount</code>参数的影响这次不会再执行<code>IdleHandler</code>了；然后再次循环进去阻塞状态。之所以这样循环，是因为<code>IdleHandler</code>也是执行在<code>Looper</code>线程的，考虑到它的执行可能会消耗时间，因此需要在它执行之后重新计算阻塞时长。</p><p>接下来再看看<code>Handler</code>是如何执行消息的，即<code>msg.target,.dispatchMessage</code></p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>    <span class="hljs-comment">// 如果callback不为空，说明消息是个可执行代码块，直接执行即可</span><br>    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) &#123;<br>        handleCallback(msg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 可以给Handler设置一个处理消息的callback，如果执行消息的话，就不会再去分发了</span><br>        <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最后的执行消息的地方，是个空方法</span><br>        handleMessage(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleCallback</span><span class="hljs-params">(Message message)</span> &#123;<br>    message.callback.run();<br>&#125;<br></code></pre></td></tr></table></figure><p>普通消息会被分为数据消息和代码块消息，代码块的消息会被直接执行掉，从而实现了跨线程，因为代码块是在其他线程发送的，但是执行时却是在<code>Looper</code>的线程执行的。而数据消息则是由用户自己去处理，使用示例如下：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// 使用方式一，构造Handler时传入Callback进行处理消息</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>.Callback() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">consumed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                consumed = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;       <br>        <span class="hljs-keyword">return</span> consumed;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 使用方式二，使用匿名内部类，重写handlerMessage方法来处理消息</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper()) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                consumed = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然，如果不发送数据消息的话，直接使用<code>new Handler(Looper)</code>即可。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在Handler消息机制中，绑定了<code>Looper</code>的<code>Handler</code>可以在任意的线程中向<code>MessageQueue</code>中发送消息，<code>Looper</code>负责循环驱动来读取消息，并在自己的线程内处理消息。其中消息分为三类：</p><ul><li>普通消息：普通消息又根据<code>msg.isAsynchronous</code>分为异步消息和同步消息，他们之间的差异就是异步消息不会被消息屏障给屏蔽掉。不管是同步消息还是异步消息，他们又根据<code>msg.callback</code>分为代码块消息和数据消息，如果<code>callback</code>不为空说明是代码块消息，会直接执行。数据消息则是由用户自己进行处理，可根据<code>what</code>来区分消息。</li><li>消息屏障：<code>msg.target</code>为空就代表它是一个消息屏障，它的作用就是屏蔽它后面的消息。一般用来保证重要消息的执行，如<code>View</code>在绘制时就会发送一个消息屏障屏蔽掉其他消息，以保障绘制的顺利完成。</li><li>空闲消息：<code>IdleHandler</code>并不是一个<code>Message</code>，他在<code>MessageQueue</code>中也是单独用一个集合存储的。它只会在消息队列空闲的时候执行，时机无法控制，因此适合处理一些不重要的东西。</li></ul><h2 id="Native层源码"><a href="#Native层源码" class="headerlink" title="Native层源码"></a>Native层源码</h2><p>前面说到的是<code>Java</code>层的整个机制的源码，可以看到在阻塞和唤醒的地方都是调用的<code>native</code>的方法：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="java hljs">MessageQueue(<span class="hljs-type">boolean</span> quitAllowed) &#123;<br>    mQuitAllowed = quitAllowed;<br>    mPtr = nativeInit();<br>&#125;<br><br>Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> <span class="hljs-keyword">when</span>)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeInit</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeDestroy</span><span class="hljs-params">(<span class="hljs-type">long</span> ptr)</span>;<br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativePollOnce</span><span class="hljs-params">(<span class="hljs-type">long</span> ptr, <span class="hljs-type">int</span> timeoutMillis)</span>; <span class="hljs-comment">/*non-static for callbacks*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeWake</span><span class="hljs-params">(<span class="hljs-type">long</span> ptr)</span>;<br></code></pre></td></tr></table></figure><p>可以看到，这一系列的方法都是<code>native</code>方法，源码实现都是在<code>JNI</code>中，并且他们不是通过<code>System.load</code>加载的，而是在<code>native</code>层动态加载的，基本上所有的系统<code>JNI</code>都是在<code>AndroidRuntime</code>（<code>frameworks/base/core/jni/AndroidRuntime.cpp</code>）中动态加载的。我们正常找对应的<code>JNI</code>文件的时候，可以直接全局搜文件名，文件名的规则就是包名+类名，如<code>MessageQueue</code>对应的<code>JNI</code>文件就是<code>android_os_MessageQueue.cpp</code>（<code>frameworks/base/core/jni/android_os_MessageQueue.cpp</code>）。</p><p>找到了对应的文件，那么我们直接看<code>nativeInit</code>方法，它是在构造<code>MessageQueue</code>的时候调用的，返回值是一个<code>long</code>类型的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> jlong <span class="hljs-title">android_os_MessageQueue_nativeInit</span><span class="hljs-params">(JNIEnv* env, jclass clazz)</span> </span>&#123;<br>    NativeMessageQueue* nativeMessageQueue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NativeMessageQueue</span>();<br>      <span class="hljs-keyword">if</span> (!nativeMessageQueue) &#123;<br>         <span class="hljs-built_in">jniThrowRuntimeException</span>(env, <span class="hljs-string">&quot;Unable to allocate native queue&quot;</span>);<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>    <span class="hljs-comment">// 增加强引用，避免被销毁</span><br>    nativeMessageQueue-&gt;<span class="hljs-built_in">incStrong</span>(env);<br>    <span class="hljs-comment">// 返回地址指针</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);<br>&#125;<br></code></pre></td></tr></table></figure><p>即创建了一个<code>NativeMessageQueue</code>，然后增强了它的强引用，避免被销毁，然后返回了地址指针给到<code>Java</code>层。这里的<code>NativeMessageQueue</code>实际并不是个消息队列，它只是名字叫做这个耳机，内部也没什么结构逻辑，只是持有一个<code>sp&lt;Looper&gt;</code>对象。注意这里的<code>Looper</code>并不是<code>Java</code>层的，而是<code>C++</code>的<code>Looper</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">NativeMessageQueue::<span class="hljs-built_in">NativeMessageQueue</span>() :<br>        <span class="hljs-built_in">mPollEnv</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">mPollObj</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">mExceptionObj</span>(<span class="hljs-literal">NULL</span>) &#123;<br>   mLooper = Looper::<span class="hljs-built_in">getForThread</span>();<br>   <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-literal">NULL</span>) &#123;<br>        mLooper = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Looper</span>(<span class="hljs-literal">false</span>);<br>        Looper::<span class="hljs-built_in">setForThread</span>(mLooper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看得出来，<code>Looper</code>和<code>Java</code>层的<code>Looper</code>是一样的，一个线程中只会存在一个。这里的逻辑就是先去根据当前线程获取<code>Looper</code>，获取不到的话就去创建一个<code>Looper</code>，然后保存起来。<code>Looper</code>的位置在<code>system/core/libutils/Looper.cpp</code>、<code>system/core/include/utils/Looper.h</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++">Looper::<span class="hljs-built_in">Looper</span>(<span class="hljs-type">bool</span> allowNonCallbacks)<br>   : <span class="hljs-built_in">mAllowNonCallbacks</span>(allowNonCallbacks),<br>      <span class="hljs-built_in">mSendingMessage</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">mPolling</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">mEpollRebuildRequired</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">mNextRequestSeq</span>(WAKE_EVENT_FD_SEQ + <span class="hljs-number">1</span>),<br>      <span class="hljs-built_in">mResponseIndex</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">mNextMessageUptime</span>(LLONG_MAX) &#123;<br>    <span class="hljs-comment">// 创建eventfd，用于监听该eventfd来实现阻塞和唤醒</span><br>    mWakeEventFd.<span class="hljs-built_in">reset</span>(<span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));<br>    <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(mWakeEventFd.<span class="hljs-built_in">get</span>() &lt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Could not make wake event fd: %s&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));<br>    AutoMutex _l(mLock);<br>    <span class="hljs-comment">// 创建epoll，通过epoll来监听eventfd</span><br>    <span class="hljs-built_in">rebuildEpollLocked</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Looper::rebuildEpollLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 重置旧的epoll</span><br>    <span class="hljs-keyword">if</span> (mEpollFd &gt;= <span class="hljs-number">0</span>) &#123;<br>        mEpollFd.<span class="hljs-built_in">reset</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 创建一个新的epoll</span><br>    mEpollFd.<span class="hljs-built_in">reset</span>(<span class="hljs-built_in">epoll_create1</span>(EPOLL_CLOEXEC));<br>    epoll_event wakeEvent = <span class="hljs-built_in">createEpollEvent</span>(EPOLLIN, WAKE_EVENT_FD_SEQ);<br>    <span class="hljs-comment">// 添加一个eventfd，并设置唤醒状态为eventfd中被写入数据时，即eventfd可读时唤醒</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">epoll_ctl</span>(mEpollFd.<span class="hljs-built_in">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class="hljs-built_in">get</span>(), &amp;wakeEvent);<br>    <br>    <span class="hljs-comment">// 监听其他的eventfd，这里与是其他流程，可以暂时不去关注 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [seq, request] : mRequests) &#123;<br>        epoll_event eventItem = <span class="hljs-built_in">createEpollEvent</span>(request.<span class="hljs-built_in">getEpollEvents</span>(), seq);<br>        <span class="hljs-type">int</span> epollResult = <span class="hljs-built_in">epoll_ctl</span>(mEpollFd.<span class="hljs-built_in">get</span>(), EPOLL_CTL_ADD, request.fd, &amp;eventItem);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里应该就很熟悉了，前面在<a href="%22https://pgaofeng.github.io/2022/02/23/eventfd-epoll%22">Handler唤起的基础</a>中详细介绍过<code>eventfd</code>和<code>epoll</code>机制，其中<code>epoll</code>是可以监控多个<code>eventfd</code>的，每个<code>fd</code>都能唤醒<code>epoll</code>，这里默认的唤醒的fd是<code>mWakeEventfd</code>。所以初始化的方法也就简洁明了了，创建了一个<code>Looper</code>，然后在<code>Looper</code>中整了<code>eventfd</code>和<code>epoll</code>。<br>然后看阻塞的方法，应该会和我们想的一样，通过<code>epoll_wait</code>等待<code>eventfd</code>的状态变化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">android_os_MessageQueue_nativePollOnce</span><span class="hljs-params">(JNIEnv* env, jobject obj,</span></span><br><span class="hljs-params"><span class="hljs-function">        jlong ptr, jint timeoutMillis)</span> </span>&#123;<br>    <span class="hljs-comment">// 根据java传进来的指针获取到MQ</span><br>    NativeMessageQueue* nativeMessageQueue = <span class="hljs-built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);<br>    nativeMessageQueue-&gt;<span class="hljs-built_in">pollOnce</span>(env, obj, timeoutMillis);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NativeMessageQueue::pollOnce</span><span class="hljs-params">(JNIEnv* env, jobject pollObj, <span class="hljs-type">int</span> timeoutMillis)</span> </span>&#123;<br>    mPollEnv = env;<br>    mPollObj = pollObj;<br>    mLooper-&gt;<span class="hljs-built_in">pollOnce</span>(timeoutMillis);<br>    mPollObj = <span class="hljs-literal">NULL</span>;<br>    mPollEnv = <span class="hljs-literal">NULL</span>;<br> <br>    <span class="hljs-keyword">if</span> (mExceptionObj) &#123;<br>        env-&gt;<span class="hljs-built_in">Throw</span>(mExceptionObj);<br>        env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(mExceptionObj);<br>        mExceptionObj = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先就是在<code>nativeInit</code>的时候构建了<code>NativeMessageQueue</code>，然后将指针传入到了<code>Java</code>层保存在<code>Java</code>层的<code>MessageQueue.mPtr</code>中。后续所有的操作都是与<code>mPtr</code>相关的，从<code>Java</code>再到<code>native</code>，将<code>mPtr</code>指针地址再转换成<code>NativeMessageQueue</code>进行操作。如<code>nativePollOnce</code>就是最终走到<code>Looper.pollOnce</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Looper.h</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">pollOnce</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pollOnce</span>(timeoutMillis, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-comment">// Looper.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Looper::pollOnce</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis, <span class="hljs-type">int</span>* outFd, <span class="hljs-type">int</span>* outEvents, <span class="hljs-type">void</span>** outData)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        ...<br>        <span class="hljs-comment">// 这段逻辑是处理消息的，但是我们传入的后面三个参数都是nullptr，</span><br>        <span class="hljs-comment">// 因此不会走到处理消息的逻辑。</span><br>        ...<br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>            ...<br>            <span class="hljs-comment">// 退出循环，即此时已经唤醒了</span><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-comment">// 进入阻塞，阻塞结束后会再次循环，然后在上面退出循环</span><br>        result = <span class="hljs-built_in">pollInner</span>(timeoutMillis);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Looper::pollInner</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis)</span> </span>&#123;  <br>    <span class="hljs-comment">// Poll.</span><br>    <span class="hljs-type">int</span> result = POLL_WAKE;<br>    mResponses.<span class="hljs-built_in">clear</span>();<br>    mResponseIndex = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-comment">// 进入阻塞，阻塞结束后返回值就是触发唤醒的个数，唤醒事件会存在eventItems中</span><br>    mPolling = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];<br>    <span class="hljs-type">int</span> eventCount = <span class="hljs-built_in">epoll_wait</span>(mEpollFd.<span class="hljs-built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);<br>    mPolling = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 发生错误，直接走到Done逻辑块</span><br>    <span class="hljs-keyword">if</span> (eventCount &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (errno == EINTR) &#123;<br>            <span class="hljs-keyword">goto</span> Done;<br>        &#125;<br>        result = POLL_ERROR;<br>        <span class="hljs-keyword">goto</span> Done;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 唤醒的消息数为0，表示是超时引起的唤醒</span><br>    <span class="hljs-keyword">if</span> (eventCount == <span class="hljs-number">0</span>) &#123;<br>        result = POLL_TIMEOUT;<br>        <span class="hljs-keyword">goto</span> Done;<br>    &#125;<br><br>    <span class="hljs-comment">// 唤醒的消息数不为0，开始处理消息。因为我们是从Java层的MessageQueue中使用的，</span><br>    <span class="hljs-comment">// 并没有额外传入eventfd，因此这里即使被唤醒eventCount也只会是1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; eventCount; i++) &#123;<br>        <span class="hljs-type">const</span> SequenceNumber seq = eventItems[i].data.u64;<br>        <span class="hljs-type">uint32_t</span> epollEvents = eventItems[i].events;<br>        <span class="hljs-comment">// 添加到epoll时，mWakeEventFd的类型就是WAKE_EVENT_FD_SEQ，因此这里说明epoll被唤醒了</span><br>        <span class="hljs-comment">// 并且唤醒的是mWakeEventFd</span><br>        <span class="hljs-keyword">if</span> (seq == WAKE_EVENT_FD_SEQ) &#123;<br>            <span class="hljs-keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;<br>                <span class="hljs-built_in">awoken</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;</span>, epollEvents);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 其他fd唤醒的会构建response，然后存入到mResponse中被looperOnce中的逻辑处理</span><br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; request_it = mRequests.<span class="hljs-built_in">find</span>(seq);<br>            <span class="hljs-keyword">if</span> (request_it != mRequests.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; request = request_it-&gt;second;<br>                <span class="hljs-type">int</span> events = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;<br>                <span class="hljs-keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;<br>                <span class="hljs-keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;<br>                <span class="hljs-keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;<br>                mResponses.<span class="hljs-built_in">push</span>(&#123;.seq = seq, .events = events, .request = request&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ...<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>Done: ;<br><br>    <span class="hljs-comment">// Invoke pending message callbacks.</span><br>    mNextMessageUptime = LLONG_MAX;<br>    ...<br><br>    <span class="hljs-comment">// 处理其他事件的response</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mResponses.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        Response&amp; response = mResponses.<span class="hljs-built_in">editItemAt</span>(i);<br>        <span class="hljs-keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;<br>            ...<br>            <span class="hljs-type">int</span> callbackResult = response.request.callback-&gt;<span class="hljs-built_in">handleEvent</span>(fd, events, data);<br>            ...<br>            response.request.callback.<span class="hljs-built_in">clear</span>();<br>            result = POLL_CALLBACK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以确实是<code>epoll</code>机制，最终走到的就是<code>epoll_wait</code>进入阻塞，等待被唤醒或者超时被唤醒。并且在这里我们看到了别的逻辑，就是<code>Looper</code>不仅仅是给<code>Java</code>层使用的，它除了默认用于唤醒的<code>mWakeEventfd</code>外，还支持添加别的<code>eventfd</code>，并且别的<code>eventfd</code>唤醒<code>epoll</code>后会构建<code>Response</code>来处理这些消息。事实上就是如此，著名的<code>ServiceManager</code>就使用了<code>Looper</code>，然后将<code>Binder</code>的<code>fd</code>添加到<code>Looper</code>中来监听<code>Binder</code>的消息，这是额外的话题，以后再说。<br>阻塞的流程我们看完了，接下来看唤醒的流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// android_os_MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">android_os_MessageQueue_nativeWake</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;<br>    NativeMessageQueue* nativeMessageQueue = <span class="hljs-built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);<br>    nativeMessageQueue-&gt;<span class="hljs-built_in">wake</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NativeMessageQueue::wake</span><span class="hljs-params">()</span> </span>&#123;<br>    mLooper-&gt;<span class="hljs-built_in">wake</span>();<br>&#125;<br><br><span class="hljs-comment">//Looper.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Looper::wake</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint64_t</span> inc = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 向mWakeEventfd中写入一个1，然后epoll_wait就会被唤醒了</span><br>    <span class="hljs-type">ssize_t</span> nWrite = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">write</span>(mWakeEventFd.<span class="hljs-built_in">get</span>(), &amp;inc, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint64_t</span>)));<br>    <span class="hljs-keyword">if</span> (nWrite != <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint64_t</span>)) &#123;<br>        <span class="hljs-keyword">if</span> (errno != EAGAIN) &#123;<br>            <span class="hljs-built_in">LOG_ALWAYS_FATAL</span>(<span class="hljs-string">&quot;Could not write wake signal to fd %d (returned %zd): %s&quot;</span>,<br>                           mWakeEventFd.<span class="hljs-built_in">get</span>(), nWrite, <span class="hljs-built_in">strerror</span>(errno));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>唤醒流程非常清晰，根据<code>Java</code>层传来的地址找到<code>NativeMessageQueue</code>，最终走到<code>Looper.wake</code>方法来进行唤醒，唤醒的方式也是最简单的向<code>eventfd</code>中写入一个1。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><code>Native</code>层也有一个<code>Looper</code>，他与<code>Java</code>层差不多，也是线程唯一的。当在<code>Java</code>层创建<code>MessageQueue</code>时，也会同时在<code>Native</code>层创建一个<code>NativeMessageQueue</code>并赋值给<code>Java</code>层的<code>mPtr</code>属性，由此将二者进行绑定。然后在<code>NativeMessageQueue</code>创建时，还会创建<code>native</code>层的<code>Looper</code>，后续的阻塞和唤醒都是在<code>native</code>层的<code>Looper</code>中通过<code>eventfd</code>和<code>epoll</code>机制进行的。</p><p><img alt="img&#x2F;handler.webp" class="lozad post-image" src="/img/handler.webp" data-src="/img/handler.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><p>通过前面对<code>Java</code>层的<code>Handler</code>消息机制的分析，我们知道了整体的逻辑：</p><ol><li>初始化：首先在线程中启用<code>Java</code>的<code>Looper</code>，此时会创建<code>Java</code>的<code>MessageQueue</code>用于存储消息，同时会通过<code>nativeInit</code>进入到<code>Native</code>层创建了<code>NativeMessageQueue</code>和<code>Native</code>的<code>Looper</code>。</li><li>读取：<code>Java</code>层的<code>Looper</code>会进入循环，一直读取<code>MessageQueue</code>中的消息。读不到的时候会通过<code>nativePollOnce</code>进入到<code>native</code>层，然后在<code>Native</code>层的<code>Looper</code>中通过<code>epoll</code>机制进入阻塞状态。</li><li>写入：<code>Java</code>层的<code>Handler</code>发送消息到<code>MessageQueue</code>中，通过<code>nativeWake</code>进入到<code>native</code>层，然后在<code>Native</code>的<code>Looper</code>中向<code>mWakeEventfd</code>写入一个值，用于唤醒<code>epoll</code>的阻塞。唤醒后回到<code>Java</code>层的<code>Looper</code>开始处理消息，然后继续阻塞。</li></ol><p>这里我们看到实际的阻塞和唤醒都是在<code>native</code>层实现的，并且<code>Native</code>层还有一个<code>Looper</code>。注意这里的<code>NativeMessageQueue</code>实际是没啥用的，它存在的作用就是连接<code>Java</code>层和<code>Native</code>层，它将<code>native Looper</code>等信息存储在自己的对象中，然后将对象的地址保存在<code>Java</code>中。后续的交互就是<code>Java</code>层根据地址找到<code>NativeMessageQueue</code>进而找到<code>native Looper</code>。</p><p>从前面的分析我们知道了<code>Looper</code>进入阻塞的时候，是通过<code>epoll</code>机制阻塞的，而熟悉<code>epoll</code>机制（<a href="https://pgaofeng.github.io/2022/02/23/eventfd-epoll/" rel="noopener" target="_blank">点击查看epoll和eventfd</a>）的我们知道，<code>epoll</code>可以监听多个<code>eventfd</code>，也就是说我们可以向<code>Looper</code>中注册自己的<code>eventfd</code>实现阻塞和唤醒。</p><p>前面我们看到在<code>Looper</code>中，会给我们提供一个默认的<code>mWakeEventfd</code>用来唤醒和阻塞，并且这个<code>fd</code>仅仅是用来唤醒和阻塞的。但是我们看到<code>Looper</code>的逻辑中是可以添加自己的<code>eventfd</code>的，然后在被自己的eventfd唤醒的时候还会自动执行操作，类似于一个消息机制了，接下来看看这个是怎么完成的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++">Looper::<span class="hljs-built_in">addFd</span>(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ident, <span class="hljs-type">int</span> events, Looper_callbackFunc callback, <span class="hljs-type">void</span>* data) &#123;<br>    sp&lt;SimpleLooperCallback&gt; looperCallback;<br>    <span class="hljs-keyword">if</span> (callback) &#123;<br>        looperCallback = sp&lt;SimpleLooperCallback&gt;::<span class="hljs-built_in">make</span>(callback);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">addFd</span>(fd, ident, events, looperCallback, data);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Looper::addFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ident, <span class="hljs-type">int</span> events, <span class="hljs-type">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="hljs-type">void</span>* data)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!callback.<span class="hljs-built_in">get</span>()) &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ident = POLL_CALLBACK;<br>    &#125;<br> <br>    &#123; <span class="hljs-comment">// acquire lock</span><br>        AutoMutex _l(mLock);<br>        <span class="hljs-comment">// mWakeEventfd的seq是WAKE_EVENT_FD_SEQ，后续添加的fd都往后排</span><br>        <span class="hljs-keyword">if</span> (mNextRequestSeq == WAKE_EVENT_FD_SEQ) mNextRequestSeq++;<br>        <span class="hljs-type">const</span> SequenceNumber seq = mNextRequestSeq++;<br><br>        Request request;<br>        <span class="hljs-comment">// 唤醒后，根据fd来寻找对应的request处理事件</span><br>        request.fd = fd;<br>        request.ident = ident;<br>        request.events = events;<br>        <span class="hljs-comment">// 唤醒后由callback处理事件</span><br>        request.callback = callback;<br>        request.data = data;<br><br>        epoll_event eventItem = <span class="hljs-built_in">createEpollEvent</span>(request.<span class="hljs-built_in">getEpollEvents</span>(), seq);<br>        <span class="hljs-keyword">auto</span> seq_it = mSequenceNumberByFd.<span class="hljs-built_in">find</span>(fd);<br>        <span class="hljs-keyword">if</span> (seq_it == mSequenceNumberByFd.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// 添加新的eventfd</span><br>            <span class="hljs-type">int</span> epollResult = <span class="hljs-built_in">epoll_ctl</span>(mEpollFd.<span class="hljs-built_in">get</span>(), EPOLL_CTL_ADD, fd, &amp;eventItem);<br>            mRequests.<span class="hljs-built_in">emplace</span>(seq, request);<br>            mSequenceNumberByFd.<span class="hljs-built_in">emplace</span>(fd, seq);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// eventfd已经添加过了，则修改fd</span><br>            <span class="hljs-type">int</span> epollResult = <span class="hljs-built_in">epoll_ctl</span>(mEpollFd.<span class="hljs-built_in">get</span>(), EPOLL_CTL_MOD, fd, &amp;eventItem);<br>            ...<br>            <span class="hljs-type">const</span> SequenceNumber oldSeq = seq_it-&gt;second;<br>            mRequests.<span class="hljs-built_in">erase</span>(oldSeq);<br>            mRequests.<span class="hljs-built_in">emplace</span>(seq, request);<br>            seq_it-&gt;second = seq;<br>        &#125;<br>    &#125; <span class="hljs-comment">// release lock</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在添加<code>fd</code>的时候，要求传入一个<code>LooperCallback</code>，它是用来处理消息的，然后将这些参数封装成<code>Request</code>对象，然后存入到<code>mRequest</code>集合中，并且向<code>epoll</code>中添加对应的<code>eventfd</code>。正常来说，添加完之后就可以开始监听了，有两个监听的方法：<code>ponnOnce</code>和<code>pollAll</code>，其中<code>pollOnce</code>就是阻塞一次，唤醒后会处理消息，然后就返回了。而<code>pollAll</code>则是循环调用<code>pollOnce</code>，只要<code>pollOnce</code>的返回值是<code>CALLBACK</code>，就继续进入阻塞等待事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Looper::pollAll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis, <span class="hljs-type">int</span>* outFd, <span class="hljs-type">int</span>* outEvents, <span class="hljs-type">void</span>** outData)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> result;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 只要返回值是POLL_CALLBACK，就一直循环</span><br>            result = <span class="hljs-built_in">pollOnce</span>(timeoutMillis, outFd, outEvents, outData);<br>        &#125; <span class="hljs-keyword">while</span> (result == POLL_CALLBACK);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">nsecs_t</span> endTime = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC)<br>                + <span class="hljs-built_in">milliseconds_to_nanoseconds</span>(timeoutMillis);<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 同样的逻辑，区别就是设置了超时时间后，会在超时时间到达时返回</span><br>            <span class="hljs-type">int</span> result = <span class="hljs-built_in">pollOnce</span>(timeoutMillis, outFd, outEvents, outData);<br>            <span class="hljs-keyword">if</span> (result != POLL_CALLBACK) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            <span class="hljs-comment">// 此次唤醒不是超时唤醒，但是在处理完时间后时间到了，也不再阻塞，而是直接返回</span><br>            <span class="hljs-type">nsecs_t</span> now = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);<br>            timeoutMillis = <span class="hljs-built_in">toMillisecondTimeoutDelay</span>(now, endTime);<br>            <span class="hljs-keyword">if</span> (timeoutMillis == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> POLL_TIMEOUT;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>pollOnce</code>我们前面已经看过了，就是进入阻塞，然后唤醒后构建<code>Response</code>，然后进行处理事件。下面再看一次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Looper::pollOnce</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis, <span class="hljs-type">int</span>* outFd, <span class="hljs-type">int</span>* outEvents, <span class="hljs-type">void</span>** outData)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        ...<br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>            ...<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        result = <span class="hljs-built_in">pollInner</span>(timeoutMillis);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Looper::pollInner</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis)</span> </span>&#123;<br>    <span class="hljs-comment">// 准备进入阻塞，先把response清空，后续用于存储唤醒的事件</span><br>    <span class="hljs-type">int</span> result = POLL_WAKE;<br>    mResponses.<span class="hljs-built_in">clear</span>();<br>    mResponseIndex = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 开始阻塞，当被唤醒后，唤醒的事件会存在epoll_event数组中</span><br>    mPolling = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];<br>    <span class="hljs-type">int</span> eventCount = <span class="hljs-built_in">epoll_wait</span>(mEpollFd.<span class="hljs-built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);<br>    mPolling = <span class="hljs-literal">false</span>;<br><br>    ...<br>    <span class="hljs-comment">// 遍历唤醒的事件，然后将其封装成Response</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; eventCount; i++) &#123;<br>        <span class="hljs-type">const</span> SequenceNumber seq = eventItems[i].data.u64;<br>        <span class="hljs-type">uint32_t</span> epollEvents = eventItems[i].events;<br>        <span class="hljs-comment">// 默认的mWakeEventfd的seq是这个，不会封装Response，也不会处理任何事件</span><br>        <span class="hljs-keyword">if</span> (seq == WAKE_EVENT_FD_SEQ) &#123;<br>            <span class="hljs-keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;<br>                <span class="hljs-built_in">awoken</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 根据seq找到request，然后构建Response的时候会将二者进行关联</span><br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; request_it = mRequests.<span class="hljs-built_in">find</span>(seq);<br>            <span class="hljs-keyword">if</span> (request_it != mRequests.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; request = request_it-&gt;second;<br>                <span class="hljs-type">int</span> events = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;<br>                <span class="hljs-keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;<br>                <span class="hljs-keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;<br>                <span class="hljs-keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;<br>                <span class="hljs-comment">// 封装成Response并添加到mResponse集合中</span><br>                mResponses.<span class="hljs-built_in">push</span>(&#123;.seq = seq, .events = events, .request = request&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>Done: ;<br>    ...<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mResponses.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        Response&amp; response = mResponses.<span class="hljs-built_in">editItemAt</span>(i);<br>        <span class="hljs-keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;<br>            <span class="hljs-type">int</span> fd = response.request.fd;<br>            <span class="hljs-type">int</span> events = response.events;<br>            <span class="hljs-type">void</span>* data = response.request.data;<br>            <span class="hljs-comment">// 直接执行callback，其中fd和data都是添加fd时的参数没有修改，而events表示的是唤醒的事件</span><br>            <span class="hljs-type">int</span> callbackResult = response.request.callback-&gt;<span class="hljs-built_in">handleEvent</span>(fd, events, data);<br>            ..<br>            result = POLL_CALLBACK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们在<code>c++</code>层中，就可以通过添加fd以及对应的<code>callback</code>，当fd发生变化的时候就会唤醒<code>epoll</code>，然后执行<code>callback</code>了。实际上<code>Looper</code>在<code>Native</code>层用的更多，像我们熟悉的<code>ServiceManager</code>也使用了<code>Looper</code>机制。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Mon Mar 07 2022 12:33:47 GMT+0800");let n="Mon Mar 07 2022 12:33:47 GMT+0800";n="2024-10-26 11:16:24 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Android-Framework/" class="post-footer-category">#&nbsp;Android Framework</a> <a href="/tags/Handler/" class="post-footer-tag">#&nbsp;Handler</a></div><div class="nav"><div class="nav-item-prev"><a href="/2022/04/20/binder-1/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">Binder和服务</div></div></a></div><div class="nav-item-next"><a href="/2022/02/23/eventfd-epoll/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Handler唤起的基础--eventfd和epoll</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" class="toc-link"><span class="toc-text">简单介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#Handler" class="toc-link"><span class="toc-text">Handler</span></a></li><li class="toc-item toc-level-3"><a href="#Message" class="toc-link"><span class="toc-text">Message</span></a></li><li class="toc-item toc-level-3"><a href="#Looper" class="toc-link"><span class="toc-text">Looper</span></a></li><li class="toc-item toc-level-3"><a href="#MessageQueue" class="toc-link"><span class="toc-text">MessageQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#Java%E5%B1%82%E6%BA%90%E7%A0%81" class="toc-link"><span class="toc-text">Java层源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%B0%8F%E7%BB%93" class="toc-link"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#Native%E5%B1%82%E6%BA%90%E7%A0%81" class="toc-link"><span class="toc-text">Native层源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%B0%8F%E7%BB%93-1" class="toc-link"><span class="toc-text">小结</span></a></li></ol></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2022-02-23</div><a href="/2022/02/23/eventfd-epoll/"><div class="recent-posts-item-content">Handler唤起的基础--eventfd和epoll</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-01-14</div><a href="/2023/01/14/sp-wp-refbase/"><div class="recent-posts-item-content">Android智能指针</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-10-02</div><a href="/2022/10/02/ams/"><div class="recent-posts-item-content">App管理服务-ActivityManagerService</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-09-21</div><a href="/2022/09/21/system_server/"><div class="recent-posts-item-content">Java服务总管-system_server进程</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-08-12</div><a href="/2022/08/12/zygote/"><div class="recent-posts-item-content">Java进程祖先-zygote服务</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-01-02</div><a href="/2024/01/02/navigation/"><div class="recent-posts-item-content">在Compose中使用Navigation</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-12-20</div><a href="/2023/12/20/ffmpeg4/"><div class="recent-posts-item-content">FFmpeg解码视频YUV</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-11-13</div><a href="/2023/11/13/ffmpeg3/"><div class="recent-posts-item-content">FFmpeg解码音频PCM</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-10-05</div><a href="/2023/10/05/ffmpeg2/"><div class="recent-posts-item-content">FFmpeg解封装与重封装</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>