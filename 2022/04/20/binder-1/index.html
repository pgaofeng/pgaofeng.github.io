<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Binder和服务</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img class="author-img" src="/img/website.svg" alt="author avatar" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>26</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>15</span> <span>标签</span> </a><a class="author-word-count"><span>11.02</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Binder%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84" class="toc-link"><span class="toc-text">Binder的继承结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#IBinder" class="toc-link"><span class="toc-text">IBinder</span></a></li><li class="toc-item toc-level-3"><a href="#BBinder" class="toc-link"><span class="toc-text">BBinder</span></a></li><li class="toc-item toc-level-3"><a href="#BpBinder" class="toc-link"><span class="toc-text">BpBinder</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#ServiceManager" class="toc-link"><span class="toc-text">ServiceManager</span></a></li><li class="toc-item toc-level-2"><a href="#IServiceManager" class="toc-link"><span class="toc-text">IServiceManager</span></a></li><li class="toc-item toc-level-2"><a href="#IServiceManager-aidl" class="toc-link"><span class="toc-text">IServiceManager.aidl</span></a></li><li class="toc-item toc-level-2"><a href="#IInterface" class="toc-link"><span class="toc-text">IInterface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1" class="toc-link"><span class="toc-text">定义一个服务</span></a></li></ol></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">3</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">5</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img class="lozad image" src="/img/cover/cover-binder-1.webp" alt="Binder和服务 thumbnail" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Binder和服务</h1></header><div class="post-meta post-show-meta"><time datetime="2022-04-20T06:03:09.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2022-04-20</span> </time><span class="dot"></span> <a href="/categories/Android-Framework/" class="post-meta-link">Android Framework </a><span class="dot"></span> <span>约9k 字</span></div><div class="post-content" id="section"><p><code>Binder</code>是<code>Android</code>中非常非常重要的一个部分，它实现了进程间高效安全的通信。整个<code>Binder</code>系统整体上分为两个部分，一部分是<code>Binder</code>驱动，运行在内核中，也是跨进程的基石；一部分是<code>Binder</code>实体，封装了通信的逻辑，主要用来进行通信的，运行在用户空间中，提供各种服务。实体<code>Binder</code>中有一个特殊的存在<code>ServiceManager</code>，它只给服务来提供服务，用于管理服务的注册和查询。</p><p>学习<code>Binder</code>能够让我们对<code>Android</code>系统的理解更加深刻，更加清晰各个层级之间的关联。虽然在实际应用中我们几乎很难遇到裸用<code>Binder</code>的，但是想要在<code>Framework</code>上走的更深，<code>Binder</code>是必不可少的一环。并且实际面试中更是经常被问到，因此就算是为了应付面试，我们也应该仔细阅读<code>Binder</code>的实现。</p><blockquote><p>本文基于Android 13源码</p></blockquote><h2 id="Binder的继承结构"><a href="#Binder的继承结构" class="headerlink" title="Binder的继承结构"></a>Binder的继承结构</h2><p><code>Binder</code>的设计独特的，它分出了两种<code>Binder</code>，一种是<code>BBinder</code>代表着服务实体，一种是<code>BpBinder</code>代表着服务的代理。在服务的实现中，它们继承自相同的接口并且分别实现了对应的方法。其中<code>BBinder</code>实现了具体的业务，而<code>BpBinder</code>封装了具体的跨进程调用，于是当一个进程拿到另一个进程对应的<code>BpBinder</code>后，就可以直接调用对应的方法，也就是通过同步调用的方式来实现跨进程的异步过程。</p><p>接下来先看下它们的继承结构：</p><h3 id="IBinder"><a href="#IBinder" class="headerlink" title="IBinder"></a>IBinder</h3><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">//frameworks/native/include/binder/IBinder.h</span><br><br><span class="hljs-keyword">class</span> [[clang::lto_visibility_public]] IBinder : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> RefBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">IBinder</span>();<br>    <span class="hljs-comment">// 实际的交互方法</span><br>     <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">status_t</span>  <span class="hljs-title">transact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> code,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">const</span> Parcel&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                Parcel* reply,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">uint32_t</span> flags = <span class="hljs-number">0</span>)</span> </span>= <span class="hljs-number">0</span>;<br><br>     <span class="hljs-comment">// 返回本地binder和远程binder</span><br>     <span class="hljs-function"><span class="hljs-keyword">virtual</span> BBinder*        <span class="hljs-title">localBinder</span><span class="hljs-params">()</span></span>;<br>     <span class="hljs-function"><span class="hljs-keyword">virtual</span> BpBinder*       <span class="hljs-title">remoteBinder</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>     <span class="hljs-keyword">virtual</span>          ~<span class="hljs-built_in">IBinder</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>IBinder</code>中定义了一些<code>Binder</code>的基础能力，所有的<code>Binder</code>都必须实现<code>IBinder</code>的接口，而<code>IBinder</code>又是继承自<code>RefBase</code>，因此可以使用智能指针去引用<code>Binder</code>。<code>BBinder</code>和<code>BpBinder</code>都是<code>IBinder</code>的实现类，从方法名字也能看到，他们分别代表本地<code>Binder</code>和远程<code>Binder</code>。注意这几个方法都是有着默认的空实现的。</p><h3 id="BBinder"><a href="#BBinder" class="headerlink" title="BBinder"></a>BBinder</h3><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/Binder.cpp</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BBinder</span> : <span class="hljs-keyword">public</span> IBinder<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BBinder</span>();<br>    <span class="hljs-comment">// 实际的交互方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">status_t</span> <span class="hljs-title">transact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> code,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> Parcel&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                              Parcel* reply,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">uint32_t</span> flags = <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">final</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> BBinder*  <span class="hljs-title">localBinder</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">protected</span>:<br>     <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">BBinder</span>();<br>     <span class="hljs-comment">// 收到的交互信息</span><br>     <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">status_t</span> <span class="hljs-title">onTransact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> code,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> Parcel&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 Parcel* reply,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">uint32_t</span> flags = <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>      <span class="hljs-built_in">BBinder</span>(<span class="hljs-type">const</span> BBinder&amp; o);<br>      BBinder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> BBinder&amp; o);<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>BBinder</code>是本地实体<code>Binder</code>，它继承自<code>IBinder</code>，本身又定义了一个<code>onTranscat</code>方法。<code>transact</code>方法是跨进程发送的方法，因此它是在<code>IBinder</code>中定义的，但是<code>onTransact</code>表示的是接受跨进程调用，因此它只在<code>BBinder</code>中有，因为它才是服务的本体，才需要处理消息事件。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/Binder.cpp</span><br><br><span class="hljs-comment">// 本地binder重写方法，返回this本身</span><br><span class="hljs-function">BBinder* <span class="hljs-title">BBinder::localBinder</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 跨进程发送的方法，因为本身就是本地Binder了，所以不需要跨进程调用，直接到onTransact中</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BBinder::transact</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-type">status_t</span> err = NO_ERROR;<br>    <span class="hljs-keyword">switch</span> (code) &#123;<br>        ...<br>        <span class="hljs-keyword">default</span>:<br>            err = <span class="hljs-built_in">onTransact</span>(code, data, reply, flags);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-comment">// 跨进程调用的接收方法，这里给了一些基础的实现，正常情况下在具体的服</span><br><span class="hljs-comment">// 务中需要再次重写这个方法，然后根据code和data调用本地的对应的方法，</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BBinder::onTransact</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> <span class="hljs-comment">/*flags*/</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (code) &#123;<br>        <span class="hljs-keyword">case</span> INTERFACE_TRANSACTION:<br>            reply-&gt;<span class="hljs-built_in">writeString16</span>(<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>            <span class="hljs-keyword">return</span> NO_ERROR;<br>        <span class="hljs-keyword">case</span> DUMP_TRANSACTION: &#123;<br>            ...<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dump</span>(fd, args);<br>        &#125;<br>        <span class="hljs-keyword">case</span> SHELL_COMMAND_TRANSACTION: &#123;<br>            ...<br>            <span class="hljs-keyword">return</span> NO_ERROR;<br>        &#125;<br>        <span class="hljs-keyword">case</span> SYSPROPS_TRANSACTION: &#123;<br>            <span class="hljs-built_in">report_sysprop_change</span>();<br>            <span class="hljs-keyword">return</span> NO_ERROR;<br>        &#125;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> UNKNOWN_TRANSACTION;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于本地<code>Binder</code>，<code>localBinder</code>返回的就是它本身，而<code>remoteBinder</code>则是默认的返回<code>nullptr</code>。同样的，在<code>transact</code>方法中，会直接走到<code>onTransact</code>中。这是因为它是本地实体，当通过实体<code>Binder</code>的<code>transact</code>方法发送消息的时候，实际是不需要经过跨进程的而是直接就能获取到消息，因此不需要处理发送的细节，而是直接将请求发回给<code>onTransact</code>中进行处理即可。</p><h3 id="BpBinder"><a href="#BpBinder" class="headerlink" title="BpBinder"></a>BpBinder</h3><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/include/binder/BpBinder.h</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BpBinder</span> : <span class="hljs-keyword">public</span> IBinder<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 实际的交互方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">status_t</span> <span class="hljs-title">transact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> code,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> Parcel&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                              Parcel* reply,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">uint32_t</span> flags = <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">final</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> BpBinder*   <span class="hljs-title">remoteBinder</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-function"><span class="hljs-type">static</span> sp&lt;BpBinder&gt; <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> handle)</span></span>;<br>     <span class="hljs-keyword">virtual</span>             ~<span class="hljs-built_in">BpBinder</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>BpBinder</code>是远程<code>Binder</code>的代理类，当客户端和服务端处于不同的进程时，客户端会获取到服务端<code>BBinder</code>实体的引用，然后将其包装成<code>BpBinder</code>，通过对<code>BpBinder</code>方法的调用来访问具体的业务，而这些方法最终会走到<code>transact</code>方法中去进行具体的跨进程逻辑。这里提供了一个<code>create</code>的方法来构建<code>BpBinder</code>，参数是<code>handle</code>。这个<code>handle</code>就是远程的服务本体<code>BBinder</code>在当前进程中的唯一索引，是通过<code>SerciceManager</code>查询到的。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/BpBinder.cpp</span><br><br><span class="hljs-function">BpBinder* <span class="hljs-title">BpBinder::remoteBinder</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 跨进程调用的发送方法</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BpBinder::transact</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (mAlive) &#123;<br>        ...<br>        <span class="hljs-type">status_t</span> status;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(<span class="hljs-built_in">isRpcBinder</span>())) &#123;<br>            <span class="hljs-comment">// 远程调用，可以是别的虚拟机</span><br>            status = <span class="hljs-built_in">rpcSession</span>()-&gt;<span class="hljs-built_in">transact</span>(sp&lt;IBinder&gt;::<span class="hljs-built_in">fromExisting</span>(<span class="hljs-keyword">this</span>), code, data, reply,flags);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 交给IPCThreadState处理</span><br>            status = IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">transact</span>(<span class="hljs-built_in">binderHandle</span>(), code, data, reply, flags);<br>        &#125;<br>        ...<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>    <span class="hljs-keyword">return</span> DEAD_OBJECT;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BpBinder</code>在跨进程调用的时候，将参数和命令统一转发给了<code>IPCThreadState</code>去处理的，因此，我们在具体的服务代理实现中，只需要在对应的方法中封装code和data即可，最后通过<code>transact</code>发送消息即可。</p><p><img class="lozad post-image" src="/img/binder-1.webp" data-src="/img/binder-1.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><h2 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h2><p>上面看了<code>Binder</code>的相关定义，大体上能看出它的设计理念：调用方拿到实体服务的<code>handle</code>去创建服务代理<code>BpBinder</code>，然后实现服务的方法，逻辑是封装code命令和data参数，最终通过<code>transact</code>发送。实体服务继承自<code>BBinder</code>，实现服务的方法并且在<code>onTransact</code>中解析code和data参数，然后调用自己对应的方法。</p><p>有了前面的基础我们再去看<code>ServiceManager</code>，前面看到调用方需要拿到实体服务的<code>handle</code>才能创建对应的代理服务<code>BpBinder</code>，这个<code>handle</code>就是通过<code>ServiceManager</code>拿到的。但是<code>ServiceManager</code>和调用方也不是在同一个进程，因此想要和<code>ServiceManager</code>交互就必须拿到<code>ServiceManager</code>的<code>handle</code>，而<code>handle</code>又得通过和<code>ServiceManager</code>交互才能拿到。。。想解决这个问题，只需要将<code>ServiceManager</code>的<code>handle</code>固定即可，就不需要查询了，因此它的值被固定成为0。这样所有的进程，都可以通过0的来创建<code>ServiceManager</code>的代理服务进而进行交互了。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/cmds/servicemanager/main.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">// binder驱动的路径</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* driver = argc == <span class="hljs-number">2</span> ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">&quot;/dev/binder&quot;</span>;<br>    <span class="hljs-comment">// 初始化ProcessState</span><br>    sp&lt;ProcessState&gt; ps = ProcessState::<span class="hljs-built_in">initWithDriver</span>(driver);<br>    ps-&gt;<span class="hljs-built_in">setThreadPoolMaxThreadCount</span>(<span class="hljs-number">0</span>);<br>    ps-&gt;<span class="hljs-built_in">setCallRestriction</span>(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);<br>    <span class="hljs-comment">// 构建ServiceManager对象</span><br>    sp&lt;ServiceManager&gt; manager = sp&lt;ServiceManager&gt;::<span class="hljs-built_in">make</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Access&gt;());<br>    <span class="hljs-comment">// 将自己也注册到Service集合中</span><br>    <span class="hljs-keyword">if</span> (!manager-&gt;<span class="hljs-built_in">addService</span>(<span class="hljs-string">&quot;manager&quot;</span>, manager, <span class="hljs-literal">false</span> <span class="hljs-comment">/*allowIsolated*/</span>, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).<span class="hljs-built_in">isOk</span>()) &#123;<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Could not self register servicemanager&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将自己设置为管理服务</span><br>    IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">setTheContextObject</span>(manager);<br>    ps-&gt;<span class="hljs-built_in">becomeContextManager</span>();<br><br>    <span class="hljs-comment">// 启用looper机制</span><br>    sp&lt;Looper&gt; looper = Looper::<span class="hljs-built_in">prepare</span>(<span class="hljs-literal">false</span> <span class="hljs-comment">/*allowNonCallbacks*/</span>);<br>    <span class="hljs-comment">// 注册eventfd，当唤醒后处理对应的消息。这里实际注册的是驱动的fd</span><br>    BinderCallback::<span class="hljs-built_in">setupTo</span>(looper);<br>    ClientCallbackCallback::<span class="hljs-built_in">setupTo</span>(looper, manager);<br>    <span class="hljs-comment">// 开始循环进入阻塞，驱动有消息时才会通过epoll唤醒</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        looper-&gt;<span class="hljs-built_in">pollAll</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br></code></pre></td></tr></table></figure><p>开机时<code>ServiceManager</code>就会启动，它的启动逻辑就是上述逻辑。概述下来就是创建<code>ServiceManager</code>对象，然后注册到自身中，然后将自己设置为<code>binder</code>的管理者，然后开始进入阻塞等待<code>Binder</code>驱动的<code>epoll</code>唤醒，唤醒后再去处理相关的业务。</p><p>下面具体看下实现的细节，首先是<code>ProcessState</code>，它的定义在<code>frameworks/native/libs/binder/include/binder/ProcessState.h</code>，这里只是定义了它的一些方法，没什么可看的，直接看它的逻辑部分：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/ProcessState.cpp</span><br><br><span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ProcessState::initWithDriver</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* driver)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">init</span>(driver, <span class="hljs-literal">true</span> <span class="hljs-comment">/*requireDefault*/</span>);<br>&#125;<br><br><span class="hljs-comment">// 创建ProcessState，通过静态变量实现进程唯一单例</span><br>[[clang::no_destroy]] <span class="hljs-type">static</span> sp&lt;ProcessState&gt; gProcess;<br>[[clang::no_destroy]] <span class="hljs-type">static</span> std::mutex gProcessMutex;<br><span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ProcessState::init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *driver, <span class="hljs-type">bool</span> requireDefault)</span></span><br><span class="hljs-function"></span>&#123;<br>    [[clang::no_destroy]] <span class="hljs-type">static</span> std::once_flag gProcessOnce;<br>    std::<span class="hljs-built_in">call_once</span>(gProcessOnce, [&amp;]()&#123;<br>        ...<br>        std::lock_guard&lt;std::mutex&gt; <span class="hljs-built_in">l</span>(gProcessMutex);<br>        gProcess = sp&lt;ProcessState&gt;::<span class="hljs-built_in">make</span>(driver);<br>    &#125;);<br>    ...<br>    <span class="hljs-built_in">verifyNotForked</span>(gProcess-&gt;mForked);<br>    <span class="hljs-keyword">return</span> gProcess;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是在<code>initWithDriver</code>的时候，会通过智能指针的<code>sp::make</code>创建<code>ProcessState</code>对象，并且这个对象是进程中的唯一单例对象。这里的make实际上就是调用了它的new方法创建的，所以直接看构造方法即可。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="c++ hljs">ProcessState::<span class="hljs-built_in">ProcessState</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* driver)<br>      : <span class="hljs-built_in">mDriverName</span>(<span class="hljs-built_in">String8</span>(driver)),<span class="hljs-comment">// 驱动的名字 /dev/binder</span><br>        <span class="hljs-built_in">mDriverFD</span>(<span class="hljs-number">-1</span>),<span class="hljs-comment">// 驱动的fd</span><br>        <span class="hljs-built_in">mVMStart</span>(MAP_FAILED), <span class="hljs-comment">// 映射内存的起始位置</span><br>        <span class="hljs-built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER),<br>        <span class="hljs-built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER),<br>        <span class="hljs-built_in">mExecutingThreadsCount</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">mWaitingForThreads</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS),<span class="hljs-comment">// 最大的线程数：15</span><br>        <span class="hljs-built_in">mStarvationStartTimeMs</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">mForked</span>(<span class="hljs-literal">false</span>),<br>        <span class="hljs-built_in">mThreadPoolStarted</span>(<span class="hljs-literal">false</span>),<br>        <span class="hljs-built_in">mThreadPoolSeq</span>(<span class="hljs-number">1</span>),<br>        <span class="hljs-built_in">mCallRestriction</span>(CallRestriction::NONE) &#123;<br>    <span class="hljs-comment">// 打开驱动</span><br>    base::Result&lt;<span class="hljs-type">int</span>&gt; opened = <span class="hljs-built_in">open_driver</span>(driver);<br><br>    <span class="hljs-keyword">if</span> (opened.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-comment">// 进行内存映射，将当前进程中的一部分内存与内核的内存进行映射，大小为1M-2*page</span><br>        mVMStart = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE,<br>                        opened.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 记录驱动的fd</span><br>    <span class="hljs-keyword">if</span> (opened.<span class="hljs-built_in">ok</span>()) &#123;<br>        mDriverFD = opened.<span class="hljs-built_in">value</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> base::Result&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">open_driver</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* driver)</span> </span>&#123;<br>    <span class="hljs-comment">// 打开驱动</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(driver, O_RDWR | O_CLOEXEC);<br>    <span class="hljs-comment">// 查询binder的版本</span><br>    <span class="hljs-type">int</span> vers = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">status_t</span> result = <span class="hljs-built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);<br>    <span class="hljs-comment">// 设置最大的线程数：默认是15</span><br>    <span class="hljs-type">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;<br>    result = <span class="hljs-built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);<br>    <span class="hljs-comment">// 是否允许单向的binder垃圾检测</span><br>    <span class="hljs-type">uint32_t</span> enable = DEFAULT_ENABLE_ONEWAY_SPAM_DETECTION;<br>    result = <span class="hljs-built_in">ioctl</span>(fd, BINDER_ENABLE_ONEWAY_SPAM_DETECTION, &amp;enable);<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>ProcessState</code>的构造方法中，对驱动做了一些基础的设置，如线程数、内存映射等操作。总的来说就是<code>ProcessState</code>是进程内单例的，用于和<code>binder</code>驱动建立连接的一个对象。它是通用的，因此在构造方法中就直接打开驱动并做了一些通用的设置，如设置最大线程数。继续回到启动<code>ServiceManager</code>的main方法中，在<code>initWithDriver</code>后，又重新设置了最大线程数为0：<code>ps-&gt;setThreadPoolMaxThreadCount(0)</code>，也就是说<code>ServiceManager</code>中线程池的个数为0，即当前进程只会存在一个默认的主线程。</p><p>这里我们先不去看驱动的具体实现过程，而是把驱动作为一个黑盒来理解。我们只需要知道可以通过<code>open</code>打开驱动，通过<code>ioctl</code>进行设置和交互，至于具体实现后续再仔细研读。接下来继续回到main方法中，然后看<code>ServiceManager</code>的构造：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/cmds/servicemanager/ServiceManager.h</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceManager</span> : <span class="hljs-keyword">public</span> os::BnServiceManager, <span class="hljs-keyword">public</span> IBinder::DeathRecipient &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ServiceManager</span>(std::unique_ptr&lt;Access&gt;&amp;&amp; access);<br>    ~<span class="hljs-built_in">ServiceManager</span>();<br><br>    <span class="hljs-function">binder::Status <span class="hljs-title">getService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">binder::Status <span class="hljs-title">checkService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">binder::Status <span class="hljs-title">addService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; binder,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">bool</span> allowIsolated, <span class="hljs-type">int32_t</span> dumpPriority)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">binder::Status <span class="hljs-title">listServices</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> dumpPriority, std::vector&lt;std::string&gt;* outList)</span> <span class="hljs-keyword">override</span></span>;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Service</span> &#123;<br>        sp&lt;IBinder&gt; binder; <span class="hljs-comment">// not null</span><br>        ...<br>    &#125;;<br>    <span class="hljs-keyword">using</span> ServiceMap = std::map&lt;std::string, Service&gt;;<br>    ServiceMap mNameToService;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>ServiceManager</code>是为了成为<code>binder</code>服务的管理者，它所相关的方法都是由用户查询和添加服务的，它有一个私有属性<code>ServiceMap</code>，用于存储注册的服务。可以看到它是继承自<code>BnServiceManager</code>的，这是<code>AIDL</code>生成的类，通常情况下我们使用AIDL都是在Java层中使用的，可以省下很多跨进程逻辑的编码。而在C++层也是可以使用AIDL的，它会生成对应的<code>BnServiceManager</code>和<code>BpServiceManager</code>，我们的本地实体服务继承自<code>BnServiceManager</code>，然后实现对应的逻辑。然后<code>BpServiceManager</code>中的逻辑是跨进程交互的逻辑，由AIDL直接生成，后面我们再看它生成的类。文件目录在：<code>frameworks/native/libs/binder/aidl/android/os/IServiceManager.aidl</code></p><p>然后继续看构造方法和添加服务的方法：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/cmds/servicemanager/ServiceManager.cpp</span><br><br>ServiceManager::<span class="hljs-built_in">ServiceManager</span>(std::unique_ptr&lt;Access&gt;&amp;&amp; access) : <span class="hljs-built_in">mAccess</span>(std::<span class="hljs-built_in">move</span>(access)) &#123;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">ServiceManager::addService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="hljs-type">bool</span> allowIsolated, <span class="hljs-type">int32_t</span> dumpPriority)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 添加到ServiceMap中</span><br>    mNameToService[name] = Service &#123;<br>        .binder = binder,<br>        .allowIsolated = allowIsolated,<br>        .dumpPriority = dumpPriority,<br>        .debugPid = ctx.debugPid,<br>    &#125;;<br>    ...<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">ok</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里仅是将自身添加到<code>ServiceMap</code>中存储下来，逻辑比较简单，因为这里也没有发生跨进程的调用，都是发生在<code>ServiceManager</code>的进程中的。添加服务后，它还会注册自己成为服务管理者，<code>IPCThreadState::self()-&gt;setTheContextObject(manager)</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span><br><br><span class="hljs-comment">// 创建线程中单例对象</span><br><span class="hljs-function">IPCThreadState* <span class="hljs-title">IPCThreadState::self</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (gHaveTLS.<span class="hljs-built_in">load</span>(std::memory_order_acquire)) &#123;<br>restart:<br>        <span class="hljs-type">const</span> <span class="hljs-type">pthread_key_t</span> k = gTLS;<br>        <span class="hljs-comment">// 从线程局部变量中读取，读不到则直接创建。在构造方法中会存入到线程局部变量中</span><br>        <span class="hljs-comment">// 下次就可以直接获取到了</span><br>        IPCThreadState* st = (IPCThreadState*)<span class="hljs-built_in">pthread_getspecific</span>(k);<br>        <span class="hljs-keyword">if</span> (st) <span class="hljs-keyword">return</span> st;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IPCThreadState;<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">goto</span> restart;<br>&#125;<br><br>IPCThreadState::<span class="hljs-built_in">IPCThreadState</span>()<br>      : <span class="hljs-built_in">mProcess</span>(ProcessState::<span class="hljs-built_in">self</span>()),<span class="hljs-comment">// 获取到ProcessState</span><br>        <span class="hljs-built_in">mServingStackPointer</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">mServingStackPointerGuard</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">mWorkSource</span>(kUnsetWorkSource),<br>        <span class="hljs-built_in">mPropagateWorkSource</span>(<span class="hljs-literal">false</span>),<br>        <span class="hljs-built_in">mIsLooper</span>(<span class="hljs-literal">false</span>),<br>        <span class="hljs-built_in">mIsFlushing</span>(<span class="hljs-literal">false</span>),<br>        <span class="hljs-built_in">mStrictModePolicy</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">mLastTransactionBinderFlags</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">mCallRestriction</span>(mProcess-&gt;mCallRestriction) &#123;<br>    <span class="hljs-built_in">pthread_setspecific</span>(gTLS, <span class="hljs-keyword">this</span>);<span class="hljs-comment">// 将自己存入到线程局部变量中</span><br>    <span class="hljs-built_in">clearCaller</span>();<br>    mIn.<span class="hljs-built_in">setDataCapacity</span>(<span class="hljs-number">256</span>);<span class="hljs-comment">// 从binder驱动读取的容量</span><br>    mOut.<span class="hljs-built_in">setDataCapacity</span>(<span class="hljs-number">256</span>); <span class="hljs-comment">// 向binder驱动写入的容量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IPCThreadState::setTheContextObject</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;BBinder&gt;&amp; obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    the_context_object = obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>ProcessState</code>，它是进程单例；对于<code>IPCThreadState</code>，它是线程单例。但是由于<code>ServiceManager</code>的线程池设置的为0，因此它们两个实际上都可以算是进程内单例的。然后<code>IPCThreadState#setTheContextObject</code>将自己设置为了服务管理者，对于其他进程的<code>IPCThreadState</code>，他们的<code>the_context_obj</code>实际上是空，所以当它们想获取<code>ServiceManager</code>的时候，就会通过handle为0的句柄去创建<code>BpServiceManager</code>。<br>最后一步是将自己注册到binder驱动中，因为它的handle是固定的，因此不需要将binder实体传入到驱动中，直接通过命令注册即可。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/ProcessState.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ProcessState::becomeContextManager</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    flat_binder_object obj &#123;<br>        .flags = FLAT_BINDER_FLAG_TXN_SECURITY_CTX,<br>    &#125;;<br>    <span class="hljs-comment">// 新的注册指令</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">ioctl</span>(mDriverFD, BINDER_SET_CONTEXT_MGR_EXT, &amp;obj);<br>   <br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> unused = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 老的注册指令</span><br>        result = <span class="hljs-built_in">ioctl</span>(mDriverFD, BINDER_SET_CONTEXT_MGR, &amp;unused);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里<code>ServiceManager</code>的启动流程基本上已经完成了，首先就是通过<code>ProcessState</code>的初始化来打开binder驱动并建立内存映射，然后初始化<code>IPCThreadState</code>用于准备与驱动进行数据交互。最后就是启用<code>looper</code>循环了，然后将驱动的<code>fd</code>添加到<code>epoll</code>中监听<code>binder</code>的变化。可以查看<a href="https://pgaofeng.github.io/2022/03/07/handler/#Native%E5%B1%82%E6%BA%90%E7%A0%81" rel="noopener" target="_blank">native looper</a>的实现细节，也可以查看<a href="https://pgaofeng.github.io/2022/02/23/eventfd-epoll/" rel="noopener" target="_blank">epoll机制</a>的机制的实现。</p><p>在启动looper循环之前，注册了一个<code>BinderCallback</code>：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/cmds/servicemanager/main.cpp</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinderCallback</span> : <span class="hljs-keyword">public</span> LooperCallback &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> sp&lt;BinderCallback&gt; <span class="hljs-title">setupTo</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;Looper&gt;&amp; looper)</span> </span>&#123;<br>        sp&lt;BinderCallback&gt; cb = sp&lt;BinderCallback&gt;::<span class="hljs-built_in">make</span>();<br><br>        <span class="hljs-type">int</span> binder_fd = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 告知驱动自己进入了looper循环</span><br>        IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">setupPolling</span>(&amp;binder_fd);<br>        <span class="hljs-comment">// 将驱动的fd添加到looper监听中</span><br>        <span class="hljs-type">int</span> ret = looper-&gt;<span class="hljs-built_in">addFd</span>(binder_fd,<br>                                Looper::POLL_CALLBACK,<br>                                Looper::EVENT_INPUT,<br>                                cb,<br>                                <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/*data*/</span>);<br>        <span class="hljs-keyword">return</span> cb;<br>    &#125;<br><br>    <span class="hljs-comment">// 当驱动发生了变化后，会走到这里来</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">handleEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/* fd */</span>, <span class="hljs-type">int</span> <span class="hljs-comment">/* events */</span>, <span class="hljs-type">void</span>* <span class="hljs-comment">/* data */</span>)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 最终交给IPCThreadState处理消息</span><br>        IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">handlePolledCommands</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 进入循环前，将驱动fd添加到looper中，然后回调转发到IPCThreadState中处理</span><br>    BinderCallback::<span class="hljs-built_in">setupTo</span>(looper);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在进入<code>looper</code>循环时，将驱动的fd添加到了looper中，这样每次驱动发生变化后，就会通知到<code>ServiceManager</code>，然后由<code>ServiceManager</code>的<code>IPCThreadState</code>去处理消息。同时还会通知到驱动自己已经进入到looper循环了。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::setupPolling</span><span class="hljs-params">(<span class="hljs-type">int</span>* fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 写入BC_ENTER_LOOPER命令，然后刷新</span><br>    mOut.<span class="hljs-built_in">writeInt32</span>(BC_ENTER_LOOPER);<br>    <span class="hljs-built_in">flushCommands</span>();<br>    *fd = mProcess-&gt;mDriverFD;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IPCThreadState::flushCommands</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 与驱动进行交互</span><br>    <span class="hljs-built_in">talkWithDriver</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 如果还有待写入的内容，再次与驱动进行交互</span><br>    <span class="hljs-keyword">if</span> (mOut.<span class="hljs-built_in">dataSize</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">talkWithDriver</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在通知到驱动自己进入循环的过程，实际上就是与驱动进行的一个交互。先向mOut写入数据，然后再往驱动中进行写入，在前面看<code>IPCThreadState</code>的时候我们知道它有两个私有属性mIn和mOut。其中mIn用于读取驱动发送来的数据，而mOut用来写入即将向驱动写入的数据。最终在<code>talkWithDriver</code>中完成实际的写入和读取：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::talkWithDriver</span><span class="hljs-params">(<span class="hljs-type">bool</span> doReceive)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 向驱动写入的数据的结构体</span><br>    binder_write_read bwr;<br><br>    <span class="hljs-comment">// mIn中的数据是否是空的</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> needRead = mIn.<span class="hljs-built_in">dataPosition</span>() &gt;= mIn.<span class="hljs-built_in">dataSize</span>();<br>    <span class="hljs-comment">// 如果doReceive为false说明不是接收，而是发送，因此记录mOut的数据大小</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="hljs-built_in">dataSize</span>() : <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 设置写入的大小和缓存指针</span><br>    bwr.write_size = outAvail;<br>    bwr.write_buffer = (<span class="hljs-type">uintptr_t</span>)mOut.<span class="hljs-built_in">data</span>();<br><br>    <span class="hljs-comment">// 如果需要读取，则设置读取的容量和存储的指针</span><br>    <span class="hljs-keyword">if</span> (doReceive &amp;&amp; needRead) &#123;<br>        bwr.read_size = mIn.<span class="hljs-built_in">dataCapacity</span>();<br>        bwr.read_buffer = (<span class="hljs-type">uintptr_t</span>)mIn.<span class="hljs-built_in">data</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        bwr.read_size = <span class="hljs-number">0</span>;<br>        bwr.read_buffer = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 没有可读和可写的内容</span><br>    <span class="hljs-keyword">if</span> ((bwr.write_size == <span class="hljs-number">0</span>) &amp;&amp; (bwr.read_size == <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> NO_ERROR;<br><br>    bwr.write_consumed = <span class="hljs-number">0</span>;<br>    bwr.read_consumed = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">status_t</span> err;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 通过ioctl将结构体写入到驱动中</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="hljs-number">0</span>)<br>            err = NO_ERROR;<br>        <span class="hljs-keyword">else</span><br>            err = -errno;<br>    &#125; <span class="hljs-keyword">while</span> (err == -EINTR);<br><br>    <span class="hljs-comment">// 写入成功之后</span><br>    <span class="hljs-keyword">if</span> (err &gt;= NO_ERROR) &#123;<br>        <span class="hljs-keyword">if</span> (bwr.write_consumed &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (bwr.write_consumed &lt; mOut.<span class="hljs-built_in">dataSize</span>())<br>                <span class="hljs-comment">// 驱动没有将mOut中的数据读完</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 驱动读完了mOut的数据</span><br>                mOut.<span class="hljs-built_in">setDataSize</span>(<span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">processPostWriteDerefs</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 驱动有往bwr写入内容，或者上次的内容还没读取完</span><br>        <span class="hljs-keyword">if</span> (bwr.read_consumed &gt; <span class="hljs-number">0</span>) &#123;<br>            mIn.<span class="hljs-built_in">setDataSize</span>(bwr.read_consumed);<br>            mIn.<span class="hljs-built_in">setDataPosition</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> NO_ERROR;<br>    &#125;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>talkWithDriver</code>如其名字一样，与驱动进行交互。这个方法可以看到它不仅向驱动写入内容，也从驱动读取内容。当有内容需要写入到驱动的时候，先往mOut中写入，然后调用<code>talkWithDriver</code>写入到驱动中。如果想从驱动读取数据，需要先将mIn清空，然后调用<code>talkWithDriver</code>，然后就可以从mIn中读取到驱动写入的内容了。</p><p>然后看<code>looper</code>的回调，正常当向驱动发送数据后，驱动处理完之后会通知到<code>epoll</code>唤醒进程，进而回到looper中注册的回调，然后再走到<code>IPCThreadState</code>中处理：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::handlePolledCommands</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">status_t</span> result;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 获取并处理命令</span><br>        result = <span class="hljs-built_in">getAndExecuteCommand</span>();<br>    <span class="hljs-comment">// 命令处理完之后这里会是false，就会跳出循环了</span><br>    &#125; <span class="hljs-keyword">while</span> (mIn.<span class="hljs-built_in">dataPosition</span>() &lt; mIn.<span class="hljs-built_in">dataSize</span>());<br>    <span class="hljs-comment">// 再次talkWithDriver，查看是否有需要交互的</span><br>    <span class="hljs-built_in">flushCommands</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::getAndExecuteCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">status_t</span> result;<br>    <span class="hljs-type">int32_t</span> cmd;<br>    <span class="hljs-comment">// 与驱动交互，此时驱动正常会向mIn中写入数据</span><br>    result = <span class="hljs-built_in">talkWithDriver</span>();<br>    <span class="hljs-keyword">if</span> (result &gt;= NO_ERROR) &#123;<br>        <span class="hljs-comment">// 读取交互的命令</span><br>        cmd = mIn.<span class="hljs-built_in">readInt32</span>();<br>        <span class="hljs-comment">// 处理命令</span><br>        result = <span class="hljs-built_in">executeCommand</span>(cmd);<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新整理下交互逻辑：<code>ServiceManager</code>实例化之后，将自己设置成为服务管理者，并通知到驱动。<code>ProcessState</code>负责打开驱动建立映射，<code>IPCThreadState</code>负责向驱动发送和读取数据。首先向mOut写入数据，然后<code>talkWithDriver</code>将数据发送给驱动，然后驱动读取数据并处理后通过epoll机制回调到looper进而再次走到<code>IPCThreadState</code>，然后再次<code>talkWithDriver</code>让驱动把数据写入到mIn中，然后在<code>executeCommand</code>方法中处理mIn中的数据。</p><p>到这里<code>ServiceManager</code>的启动逻辑基本上已经清楚了，与驱动交互的逻辑也基本上已经清楚了，这里我们没是将驱动作为黑盒看待的，具体的逻辑以及命令交互的过程都是没仔细看的，这个在后面讲驱动的时候再看了。</p><h2 id="IServiceManager"><a href="#IServiceManager" class="headerlink" title="IServiceManager"></a>IServiceManager</h2><p>前面我们看到的<code>ServiceManager</code>都是定义在<code>frameworks/native/cmds/servicemanager</code>下的，然后继承的<code>BnServiceManager</code>是aidl生成的。实际上，在<code>Android10</code>及以前，<code>ServiceManager</code>是用C语言实现的，没有类的概念也就没有<code>ServiceManager</code>，所有的逻辑都是由C的结构体实现的。<br>其他模块基本上都是用的<code>C++</code>，因此为了提供方法给其他模块调用，在<code>frameworks/native/libs/binder/include/binder</code>下定义了<code>IServiceManager.h</code>，并且在<code>frameworks/native/libs/binder/</code>目录下定义了<code>IServiceManager.cpp</code>实现了<code>BpServiceManager</code>类。</p><p>到了<code>Android11</code>以后，<code>ServiceManager</code>弃用了原来的C语言实现，和普通的服务一样使用更加通用的AIDL方式实现，声明文件在：<code>frameworks/native/libs/binder/aidl/android/os/IServiceManager.aidl</code></p><p>编译后生成的文件在：<code>out/soong/.intermediates/frameworks/native/libs/binder/libbinder/android_x86_64_shared/gen/aidl/android/os</code>目录下。一共是四个文件：</p><ul><li><code>IServiceManager.h</code>：根据<code>IServiceManager.aidl</code>生成的接口</li><li><code>IServiceManager.cpp</code>：实现了<code>BpServiceManager</code>类的方法，通过<code>Parcel</code>中添加参数标记自己要调用的方法以及参数；实现了<code>BnServiceManager</code>中的<code>onTransact</code>方法，解析<code>Parcel</code>中的方法和参数，然后调用到自己本地的方法，然后将返回值再塞进<code>Parcel</code>中返回。</li><li><code>BnServiceManager.h</code>：代表着实体服务</li><li><code>BpServiceManager.h</code>：代表着远程代理服务</li></ul><p>通过<code>AIDL</code>实现的<code>ServiceManager</code>更加易于阅读，同时也更容易管理，整个逻辑和Java层的AIDL也是一致的。但是，原本的<code>IServiceManager</code>怎么办？不能废弃了吧，因为很多的地方都在使用<code>IServiceManager</code>，如果直接废弃了而使用AIDL生成的新的<code>IServiceManager</code>改动起来就太多了。因此为了兼容，对老的<code>IServiceManager</code>进行改造，让它的内部持有一个新的AIDL生成的的<code>ServiceManager</code>，原来的方法都由新的SM来进行处理，这样就不需要改动到别的地方了。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/include/binder/IServiceManager.h</span><br><br><span class="hljs-keyword">namespace</span> android &#123;<br><br><span class="hljs-comment">// 方法基本上与AIDL的IServiceManager一致，但是返回值有一些差异，使用了智能指针包裹</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IServiceManager</span> : <span class="hljs-keyword">public</span> IInterface<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> String16&amp; <span class="hljs-title">getInterfaceDescriptor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-built_in">IServiceManager</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IServiceManager</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> sp&lt;IBinder&gt;         <span class="hljs-title">getService</span><span class="hljs-params">( <span class="hljs-type">const</span> String16&amp; name)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> sp&lt;IBinder&gt;         <span class="hljs-title">checkService</span><span class="hljs-params">( <span class="hljs-type">const</span> String16&amp; name)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">status_t</span> <span class="hljs-title">addService</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; name, <span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">bool</span> allowIsolated = <span class="hljs-literal">false</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_DEFAULT)</span> </span>= <span class="hljs-number">0</span>;   <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vector&lt;String16&gt; <span class="hljs-title">listServices</span><span class="hljs-params">(<span class="hljs-type">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_ALL)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 在android命名空间中定义了一个获取默认ServiceManager的方法</span><br><span class="hljs-function">sp&lt;IServiceManager&gt; <span class="hljs-title">defaultServiceManager</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原本的<code>IServiceManager</code>和AIDL生成的类的方法基本上是一样的，但是方法的返回值可能会有一些差异，不过差异不大。另外，在<code>IServiceManager.h</code>中，在android的命名空间中增加了一个<code>defaultServiceManager</code>，用于获取到<code>ServiceManager</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// 给AIDL的IServiceManager起了个别名AidlServiceManager</span><br><span class="hljs-keyword">using</span> AidlServiceManager = android::os::IServiceManager;<br><br><br><span class="hljs-function"><span class="hljs-type">const</span> String16&amp; <span class="hljs-title">IServiceManager::getInterfaceDescriptor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> AidlServiceManager::descriptor;<br>&#125;<br>IServiceManager::<span class="hljs-built_in">IServiceManager</span>() &#123;&#125;<br>IServiceManager::~<span class="hljs-built_in">IServiceManager</span>() &#123;&#125;<br><br><span class="hljs-comment">// 老的ServiceManager的实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceManagerShim</span> : <span class="hljs-keyword">public</span> IServiceManager<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造方法中传入AIDL的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ServiceManagerShim</span> <span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;AidlServiceManager&gt;&amp; impl)</span></span>;<br><br>    <span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">getService</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; name)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">checkService</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; name)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">addService</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; name, <span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">bool</span> allowIsolated, <span class="hljs-type">int</span> dumpsysPriority)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">Vector&lt;String16&gt; <span class="hljs-title">listServices</span><span class="hljs-params">(<span class="hljs-type">int</span> dumpsysPriority)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 真实的IServiceManager，也就是AIDL的实现</span><br>    sp&lt;AidlServiceManager&gt; mTheRealServiceManager;<br>&#125;;<br><br><span class="hljs-comment">// -----------------------------------------------</span><br><span class="hljs-comment">// 获取默认的ServiceManager，然后存入到静态变量中</span><br>[[clang::no_destroy]] <span class="hljs-type">static</span> std::once_flag gSmOnce;<br>[[clang::no_destroy]] <span class="hljs-type">static</span> sp&lt;IServiceManager&gt; gDefaultServiceManager;<br><br><span class="hljs-function">sp&lt;IServiceManager&gt; <span class="hljs-title">defaultServiceManager</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-built_in">call_once</span>(gSmOnce, []() &#123;<br>        sp&lt;AidlServiceManager&gt; sm = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (sm == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">// 通过ProcessState.getContextObject获取到ServiceManager</span><br>            sm = <span class="hljs-built_in">interface_cast</span>&lt;AidlServiceManager&gt;(ProcessState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">getContextObject</span>(<span class="hljs-literal">nullptr</span>));<br>            <span class="hljs-keyword">if</span> (sm == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 构造IServiceManager，并传入AIDL的ServiceManager实现</span><br>        gDefaultServiceManager = sp&lt;ServiceManagerShim&gt;::<span class="hljs-built_in">make</span>(sm);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> gDefaultServiceManager;<br>&#125;<br><span class="hljs-comment">// ----------------------------------------------------------------------</span><br><br>ServiceManagerShim::<span class="hljs-built_in">ServiceManagerShim</span>(<span class="hljs-type">const</span> sp&lt;AidlServiceManager&gt;&amp; impl)<br>: <span class="hljs-built_in">mTheRealServiceManager</span>(impl)<br>&#123;&#125;<br><br><span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ServiceManagerShim::getService</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; name)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从AIDL实现的ServiceManager中查询服务</span><br>    sp&lt;IBinder&gt; svc = <span class="hljs-built_in">checkService</span>(name);<br>    <span class="hljs-keyword">if</span> (svc != <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> svc;<br>    <span class="hljs-comment">// 未查询到，则循环5次，每秒查询一次</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">uptimeMillis</span>() - startTime &lt; timeout) &#123;<br>        n++;<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">1000</span>*sleepTime);<br><br>        sp&lt;IBinder&gt; svc = <span class="hljs-built_in">checkService</span>(name);<br>        <span class="hljs-keyword">if</span> (svc != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> svc;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 从AIDL实现的ServiceManager中查询服务</span><br><span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ServiceManagerShim::checkService</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; name)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    sp&lt;IBinder&gt; ret;<br>    <span class="hljs-keyword">if</span> (!mTheRealServiceManager-&gt;<span class="hljs-built_in">checkService</span>(<span class="hljs-built_in">String8</span>(name).<span class="hljs-built_in">c_str</span>(), &amp;ret).<span class="hljs-built_in">isOk</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 通过AIDL实现的ServiceManager添加服务</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">ServiceManagerShim::addService</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; name, <span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">bool</span> allowIsolated, <span class="hljs-type">int</span> dumpsysPriority)</span></span><br><span class="hljs-function"></span>&#123;<br>    Status status = mTheRealServiceManager-&gt;<span class="hljs-built_in">addService</span>(<br>        <span class="hljs-built_in">String8</span>(name).<span class="hljs-built_in">c_str</span>(), service, allowIsolated, dumpsysPriority);<br>    <span class="hljs-keyword">return</span> status.<span class="hljs-built_in">exceptionCode</span>();<br>&#125;<br><br><span class="hljs-comment">// 通过AIDL实现的ServiceManager列出所有服务，并将数组转换成集合</span><br><span class="hljs-function">Vector&lt;String16&gt; <span class="hljs-title">ServiceManagerShim::listServices</span><span class="hljs-params">(<span class="hljs-type">int</span> dumpsysPriority)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;std::string&gt; ret;<br>    <span class="hljs-keyword">if</span> (!mTheRealServiceManager-&gt;<span class="hljs-built_in">listServices</span>(dumpsysPriority, &amp;ret).<span class="hljs-built_in">isOk</span>()) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    Vector&lt;String16&gt; res;<br>    res.<span class="hljs-built_in">setCapacity</span>(ret.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::string&amp; name : ret) &#123;<br>        res.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">String16</span>(name.<span class="hljs-built_in">c_str</span>()));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>IServiceManager</code>的实现类实际是<code>ServiceManagerShim</code>，它只是个包装类，实际的方法实现仍然是由AIDL的<code>ServiceManager</code>实现的，它只是起到包装的作用，并且修改了方法返回值等，以适配原本的<code>IServiceManager</code>。同时，它还额外添加了一个方法<code>defaultServiceManager</code>来获取默认的AIDL的<code>ServiceManager</code>，该方法返回的值仍然是进程单例的，在当前进程中只会存在一个<code>ServiceManager</code>。该方法实际是获取到<code>ServiceManager</code>的<code>IBinder</code>对象，然后转成<code>IServiceManager</code>的。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/ProcessState.cpp</span><br><br><span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ProcessState::getContextObject</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; <span class="hljs-comment">/*caller*/</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// handle传的值为0，也就是ServiceManager的默认handle</span><br>    sp&lt;IBinder&gt; context = <span class="hljs-built_in">getStrongProxyForHandle</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br><br><span class="hljs-comment">// 根据handle从已注册的服务中查找</span><br><span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ProcessState::getStrongProxyForHandle</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> handle)</span></span><br><span class="hljs-function"></span>&#123;<br>    sp&lt;IBinder&gt; result;<br>    <span class="hljs-comment">// handle为0，并且the_context_object不为空，说明当前进程</span><br>    <span class="hljs-comment">// 是ServiceManager的进程，因此直接返回实体binder</span><br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-number">0</span> &amp;&amp; the_context_object != <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> the_context_object;<br><br>    <span class="hljs-comment">// 如果handle对应的没有handle_entry就创建一个返回</span><br>    handle_entry* e = <span class="hljs-built_in">lookupHandleLocked</span>(handle);<br><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">nullptr</span>) &#123;<br>        IBinder* b = e-&gt;binder;<br>        <span class="hljs-comment">// 新创建的entry是没有binder的</span><br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">nullptr</span> || !e-&gt;refs-&gt;<span class="hljs-built_in">attemptIncWeak</span>(<span class="hljs-keyword">this</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (handle == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// handle为0，说明创建的是ServiceManager</span><br>                IPCThreadState* ipc = IPCThreadState::<span class="hljs-built_in">self</span>();<br>                <span class="hljs-comment">// 需要检测ServiceManager是否是可用的</span><br>                Parcel data;<br>                <span class="hljs-type">status_t</span> status = ipc-&gt;<span class="hljs-built_in">transact</span>(<br>                        <span class="hljs-number">0</span>, IBinder::PING_TRANSACTION, data, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (status == DEAD_OBJECT)<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-comment">// 创建BpBinder返回</span><br>            sp&lt;BpBinder&gt; b = BpBinder::PrivateAccessor::<span class="hljs-built_in">create</span>(handle);<br>            e-&gt;binder = b.<span class="hljs-built_in">get</span>();<br>            <span class="hljs-keyword">if</span> (b) e-&gt;refs = b-&gt;<span class="hljs-built_in">getWeakRefs</span>();<br>            result = b;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result.force_set(b);<br>            e-&gt;refs-&gt;<span class="hljs-built_in">decWeak</span>(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getContextObject</code>获取<code>ServiceManager</code>，如果是同一个进程则直接能拿到实体<code>Binder</code>，如果不是同一个进程则创建<code>handle</code>为0的<code>BpBinder</code>，反正最终结果是能拿到一个<code>IBinder</code>，然后再将其转换成<code>IServiceManager</code>就可以了，至于这个<code>IServiceManager</code>是实体服务还是远程代理服务都无所谓啦。</p><p><img class="lozad post-image" src="/img/binder-2.webp" alt="UML" data-src="/img/binder-2.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><h2 id="IServiceManager-aidl"><a href="#IServiceManager-aidl" class="headerlink" title="IServiceManager.aidl"></a>IServiceManager.aidl</h2><p>一般来说，我们注册服务肯定是获取到<code>IServiceManager</code>，然后通过<code>addService</code>方法进行注册。经过前面的分析我们知道<code>IServiceManager</code>实际上是包装了AIDL的<code>IServiceManager</code>，因此我们可以看看AIDL生成的代码逻辑是怎么样的。注意，<code>AOSP</code>中只有<code>IServiceManager.aidl</code>文件的，想看实现的话必须将源码下载下来进行编译，编译之后才会有我们想要的:</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// out/soong/.intermediates/frameworks/native/libs/binder/libbinder/</span><br><span class="hljs-comment">// android_x86_64_shared/gen/aidl/android/os/IServiceManager.cpp</span><br><br>::android::<span class="hljs-function">binder::Status <span class="hljs-title">BpServiceManager::addService</span><span class="hljs-params">(<span class="hljs-type">const</span> ::std::string&amp; name, <span class="hljs-type">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; service, <span class="hljs-type">bool</span> allowIsolated, <span class="hljs-type">int32_t</span> dumpPriority)</span> </span>&#123;<br>  ::android::Parcel _aidl_data;<br>  _aidl_data.<span class="hljs-built_in">markForBinder</span>(<span class="hljs-built_in">remoteStrong</span>());<br>  ::android::Parcel _aidl_reply;<br>  ::android::<span class="hljs-type">status_t</span> _aidl_ret_status = ::android::OK;<br>  ::android::binder::Status _aidl_status;<br>    <span class="hljs-comment">// 向parcel中写入要传递的数据</span><br>  _aidl_ret_status = _aidl_data.<span class="hljs-built_in">writeInterfaceToken</span>(<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>  _aidl_ret_status = _aidl_data.<span class="hljs-built_in">writeUtf8AsUtf16</span>(name);<br>  _aidl_ret_status = _aidl_data.<span class="hljs-built_in">writeStrongBinder</span>(service);<br>  _aidl_ret_status = _aidl_data.<span class="hljs-built_in">writeBool</span>(allowIsolated);<br>  _aidl_ret_status = _aidl_data.<span class="hljs-built_in">writeInt32</span>(dumpPriority);<br>  <span class="hljs-comment">// 跨进程调用方法</span><br>  _aidl_ret_status = <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(BnServiceManager::TRANSACTION_addService, _aidl_data, &amp;_aidl_reply, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 检查远程的ServiceManager的回复是否是OK</span><br>  _aidl_ret_status = _aidl_status.<span class="hljs-built_in">readFromParcel</span>(_aidl_reply);<br>  <span class="hljs-keyword">return</span> _aidl_status;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是往<code>Parcel</code>中写入数据，如服务的名字，服务的本体等。然后通过<code>remote().transact</code>方法进行跨进程的调用，其中<code>remote()</code>方法是定义在<code>BpRefBase</code>中的，它的返回值是<code>IBinder*</code>。而我们获取的<code>IServiceManager</code>的实际类型是<code>BpServiceManager</code>，它是继承自<code>BpInterface</code>，又继承自<code>BpRefBase</code>。因此我们实际是调用到了<code>BpBinder.transact</code>中了。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/include/binder/Binder.h</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BpRefBase</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> RefBase<br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span>                <span class="hljs-title">BpRefBase</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; o)</span></span>;<br>    <span class="hljs-keyword">virtual</span>                 ~<span class="hljs-built_in">BpRefBase</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>            <span class="hljs-title">onFirstRef</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>            <span class="hljs-title">onLastStrongRef</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* id)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span>            <span class="hljs-title">onIncStrongAttempted</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> flags, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* id)</span></span>;<br>    <span class="hljs-comment">// 获取到远程Binder</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> IBinder* <span class="hljs-title">remote</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> mRemote; &#125;<br>    <span class="hljs-comment">// 使用强引用来访问远程Binder</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> sp&lt;IBinder&gt; <span class="hljs-title">remoteStrong</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> sp&lt;IBinder&gt;::<span class="hljs-built_in">fromExisting</span>(mRemote); &#125;<br><br><span class="hljs-keyword">private</span>:<br>                            <span class="hljs-built_in">BpRefBase</span>(<span class="hljs-type">const</span> BpRefBase&amp; o);<br>    BpRefBase&amp;              <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> BpRefBase&amp; o);<br><br>    IBinder* <span class="hljs-type">const</span>          mRemote;<br>    RefBase::weakref_type*  mRefs;<br>    std::atomic&lt;<span class="hljs-type">int32_t</span>&gt;    mState;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在前面我们看过<code>BpBinder</code>的源码，它的transact实现实际是调用<code>IPCThreadState</code>的<code>transact</code>方法，所以只要是跨进程的逻辑，最终都是走到了<code>IPCThreadState</code>中。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::transact</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  Parcel* reply, <span class="hljs-type">uint32_t</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">status_t</span> err;<br>    <span class="hljs-comment">// 写入要传输的数据</span><br>    err = <span class="hljs-built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="hljs-literal">nullptr</span>);<br>   <br>    <span class="hljs-keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 非单向消息，需要等待回复</span><br>        <span class="hljs-keyword">if</span> (reply) &#123;<br>            <span class="hljs-comment">// 等待回复</span><br>            err = <span class="hljs-built_in">waitForResponse</span>(reply);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// reply为空，需要构建一个新的Parcel来接收回复</span><br>            Parcel fakeReply;<br>            err = <span class="hljs-built_in">waitForResponse</span>(&amp;fakeReply);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 单向消息不需要回复</span><br>        err = <span class="hljs-built_in">waitForResponse</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::writeTransactionData</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> cmd, <span class="hljs-type">uint32_t</span> binderFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int32_t</span> handle, <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, <span class="hljs-type">status_t</span>* statusBuffer)</span></span><br><span class="hljs-function"></span>&#123;<br>    binder_transaction_data tr;<br>    ..<br>    <span class="hljs-comment">// 将参数写入到tr中之后，再将命令和数据写入到mOut中</span><br>    mOut.<span class="hljs-built_in">writeInt32</span>(cmd);<br>    mOut.<span class="hljs-built_in">write</span>(&amp;tr, <span class="hljs-built_in">sizeof</span>(tr));<br><br>    <span class="hljs-keyword">return</span> NO_ERROR;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就进入到驱动了，驱动中会进行一系列的处理，这里也暂时先不去看。反正最后就会走到实体服务<code>BnServiceManager</code>的<code>onTransact</code>方法中：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// out/soong/.intermediates/frameworks/native/libs/binder/libbinder/</span><br><span class="hljs-comment">// android_x86_64_shared/gen/aidl/android/os/IServiceManager.cpp</span><br><br>::<span class="hljs-function">android::<span class="hljs-type">status_t</span> <span class="hljs-title">BnServiceManager::onTransact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> _aidl_code, <span class="hljs-type">const</span> ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, <span class="hljs-type">uint32_t</span> _aidl_flags)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (_aidl_code) &#123;<br>  ...<br>  <span class="hljs-keyword">case</span> BnServiceManager::TRANSACTION_addService:<br>  &#123;<br>    ...<br>    <span class="hljs-comment">// 读取客户端传递过来的消息</span><br>    _aidl_ret_status = _aidl_data.<span class="hljs-built_in">readUtf8FromUtf16</span>(&amp;in_name);<br>    _aidl_ret_status = _aidl_data.<span class="hljs-built_in">readStrongBinder</span>(&amp;in_service);<br>    _aidl_ret_status = _aidl_data.<span class="hljs-built_in">readBool</span>(&amp;in_allowIsolated);<br>    _aidl_ret_status = _aidl_data.<span class="hljs-built_in">readInt32</span>(&amp;in_dumpPriority);<br>    <span class="hljs-comment">// 最终是走到了本地的addService添加服务</span><br>    ::android::binder::Status _aidl_status(<span class="hljs-built_in">addService</span>(in_name, in_service, in_allowIsolated, in_dumpPriority));<br>    _aidl_ret_status = _aidl_status.<span class="hljs-built_in">writeToParcel</span>(_aidl_reply);<br>  &#125;<br>  ...<br>  &#125;<br>  <span class="hljs-keyword">return</span> _aidl_ret_status;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终是走到<code>ServiceManager</code>实体的<code>addService</code>方法来将服务添加到集合中，<code>addService</code>我们前面看到，就是将<code>binder</code>添加到它的<code>ServiceMap</code>中。同样的，查找服务的时候也是向上面的流程一样，<code>BpServiceManager</code>将所需要的数据写入到<code>Parcel</code>中，然后经由驱动中转，最终到达<code>BnServiceManager</code>中的<code>onTransact</code>：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// out/soong/.intermediates/frameworks/native/libs/binder/libbinder/</span><br><span class="hljs-comment">// android_x86_64_shared/gen/aidl/android/os/IServiceManager.cpp</span><br><br>::<span class="hljs-function">android::<span class="hljs-type">status_t</span> <span class="hljs-title">BnServiceManager::onTransact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> _aidl_code, <span class="hljs-type">const</span> ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, <span class="hljs-type">uint32_t</span> _aidl_flags)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (_aidl_code) &#123;<br>  ...<br>  <span class="hljs-keyword">case</span> BnServiceManager::TRANSACTION_getService:<br>  &#123;<br>    <span class="hljs-comment">// 读取要查找的服务的名字</span><br>    _aidl_ret_status = _aidl_data.<span class="hljs-built_in">readUtf8FromUtf16</span>(&amp;in_name);<br>    <span class="hljs-comment">// 查找服务</span><br>    ::android::binder::Status _aidl_status(<span class="hljs-built_in">getService</span>(in_name, &amp;_aidl_return));<br>    <span class="hljs-comment">// 写入到reply中，然后客户端就可以拿到IBinder了</span><br>    _aidl_ret_status = _aidl_status.<span class="hljs-built_in">writeToParcel</span>(_aidl_reply);<br>    _aidl_ret_status = _aidl_reply-&gt;<span class="hljs-built_in">writeStrongBinder</span>(_aidl_return);<br>  &#125;<br>  ...<br>  &#125;<br>  <span class="hljs-keyword">return</span> _aidl_ret_status;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终走到<code>ServiceManager</code>实体的<code>getService</code>方法中：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/cmds/servicemanager/ServiceManager.cpp</span><br><br><span class="hljs-function">Status <span class="hljs-title">ServiceManager::getService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> </span>&#123;<br>    *outBinder = <span class="hljs-built_in">tryGetService</span>(name, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">ok</span>();<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">ServiceManager::checkService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> </span>&#123;<br>    *outBinder = <span class="hljs-built_in">tryGetService</span>(name, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">ok</span>();<br>&#125;<br><br><span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ServiceManager::tryGetService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">bool</span> startIfNotFound)</span> </span>&#123;<br>    sp&lt;IBinder&gt; out;<br>    Service* service = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 从注册的ServiceMap中根据名字查询</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> it = mNameToService.<span class="hljs-built_in">find</span>(name); it != mNameToService.<span class="hljs-built_in">end</span>()) &#123;<br>        service = &amp;(it-&gt;second);<br>        out = service-&gt;binder;<br>    &#125;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>注册服务和查找服务，都是一个跨进程的调用。我们看到在生成的AIDL代码中，在<code>BpServiceManager</code>中会自动将跨进程的方法包装成对应的code和data，然后进行快进程调用。而在<code>BnServiceManager</code>中会自动将数据进行解包判断，然后调用自身的方法，最终实现了跨进程的方法调用。</p><h2 id="IInterface"><a href="#IInterface" class="headerlink" title="IInterface"></a>IInterface</h2><p>至此，我们已经知道了<code>Binder</code>是什么了。它就是一个服务，一个可以跨越进程交互的服务。<code>Binder</code>的设计可以让我们以同步的方式实现跨进程的调用，它封装了具体的细节，让我们在使用的地方完全看不出来它是一个跨进程的调用。</p><p>那么服务又是什么呢？服务指的是注册在<code>ServiceManager</code>中的服务，可以说服务就是<code>Binder</code>。在前面我们看<code>defaultServiceManager</code>的时候，它是先获取到<code>ServiceManager</code>的<code>BpBinder</code>，然后通过<code>interface_cast&lt;AidlServiceManager&gt;</code>转成的<code>BpServiceManager</code>。如果获取的是<code>BBinder</code>的话，转换的结果就是<code>BnServiceManager</code>。这里之所以能够转换，就是因为<code>IInterface</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/include/binder/IInterface.h</span><br><br><span class="hljs-comment">// 基础接口，服务都需要继承自IInterface</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IInterface</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> RefBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">IInterface</span>();<br>    <span class="hljs-comment">// 将IInterface转换成IBinder</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> sp&lt;IBinder&gt;  <span class="hljs-title">asBinder</span><span class="hljs-params">(<span class="hljs-type">const</span> IInterface*)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> sp&lt;IBinder&gt;  <span class="hljs-title">asBinder</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;IInterface&gt;&amp;)</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">virtual</span>                     ~<span class="hljs-built_in">IInterface</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IBinder*            <span class="hljs-title">onAsBinder</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 服务本体需要继承自BnInterface</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BnInterface</span> : <span class="hljs-keyword">public</span> INTERFACE, <span class="hljs-keyword">public</span> BBinder<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 获取到本地的服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> sp&lt;IInterface&gt;      <span class="hljs-title">queryLocalInterface</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; _descriptor)</span></span>;<br>    <span class="hljs-comment">// 获取服务的描述符，用于进行区分服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> String16&amp;     <span class="hljs-title">getInterfaceDescriptor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">typedef</span> INTERFACE           BaseInterface;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IBinder*            <span class="hljs-title">onAsBinder</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 远程服务代理需要继承自BpInterface</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BpInterface</span> : <span class="hljs-keyword">public</span> INTERFACE, <span class="hljs-keyword">public</span> BpRefBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span>                    <span class="hljs-title">BpInterface</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; remote)</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">typedef</span> INTERFACE           BaseInterface;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IBinder*            <span class="hljs-title">onAsBinder</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img class="lozad post-image" src="/img/binder-3.webp" alt="URL2" data-src="/img/binder-3.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><p>在前面我们获取到<code>ServiceManager</code>的<code>IBinder</code>后，就通过<code>interface_cast</code>转换成对应的<code>ServiceManager</code>了。因为<code>BnServiceManager</code>是继承自<code>BBinder</code>的，所以可以直接强转，而<code>BpServiceManager</code>与<code>IBinder</code>并没有直接的继承关系，因此是无法直接强转的。也就是说，<code>interface_cast</code>肯定不是简单的强转，而是有一定的逻辑在其中。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/include/binder/IInterface.h</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> sp&lt;INTERFACE&gt; <span class="hljs-title">interface_cast</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> INTERFACE::<span class="hljs-built_in">asInterface</span>(obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>interface_cast</code>是定义在<code>IInterface</code>文件中的一个模板类方法，它的实现方法实际上是调用它指向的对象的<code>asInterface</code>方法，但是我们翻遍了所有的类和它的父类，都没有发现<code>asInterface</code>在哪定义的。再仔细看看实际是在<code>IInterface</code>中的一个宏中定义的：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/include/binder/IInterface.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                                                         \</span><br><span class="hljs-meta">public:                                                                                           \</span><br><span class="hljs-meta">    <span class="hljs-comment">// descriptor实际是用来标识当前Service的</span></span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> ::android::String16 descriptor;                                                  \<br>    <span class="hljs-comment">// 根据IBinder，转换成对应的Service</span><br>    <span class="hljs-type">static</span> ::<span class="hljs-function">android::sp&lt;I##INTERFACE&gt; <span class="hljs-title">asInterface</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span></span>; \<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> ::<span class="hljs-function">android::String16&amp; <span class="hljs-title">getInterfaceDescriptor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                            \<br>    I##<span class="hljs-built_in">INTERFACE</span>();                                                                               \<br>    <span class="hljs-keyword">virtual</span> ~I##<span class="hljs-built_in">INTERFACE</span>();                                                                      \<br>    <span class="hljs-comment">// 设置默认实现，不重要</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">setDefaultImpl</span><span class="hljs-params">(::android::sp&lt;I##INTERFACE&gt; impl)</span></span>;                                 \<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> ::<span class="hljs-function">android::sp&lt;I##INTERFACE&gt;&amp; <span class="hljs-title">getDefaultImpl</span><span class="hljs-params">()</span></span>;                                   \<br>                                                                                                  \<br><span class="hljs-keyword">private</span>:                                                                                          \<br>    <span class="hljs-type">static</span> ::android::sp&lt;I##INTERFACE&gt; default_impl;                                              \<br>                                                                                                  \<br><span class="hljs-keyword">public</span>:<br></code></pre></td></tr></table></figure><p>它定义了一个<code>descriptor</code>属性以及一些方法，<code>asInterface</code>就是其中之一。同样的，它的实现部分也是在宏中定义的：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// 我们应该使用这个宏来实现对应的方法</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span><br><span class="hljs-meta">    DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME)    \</span><br><span class="hljs-meta">   </span><br><span class="hljs-comment">// 一般而言不要用这个宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                        \</span><br><span class="hljs-meta">    const ::android::StaticString16 I##INTERFACE##_descriptor_static_str16(                     \</span><br><span class="hljs-meta">            __IINTF_CONCAT(u, NAME));                                                           \</span><br><span class="hljs-meta">    <span class="hljs-comment">// 定义了这个服务的描述符</span></span><br>    <span class="hljs-type">const</span> ::android::String16 I##INTERFACE::<span class="hljs-built_in">descriptor</span>(I##INTERFACE##_descriptor_static_str16); \<br>    <span class="hljs-built_in">DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE0</span>(I##INTERFACE, I##INTERFACE, Bp##INTERFACE)<br>   <br><span class="hljs-comment">// 禁止直接使用这个宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE0(ITYPE, INAME, BPTYPE)                     \</span><br><span class="hljs-meta">    <span class="hljs-comment">// 返回descriptor，在前一个宏中定义的</span></span><br>    <span class="hljs-type">const</span> ::<span class="hljs-function">android::String16&amp; <span class="hljs-title">ITYPE::getInterfaceDescriptor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ITYPE::descriptor; &#125; \<br>    <span class="hljs-comment">// 根据IBinder返回对应的Service</span><br>    ::<span class="hljs-function">android::sp&lt;ITYPE&gt; <span class="hljs-title">ITYPE::asInterface</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span> </span>&#123;        \<br>        ::android::sp&lt;ITYPE&gt; intr;                                                                 \<br>        <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">nullptr</span>) &#123;                                                                      \<br>            <span class="hljs-comment">// 首先通过queryLocalInterface方法查询Service</span><br>            intr = ::android::sp&lt;ITYPE&gt;::<span class="hljs-built_in">cast</span>(obj-&gt;<span class="hljs-built_in">queryLocalInterface</span>(ITYPE::descriptor));        \<br>            <span class="hljs-keyword">if</span> (intr == <span class="hljs-literal">nullptr</span>) &#123;                                                                 \<br>                <span class="hljs-comment">// 查询不到的话，直接创建一个Bp类型的Service</span><br>                intr = ::android::sp&lt;BPTYPE&gt;::<span class="hljs-built_in">make</span>(obj);                                           \<br>            &#125;                                                                                      \<br>        &#125;                                                                                          \<br>        <span class="hljs-keyword">return</span> intr;                                                                               \<br>    &#125;                                                                                              \<br>    <span class="hljs-comment">// 下面的不重要</span><br>    ::android::sp&lt;ITYPE&gt; ITYPE::default_impl;                                                      \<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ITYPE::setDefaultImpl</span><span class="hljs-params">(::android::sp&lt;ITYPE&gt; impl)</span> </span>&#123;                                        \<br>        <span class="hljs-built_in">assert</span>(!ITYPE::default_impl);                                                              \<br>        <span class="hljs-keyword">if</span> (impl) &#123;                                                                                \<br>            ITYPE::default_impl = std::<span class="hljs-built_in">move</span>(impl);                                                 \<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                                                                           \<br>        &#125;                                                                                          \<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                                                                              \<br>    &#125;                                                                                              \<br>    <span class="hljs-type">const</span> ::<span class="hljs-function">android::sp&lt;ITYPE&gt;&amp; <span class="hljs-title">ITYPE::getDefaultImpl</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> ITYPE::default_impl; &#125;            \<br>    ITYPE::<span class="hljs-built_in">INAME</span>() &#123;&#125;                                                                              \<br>    ITYPE::~<span class="hljs-built_in">INAME</span>() &#123;&#125;<br><br><br></code></pre></td></tr></table></figure><p>实现逻辑就是先从<code>IBinder</code>中查询<code>IInterface</code>，查不到的时候表示当前的<code>IBinder</code>不是实体<code>BBinder</code>，而是一个<code>BpBinder</code>。因此直接创建对应的Bp类型的<code>Service</code>即可。其中，<code>queryLocalInterface</code>是定义在<code>IBinder</code>中的方法，但是在<code>BnInterface</code>中也定义了一次，也就是说我们实际调用的是<code>BnInterface</code>中的方法。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/native/libs/binder/include/binder/IInterface.h</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;<br><span class="hljs-keyword">inline</span> sp&lt;IInterface&gt; BnInterface&lt;INTERFACE&gt;::<span class="hljs-built_in">queryLocalInterface</span>(<br>        <span class="hljs-type">const</span> String16&amp; _descriptor)<br>&#123;<br>    <span class="hljs-comment">// 如果参数与自己的descriptor一致，则返回本身，否则返回null</span><br>    <span class="hljs-keyword">if</span> (_descriptor == INTERFACE::descriptor) <span class="hljs-keyword">return</span> sp&lt;IInterface&gt;::<span class="hljs-built_in">fromExisting</span>(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上<code>interface_cast</code>就是判断<code>IBinder</code>的类型，然后转换成Bn类型的服务或者Bp类型的服务。</p><h3 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h3><p>看了<code>IInterface</code>的实现以及相关的类，我们实际上已经可以模仿着AIDL的实现来实现自己的一个服务<code>MyService</code>了。</p><p>第一步，定义服务的接口，需要继承自<code>IInterface</code>，同时使用宏增加一些方法和实现：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IMyService</span> : <span class="hljs-keyword">public</span> IInterface &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DECLARE_META_INTERFACE</span>(MyService)<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-built_in">IMPLEMENT_META_INTERFACE</span>(MyService, <span class="hljs-string">&quot;com.demo.IMyService&quot;</span>)<br></code></pre></td></tr></table></figure><p>第二步，实现<code>BnMyService</code>：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BnMyService</span> : <span class="hljs-keyword">public</span> BnInterface&lt;IMyService&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> TRANSACTION_demo = IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 本地实现具体的方法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;call from other process&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>   <br>   <span class="hljs-comment">// 重写onTransact方法，根据code选择调用对应的本地方法</span><br>   <span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BnServiceManager::onTransact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> flags)</span> </span>&#123;<br>       <span class="hljs-type">status_t</span> result = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">switch</span> (code) &#123;<br>          <span class="hljs-keyword">case</span> BnMyService::TRANSACTION_demo:   <br>          &#123;<br>              <span class="hljs-keyword">if</span> (!(data.<span class="hljs-built_in">checkInterface</span>(<span class="hljs-keyword">this</span>))) &#123;<br>                  result = BAD_TYPE;<br>                  <span class="hljs-keyword">break</span>;<br>              &#125;<br>              <span class="hljs-built_in">demo</span>()<br>          &#125;<br>          <span class="hljs-keyword">default</span>:<br>               result = BBinder::<span class="hljs-built_in">onTransact</span>(code, data, reply, flags);<br>       &#125;<br>       <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三步，实现<code>BpMyService</code>：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BpMyService</span> : <span class="hljs-keyword">public</span> BpInterface&lt;IMyService&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 实现方法，逻辑是将方法参数封装到Parcel，然后通过transact发送到服务进程中</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span> </span>&#123;<br>        Parcel data;<br>        data.<span class="hljs-built_in">writeInterfaceToken</span>(<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>        Parcel reply;<br>        <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(BnMyService::TRANSACTION_demo, data, &amp;reply, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Wed Apr 20 2022 14:03:09 GMT+0800");let n="Wed Apr 20 2022 14:03:09 GMT+0800";n="2024-12-25 17:39:10 +0800";var d=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-d)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Android-Framework/" class="post-footer-category">#&nbsp;Android Framework</a> <a href="/tags/Binder/" class="post-footer-tag">#&nbsp;Binder</a></div><div class="nav"><div class="nav-item-prev"><a href="/2022/05/13/android-lint-language/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">【翻译】Android Init Language</div></div></a></div><div class="nav-item-next"><a href="/2022/03/07/handler/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Handler从Java到Native</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Binder%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84" class="toc-link"><span class="toc-text">Binder的继承结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#IBinder" class="toc-link"><span class="toc-text">IBinder</span></a></li><li class="toc-item toc-level-3"><a href="#BBinder" class="toc-link"><span class="toc-text">BBinder</span></a></li><li class="toc-item toc-level-3"><a href="#BpBinder" class="toc-link"><span class="toc-text">BpBinder</span></a></li></ol></li><li class="toc-item toc-level-2"><a href="#ServiceManager" class="toc-link"><span class="toc-text">ServiceManager</span></a></li><li class="toc-item toc-level-2"><a href="#IServiceManager" class="toc-link"><span class="toc-text">IServiceManager</span></a></li><li class="toc-item toc-level-2"><a href="#IServiceManager-aidl" class="toc-link"><span class="toc-text">IServiceManager.aidl</span></a></li><li class="toc-item toc-level-2"><a href="#IInterface" class="toc-link"><span class="toc-text">IInterface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1" class="toc-link"><span class="toc-text">定义一个服务</span></a></li></ol></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-01-14</div><a href="/2023/01/14/sp-wp-refbase/"><div class="recent-posts-item-content">Android智能指针</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2021-03-12</div><a href="/2021/03/12/aidl/"><div class="recent-posts-item-content">Android进程间通信-AIDL</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-10-02</div><a href="/2022/10/02/ams/"><div class="recent-posts-item-content">App管理服务-ActivityManagerService</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-09-21</div><a href="/2022/09/21/system_server/"><div class="recent-posts-item-content">Java服务总管-system_server进程</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-08-12</div><a href="/2022/08/12/zygote/"><div class="recent-posts-item-content">Java进程祖先-zygote服务</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-07-11</div><a href="/2023/07/11/coroutine-2/"><div class="recent-posts-item-content">Kotlin协程的实现</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-06-05</div><a href="/2023/06/05/flow-2/"><div class="recent-posts-item-content">SharedFlow、StateFlow、SafeFlow的区别</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-05-22</div><a href="/2023/05/22/flow/"><div class="recent-posts-item-content">协程数据流Flow</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-04-29</div><a href="/2023/04/29/coroutine-context/"><div class="recent-posts-item-content">协程上下文CoroutineContext</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>