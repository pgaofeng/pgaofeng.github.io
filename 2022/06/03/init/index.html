<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Android Init进程</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>21</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>14</span> <span>标签</span> </a><a class="author-word-count"><span>9.73</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Init%E8%BF%9B%E7%A8%8B" class="toc-link"><span class="toc-text">Init进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#ueventd" class="toc-link"><span class="toc-text">ueventd</span></a></li><li class="toc-item toc-level-3"><a href="#first-stage" class="toc-link"><span class="toc-text">first_stage</span></a></li><li class="toc-item toc-level-3"><a href="#selinux-setup" class="toc-link"><span class="toc-text">selinux_setup</span></a></li><li class="toc-item toc-level-3"><a href="#second-stage" class="toc-link"><span class="toc-text">second_stage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B1%9E%E6%80%A7%E6%9C%8D%E5%8A%A1" class="toc-link"><span class="toc-text">初始化属性服务</span></a></li><li class="toc-item toc-level-4"><a href="#%E6%B3%A8%E5%86%8Cepoll%E7%9B%91%E5%90%AC" class="toc-link"><span class="toc-text">注册epoll监听</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#InstallSignalFdHandler" class="toc-link"><span class="toc-text">InstallSignalFdHandler</span></a></li><li class="toc-item toc-level-5"><a href="#InstallInitNotifier" class="toc-link"><span class="toc-text">InstallInitNotifier</span></a></li><li class="toc-item toc-level-5"><a href="#StartPropertyService" class="toc-link"><span class="toc-text">StartPropertyService</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#%E8%A7%A3%E6%9E%90rc%E6%96%87%E4%BB%B6" class="toc-link"><span class="toc-text">解析rc文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">3</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">5</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Android Init进程 thumbnail" class="image lozad" src="/img/cover/cover-init.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Android Init进程</h1></header><div class="post-meta post-show-meta"><time datetime="2022-06-03T13:18:26.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2022-06-03</span> </time><span class="dot"></span> <a href="/categories/Android-Framework/" class="post-meta-link">Android Framework </a><span class="dot"></span> <span>约2.6k 字</span></div><div class="post-content" id="section"><p>在<code>Android</code>系统启动时，会创建两个进程<code>init</code>和<code>kthreadd</code>。它们是后续所有进程的祖先，其中<code>init</code>进程主要负责完成系统的初始化工作，挂载文件、创建目录、配置信息等，它管理和创建用户空间层的所有进程，进程号为1。而<code>kthreadd</code>进程是对内核进程的管理，所有内核进程都是由<code>kthreadd</code>直接或间接创建的，它负责管理内核的生命周期等，进程号为2。</p><p>可以通过<code>adb shell ps -ef</code>查看进程信息。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">PS C:\Users\feng\Desktop&gt; adb shell ps -ef<br>UID        PID  PPID C STIME TTY          <span class="hljs-built_in">TIME</span> <span class="hljs-built_in">CMD</span><br>root         <span class="hljs-number">1</span>     <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">06</span>:<span class="hljs-number">36</span>:<span class="hljs-number">23</span> ?     <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">06</span> init second_stage<br>root         <span class="hljs-number">2</span>     <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">06</span>:<span class="hljs-number">36</span>:<span class="hljs-number">23</span> ?     <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> [kthreadd]<br></code></pre></td></tr></table></figure><h2 id="Init进程"><a href="#Init进程" class="headerlink" title="Init进程"></a>Init进程</h2><blockquote><p>本文基于Android13源码</p></blockquote><p><code>init</code>进程是在内核启动时，由内核中<code>kernal_init</code>方法通过<code>try_init_process</code>启动的。实际上它的代码主入口在<code>system/core/init/main.cpp</code>中。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 文件名为ueventd时，执行该逻辑</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(<span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;ueventd&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ueventd_main</span>(argc, argv);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;subcontext&quot;</span>)) &#123;<br>            android::base::<span class="hljs-built_in">InitLogging</span>(argv, &amp;android::base::KernelLogger);<br>            <span class="hljs-type">const</span> BuiltinFunctionMap&amp; function_map = <span class="hljs-built_in">GetBuiltinFunctionMap</span>();<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">SubcontextMain</span>(argc, argv, &amp;function_map);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;selinux_setup&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">SetupSelinux</span>(argv);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;second_stage&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">SecondStageMain</span>(argc, argv);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">FirstStageMain</span>(argc, argv);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ueventd"><a href="#ueventd" class="headerlink" title="ueventd"></a>ueventd</h3><p>在主入口中，分为多个逻辑，其中当<code>argv[0]</code>为<code>ueventd</code>时，即可执行文件的名字为<code>ueventd</code>时，会通过<code>ueventd_main</code>方法启动<code>ueventd</code>服务，它主要是负责挂载和创建设备节点的。由内核启动时，执行的是<code>/init</code>，因此不会走到这里，它实际上被定义在<code>rc</code>文件中启动的，<code>system/core/rootdir/init.rc</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rc">service ueventd /system/bin/ueventd<br>    class core<br>    critical<br>    seclabel u:r:ueventd:s0<br>    shutdown critical<br></code></pre></td></tr></table></figure><p><code>ueventd</code>服务是通过<code>rc</code>文件启动的，因此它实际上的执行顺序会比较靠后，因为在<code>init</code>的第二阶段才会去解析<code>rc</code>文件。可以查看它的可执行文件，只是一个软链接，实际上仍指向<code>init</code>可执行文件，因此才会有上面的逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">PS C:\Users\feng\Desktop&gt; adb shell ls -l /system/bin/ueventd<br>lrwxr-xr-x 1 root shell 4 2022-06-03 22:32 /system/bin/ueventd -&gt; init<br></code></pre></td></tr></table></figure><h3 id="first-stage"><a href="#first-stage" class="headerlink" title="first_stage"></a>first_stage</h3><p>再由内核启动<code>init</code>的时候，实际上参数都不会匹配上述的判断逻辑，因此在首次执行<code>init</code>的时候，走的是第一阶段<code>FirstStageMain</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/core/init/first_stage_init.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    ...<br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">clearenv</span>());<br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">setenv</span>(<span class="hljs-string">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/dev&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="hljs-string">&quot;mode=0755&quot;</span>));<br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mkdir</span>(<span class="hljs-string">&quot;/dev/pts&quot;</span>, <span class="hljs-number">0755</span>));<br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mkdir</span>(<span class="hljs-string">&quot;/dev/socket&quot;</span>, <span class="hljs-number">0755</span>));<br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mkdir</span>(<span class="hljs-string">&quot;/dev/dm-user&quot;</span>, <span class="hljs-number">0755</span>));<br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;devpts&quot;</span>, <span class="hljs-string">&quot;/dev/pts&quot;</span>, <span class="hljs-string">&quot;devpts&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;proc&quot;</span>, <span class="hljs-string">&quot;/proc&quot;</span>, <span class="hljs-string">&quot;proc&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;hidepid=2,gid=&quot;</span> <span class="hljs-built_in">MAKE_STR</span>(AID_READPROC)));<br>    ...<br><br>    <span class="hljs-comment">// 再次执行init程序，这次传的参数中有一个selinux_setup参数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path = <span class="hljs-string">&quot;/system/bin/init&quot;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* args[] = &#123;path, <span class="hljs-string">&quot;selinux_setup&quot;</span>, <span class="hljs-literal">nullptr</span>&#125;;<br>    ...<br>    <span class="hljs-built_in">execv</span>(path, <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>**&gt;(args));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一阶段的启动，主要是负责挂载各个目录，以及创建对应的文件可目录等，然后就是初始化内核日志等操作。当第一阶段的逻辑执行完成后，会再次执行<code>init</code>，并且传入<code>selinux_setup</code>参数，因此后续会进入到<code>SetupSelinux</code>中。</p><h3 id="selinux-setup"><a href="#selinux-setup" class="headerlink" title="selinux_setup"></a>selinux_setup</h3><p>第一阶段创建和挂载目录之后，就会进入下一阶段，该阶段就是<code>SELinux</code>的配置阶段。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">//system/core/init/selinux.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SetupSelinux</span><span class="hljs-params">(<span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-built_in">SetStdioToDevNull</span>(argv);<br>    <span class="hljs-built_in">InitKernelLogging</span>(argv);<br>    <span class="hljs-built_in">MountMissingSystemPartitions</span>();<br>    <span class="hljs-built_in">SelinuxSetupKernelLogging</span>();<br>    <span class="hljs-built_in">PrepareApexSepolicy</span>();<br>    <span class="hljs-built_in">ReadPolicy</span>(&amp;policy);<br>    <span class="hljs-built_in">CleanupApexSepolicy</span>();<br>    <span class="hljs-keyword">auto</span> snapuserd_helper = SnapuserdSelinuxHelper::<span class="hljs-built_in">CreateIfNeeded</span>();<br>    <span class="hljs-built_in">LoadSelinuxPolicy</span>(policy);<br>    <span class="hljs-built_in">SelinuxSetEnforcement</span>();<br>    <span class="hljs-built_in">setenv</span>(kEnvSelinuxStartedAt, std::<span class="hljs-built_in">to_string</span>(start_time.<span class="hljs-built_in">time_since_epoch</span>().<span class="hljs-built_in">count</span>()).<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 再次执行init，并且传递了second_stage参数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path = <span class="hljs-string">&quot;/system/bin/init&quot;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* args[] = &#123;path, <span class="hljs-string">&quot;second_stage&quot;</span>, <span class="hljs-literal">nullptr</span>&#125;;<br>    <span class="hljs-built_in">execv</span>(path, <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>**&gt;(args));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里我们也不用过多深究，它主要就是负责加载<code>SELinux</code>的策划信息等，当所有逻辑执行结束后，会再次执行<code>init</code>来进入到下一阶段<code>SecondStageMain</code>。</p><h3 id="second-stage"><a href="#second-stage" class="headerlink" title="second_stage"></a>second_stage</h3><p>第二阶段可以说是<code>init</code>进程的最后一个阶段了，它会解析<code>rc</code>文件并创建对应的服务进程，并且会一直存在于系统中。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SecondStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 设置oom_score_adj，该属性用于控制当内存不足时被杀死的优先级</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> result =<br>                <span class="hljs-built_in">WriteFile</span>(<span class="hljs-string">&quot;/proc/1/oom_score_adj&quot;</span>, <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;%d&quot;</span>, DEFAULT_OOM_SCORE_ADJUST));<br>        !result.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unable to write &quot;</span> &lt;&lt; DEFAULT_OOM_SCORE_ADJUST<br>                   &lt;&lt; <span class="hljs-string">&quot; to /proc/1/oom_score_adj: &quot;</span> &lt;&lt; result.<span class="hljs-built_in">error</span>();<br>    &#125;<br>    <span class="hljs-comment">// 初始化属性服务</span><br>    <span class="hljs-built_in">PropertyInit</span>();<br><br>    <span class="hljs-comment">// 注册epoll监听</span><br>    Epoll epoll;<br>    <span class="hljs-built_in">InstallSignalFdHandler</span>(&amp;epoll);<br>    <span class="hljs-built_in">InstallInitNotifier</span>(&amp;epoll);<br>    <span class="hljs-built_in">StartPropertyService</span>(&amp;property_fd);<br><br>    <span class="hljs-comment">// 创建AM和SM解析器，然后加载并解析rc文件</span><br>    ActionManager&amp; am = ActionManager::<span class="hljs-built_in">GetInstance</span>();<br>    ServiceList&amp; sm = ServiceList::<span class="hljs-built_in">GetInstance</span>();<br>    <span class="hljs-built_in">LoadBootScripts</span>(am, sm);<br>    <span class="hljs-comment">// 发送对应的触发器，以根据rc文件的配置来启动对应的服务</span><br>    am.<span class="hljs-built_in">QueueEventTrigger</span>(<span class="hljs-string">&quot;early-init&quot;</span>);<br>    am.<span class="hljs-built_in">QueueEventTrigger</span>(<span class="hljs-string">&quot;init&quot;</span>);<br>    std::string bootmode = <span class="hljs-built_in">GetProperty</span>(<span class="hljs-string">&quot;ro.bootmode&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bootmode == <span class="hljs-string">&quot;charger&quot;</span>) &#123;<br>        am.<span class="hljs-built_in">QueueEventTrigger</span>(<span class="hljs-string">&quot;charger&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        am.<span class="hljs-built_in">QueueEventTrigger</span>(<span class="hljs-string">&quot;late-init&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 进入epoll阻塞</span><br>        <span class="hljs-keyword">auto</span> pending_functions = epoll.<span class="hljs-built_in">Wait</span>(epoll_timeout);<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们重点关注第二阶段的初始化，因为这一阶段才算的上是Android的启动。</p><h4 id="初始化属性服务"><a href="#初始化属性服务" class="headerlink" title="初始化属性服务"></a>初始化属性服务</h4><p>在第二阶段会初始化属性服务，也就是系统属性。它可以包含系统属性也可以用于应用设置属性，有点类似于系统环境变量，很多配置都是通过属性服务来设置的。在第二阶段的初始化中，会通过<code>PropertyInit</code>方法进入初始化。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/core/init/property_service.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PropertyInit</span><span class="hljs-params">()</span> </span>&#123;<br>    selinux_callback cb;<br>    cb.func_audit = PropertyAuditCallback;<br>    <span class="hljs-built_in">selinux_set_callback</span>(SELINUX_CB_AUDIT, cb);<br><br>    <span class="hljs-comment">// 创建属性服务的目录，对应是属性文件会在该目录下</span><br>    <span class="hljs-built_in">mkdir</span>(<span class="hljs-string">&quot;/dev/__properties__&quot;</span>, S_IRWXU | S_IXGRP | S_IXOTH);<br>    <span class="hljs-built_in">CreateSerializedPropertyInfo</span>();<br>    <span class="hljs-keyword">if</span> (__system_property_area_init()) &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Failed to initialize property area&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 加载默认的配置/dev/__properties__/property_info</span><br>    <span class="hljs-keyword">if</span> (!property_info_area.<span class="hljs-built_in">LoadDefaultPath</span>()) &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Failed to load serialized property info file&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取/proc/bootconfig中的androidboot.android_dt_dir或androidboot.android_dt_dir</span><br>    <span class="hljs-built_in">ProcessKernelDt</span>();<br>    <span class="hljs-comment">// 读取/proc/cmdline</span><br>    <span class="hljs-built_in">ProcessKernelCmdline</span>();<br>    <span class="hljs-comment">// 读取/proc/bootconfig</span><br>    <span class="hljs-built_in">ProcessBootconfig</span>();<br><br>    <span class="hljs-comment">// 处理内核boot相关的属性，ro.boot开头的属性</span><br>    <span class="hljs-built_in">ExportKernelBootProps</span>();<br>    <span class="hljs-comment">// 加载各个路径下的build.proc和default.proc文件</span><br>    <span class="hljs-built_in">PropertyLoadBootDefaults</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注册epoll监听"><a href="#注册epoll监听" class="headerlink" title="注册epoll监听"></a>注册epoll监听</h4><p><code>epoll</code>机制是<code>Linux</code>中用来监听文件变化的一个机制，他可以在文件不可读时阻塞并释放<code>cpu</code>，然后在文件可读时唤醒，具体可以查看<a href="https://pgaofeng.github.io/2022/02/23/eventfd-epoll/" rel="noopener" target="_blank">Handler唤起的基础–eventfd和epoll</a>。</p><h5 id="InstallSignalFdHandler"><a href="#InstallSignalFdHandler" class="headerlink" title="InstallSignalFdHandler"></a>InstallSignalFdHandler</h5><p>该方法主要就是注册信号量的<code>epoll</code>，因为<code>init</code>是所有用户进程的祖先进程，因此需要注册信号量来接收子孙进程发送的信号，来处理相关的回收等逻辑。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/core/init/init.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">InstallSignalFdHandler</span><span class="hljs-params">(Epoll* epoll)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 创建一个信号量文件描述符</span><br>    signal_fd = <span class="hljs-built_in">signalfd</span>(<span class="hljs-number">-1</span>, &amp;mask, SFD_CLOEXEC | SFD_NONBLOCK);<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> flags = EPOLLIN | EPOLLPRI;<br>    <span class="hljs-keyword">auto</span> handler = std::<span class="hljs-built_in">bind</span>(HandleSignalFd, <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 向epoll中注册该信号量，当收到信号量时，会唤醒epoll，然后交给handler中的HandleSignalFd方法处理</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> result = epoll-&gt;<span class="hljs-built_in">RegisterHandler</span>(signal_fd, handler, flags); !result.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; result.<span class="hljs-built_in">error</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="InstallInitNotifier"><a href="#InstallInitNotifier" class="headerlink" title="InstallInitNotifier"></a>InstallInitNotifier</h5><p>该方法注册了一个<code>eventfd</code>，该文件描述符用于唤醒<code>init</code>进程，因为在系统启动后，<code>init</code>进程是一直常驻的，但肯定不会是一直活跃的，因此会通过<code>epoll</code>机制进行阻塞，如果想要唤醒<code>init</code>进程，只需要通过<code>wake_main_thread_fd</code>描述符写入内容即可唤醒。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-type">static</span> <span class="hljs-type">int</span> wake_main_thread_fd = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">InstallInitNotifier</span><span class="hljs-params">(Epoll* epoll)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个eventfd</span><br>    wake_main_thread_fd = <span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, EFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (wake_main_thread_fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Failed to create eventfd for waking init&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> clear_eventfd = [] &#123;<br>        <span class="hljs-type">uint64_t</span> counter;<br>        <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">read</span>(wake_main_thread_fd, &amp;counter, <span class="hljs-built_in">sizeof</span>(counter)));<br>    &#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> result = epoll-&gt;<span class="hljs-built_in">RegisterHandler</span>(wake_main_thread_fd, clear_eventfd); !result.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; result.<span class="hljs-built_in">error</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="StartPropertyService"><a href="#StartPropertyService" class="headerlink" title="StartPropertyService"></a>StartPropertyService</h5><p>为系统属性创建一个<code>socket</code>，当设置系统属性时，实际上就是通过该<code>socket</code>来处理并写入到对应的文件中。这样做是因为有些系统功能是需要一直监听系统属性的，当系统属性变化时会做出响应，通过<code>ctl.</code>开头的属性是会被直接响应的，如：<code>SetProperty(&quot;ctl.start&quot;, &quot;logd&quot;)</code>实际上会直接通过<code>start</code>命令启动<code>logd</code>服务。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/core/init/property_service.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartPropertyService</span><span class="hljs-params">(<span class="hljs-type">int</span>*                                                                                           )</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个socket</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">CreateSocket</span>(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,<br>                                   <span class="hljs-comment">/*passcred=*/</span><span class="hljs-literal">false</span>, <span class="hljs-comment">/*should_listen=*/</span><span class="hljs-literal">false</span>, <span class="hljs-number">0666</span>, <span class="hljs-comment">/*uid=*/</span><span class="hljs-number">0</span>,<br>                                   <span class="hljs-comment">/*gid=*/</span><span class="hljs-number">0</span>, <span class="hljs-comment">/*socketcon=*/</span>&#123;&#125;);<br>        result.<span class="hljs-built_in">ok</span>()) &#123;<br>        property_set_fd = *result;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;start_property_service socket creation failed: &quot;</span> &lt;&lt; result.<span class="hljs-built_in">error</span>();<br>    &#125;<br>    <span class="hljs-comment">// 监听该socket</span><br>    <span class="hljs-built_in">listen</span>(property_set_fd, <span class="hljs-number">8</span>);<br>    <span class="hljs-comment">// 启动一个新的线程，该线程会执行PropertyServiceThread方法</span><br>    <span class="hljs-keyword">auto</span> new_thread = std::thread&#123;PropertyServiceThread&#125;;<br>    property_service_thread.<span class="hljs-built_in">swap</span>(new_thread);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">PropertyServiceThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 为该线程创建一个新的epoll</span><br>    Epoll epoll;<br>    <span class="hljs-comment">// 然后将socketfd注册到epoll中，当唤醒时，会通过handle_property_set_fd方法去处理相关逻辑</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> result = epoll.<span class="hljs-built_in">RegisterHandler</span>(property_set_fd, handle_property_set_fd);<br>        !result.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; result.<span class="hljs-built_in">error</span>();<br>    &#125;<br>    <span class="hljs-comment">// 还注册了一个init_socket，该fd唤醒对应的是HandleInitSocket方法</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> result = epoll.<span class="hljs-built_in">RegisterHandler</span>(init_socket, HandleInitSocket); !result.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; result.<span class="hljs-built_in">error</span>();<br>    &#125;<br>    <span class="hljs-comment">// 通过epoll.wait进入阻塞等待被唤醒</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">auto</span> pending_functions = epoll.<span class="hljs-built_in">Wait</span>(std::<span class="hljs-literal">nullopt</span>);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解析rc文件"><a href="#解析rc文件" class="headerlink" title="解析rc文件"></a>解析rc文件</h4><p>这部分是解析<code>rc</code>文件的，基本上所有的系统服务都是通过<code>rc</code>文件来定义的，然后在系统启动时会由<code>init</code>进程解析并启动。它主要的逻辑就是加载<code>rc</code>文件，然后通过触发器来决定是否启动对应的服务等。具体的<code>rc</code>文件规则，可以查看<a href="https://pgaofeng.github.io/2022/05/13/android-lint-language/" rel="noopener" target="_blank">Android Init Language</a>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/core/init/init.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">LoadBootScripts</span><span class="hljs-params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;<br>    Parser parser = <span class="hljs-built_in">CreateParser</span>(action_manager, service_list);<br>    <span class="hljs-comment">// 如果系统属性中没有ro.boot.init_rc的话，就会从下面的路径加载对应的rc文件</span><br>    std::string bootscript = <span class="hljs-built_in">GetProperty</span>(<span class="hljs-string">&quot;ro.boot.init_rc&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bootscript.<span class="hljs-built_in">empty</span>()) &#123;<br>        parser.<span class="hljs-built_in">ParseConfig</span>(<span class="hljs-string">&quot;/system/etc/init/hw/init.rc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!parser.<span class="hljs-built_in">ParseConfig</span>(<span class="hljs-string">&quot;/system/etc/init&quot;</span>)) &#123;<br>            late_import_paths.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;/system/etc/init&quot;</span>);<br>        &#125;<br>        parser.<span class="hljs-built_in">ParseConfig</span>(<span class="hljs-string">&quot;/system_ext/etc/init&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!parser.<span class="hljs-built_in">ParseConfig</span>(<span class="hljs-string">&quot;/vendor/etc/init&quot;</span>)) &#123;<br>            late_import_paths.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;/vendor/etc/init&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!parser.<span class="hljs-built_in">ParseConfig</span>(<span class="hljs-string">&quot;/odm/etc/init&quot;</span>)) &#123;<br>            late_import_paths.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;/odm/etc/init&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!parser.<span class="hljs-built_in">ParseConfig</span>(<span class="hljs-string">&quot;/product/etc/init&quot;</span>)) &#123;<br>            late_import_paths.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;/product/etc/init&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        parser.<span class="hljs-built_in">ParseConfig</span>(bootscript);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建对应的解析器</span><br><span class="hljs-function">Parser <span class="hljs-title">CreateParser</span><span class="hljs-params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;<br>    Parser parser;<br><br>    parser.<span class="hljs-built_in">AddSectionParser</span>(<span class="hljs-string">&quot;service&quot;</span>, std::<span class="hljs-built_in">make_unique</span>&lt;ServiceParser&gt;(<br>                                               &amp;service_list, <span class="hljs-built_in">GetSubcontext</span>(), std::<span class="hljs-literal">nullopt</span>));<br>    parser.<span class="hljs-built_in">AddSectionParser</span>(<span class="hljs-string">&quot;on&quot;</span>, std::<span class="hljs-built_in">make_unique</span>&lt;ActionParser&gt;(&amp;action_manager, <span class="hljs-built_in">GetSubcontext</span>()));<br>    parser.<span class="hljs-built_in">AddSectionParser</span>(<span class="hljs-string">&quot;import&quot;</span>, std::<span class="hljs-built_in">make_unique</span>&lt;ImportParser&gt;(&amp;parser));<br><br>    <span class="hljs-keyword">return</span> parser;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里<code>init</code>进程就分析完了，过程比较简陋，只关注了主要的逻辑。首先<code>init</code>进程分为三个阶段：第一阶段，<code>SELinux</code>阶段，第二阶段。其中第一阶段挂载和创建对应的目录，<code>SELinux</code>阶段用于初始化<code>SELinux</code>，第二阶段初始化系统属性已经加载<code>rc</code>文件并启动对应的系统服务。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Fri Jun 03 2022 21:18:26 GMT+0800");let n="Fri Jun 03 2022 21:18:26 GMT+0800";n="2024-12-11 14:42:55 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Android-Framework/" class="post-footer-category">#&nbsp;Android Framework</a> <a href="/tags/AOSP/" class="post-footer-tag">#&nbsp;AOSP</a></div><div class="nav"><div class="nav-item-prev"><a href="/2022/07/25/logd/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">Android logd日志服务</div></div></a></div><div class="nav-item-next"><a href="/2022/05/13/android-lint-language/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">【翻译】Android Init Language</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Init%E8%BF%9B%E7%A8%8B" class="toc-link"><span class="toc-text">Init进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#ueventd" class="toc-link"><span class="toc-text">ueventd</span></a></li><li class="toc-item toc-level-3"><a href="#first-stage" class="toc-link"><span class="toc-text">first_stage</span></a></li><li class="toc-item toc-level-3"><a href="#selinux-setup" class="toc-link"><span class="toc-text">selinux_setup</span></a></li><li class="toc-item toc-level-3"><a href="#second-stage" class="toc-link"><span class="toc-text">second_stage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B1%9E%E6%80%A7%E6%9C%8D%E5%8A%A1" class="toc-link"><span class="toc-text">初始化属性服务</span></a></li><li class="toc-item toc-level-4"><a href="#%E6%B3%A8%E5%86%8Cepoll%E7%9B%91%E5%90%AC" class="toc-link"><span class="toc-text">注册epoll监听</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#InstallSignalFdHandler" class="toc-link"><span class="toc-text">InstallSignalFdHandler</span></a></li><li class="toc-item toc-level-5"><a href="#InstallInitNotifier" class="toc-link"><span class="toc-text">InstallInitNotifier</span></a></li><li class="toc-item toc-level-5"><a href="#StartPropertyService" class="toc-link"><span class="toc-text">StartPropertyService</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#%E8%A7%A3%E6%9E%90rc%E6%96%87%E4%BB%B6" class="toc-link"><span class="toc-text">解析rc文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2022-09-21</div><a href="/2022/09/21/system_server/"><div class="recent-posts-item-content">Java服务总管-system_server进程</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-08-12</div><a href="/2022/08/12/zygote/"><div class="recent-posts-item-content">Java进程祖先-zygote服务</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-07-25</div><a href="/2022/07/25/logd/"><div class="recent-posts-item-content">Android logd日志服务</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-05-13</div><a href="/2022/05/13/android-lint-language/"><div class="recent-posts-item-content">【翻译】Android Init Language</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-01-11</div><a href="/2022/01/11/build-aosp-ubuntu/"><div class="recent-posts-item-content">在Ubuntu上下载AOSP并编译Android13</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-06-05</div><a href="/2023/06/05/flow-2/"><div class="recent-posts-item-content">SharedFlow、StateFlow、SafeFlow的区别</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-05-22</div><a href="/2023/05/22/flow/"><div class="recent-posts-item-content">协程数据流Flow</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-01-14</div><a href="/2023/01/14/sp-wp-refbase/"><div class="recent-posts-item-content">Android智能指针</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-09-21</div><a href="/2022/09/21/system_server/"><div class="recent-posts-item-content">Java服务总管-system_server进程</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>