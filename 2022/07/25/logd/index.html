<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Android logd日志服务</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 8.1.1" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>44</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>6</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>19</span> <span>标签</span> </a><a class="author-word-count"><span>18.05</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Logd" class="toc-link"><span class="toc-text">Logd</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E6%97%A5%E5%BF%97%E5%88%9D%E5%A7%8B%E5%8C%96" class="toc-link"><span class="toc-text">日志初始化</span></a></li><li class="toc-item toc-level-3"><a href="#%E5%88%9B%E5%BB%BA%E6%97%A5%E5%BF%97buffer" class="toc-link"><span class="toc-text">创建日志buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#SimpleLogBuffer" class="toc-link"><span class="toc-text">SimpleLogBuffer</span></a></li><li class="toc-item toc-level-4"><a href="#SerializedLogBuffer" class="toc-link"><span class="toc-text">SerializedLogBuffer</span></a></li><li class="toc-item toc-level-4"><a href="#ChattyLogBuffer" class="toc-link"><span class="toc-text">ChattyLogBuffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E5%90%AF%E7%94%A8socket" class="toc-link"><span class="toc-text">启用socket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#logdr" class="toc-link"><span class="toc-text">logdr</span></a></li><li class="toc-item toc-level-4"><a href="#logdw" class="toc-link"><span class="toc-text">logdw</span></a></li><li class="toc-item toc-level-4"><a href="#logd" class="toc-link"><span class="toc-text">logd</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E4%BD%BF%E7%94%A8" class="toc-link"><span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">11</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Flutter/"><div class="categories-list-item">Flutter <span class="categories-list-item-badge">9</span></div></a><a href="/categories/Java/"><div class="categories-list-item">Java <span class="categories-list-item-badge">2</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Android logd日志服务 thumbnail" class="lozad image" src="/img/cover/cover-logd.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Android logd日志服务</h1></header><div class="post-meta post-show-meta"><time datetime="2022-07-25T06:00:26.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2022-07-25</span> </time><span class="dot"></span> <a href="/categories/Android-Framework/" class="post-meta-link">Android Framework </a><span class="dot"></span> <span>约7.5k 字</span></div><div class="post-content" id="section"><p><code>Android</code>日志服务是我们接触非常多的一个服务，主要用于调试以及分析<code>bug</code>使用，可以记录程序执行的步骤，方便我们对代码进行追踪。它也是通过<code>rc</code>文件描述的，由<code>init</code>进程解析并启动的，我们知道<code>init</code>的<code>second_stage</code>阶段解析<code>rc</code>文件，其中会按顺序触发三个触发器以触发各个服务的启动，分别是<code>early_init</code>、<code>init</code>、<code>late_init</code>，日志服务在<code>init</code>触发器中启动的服务，它是比<code>ServiceManager</code>早启动的，因此是无法使用<code>binder</code>的。</p><blockquote><p>本文基于Android13源码</p></blockquote><h2 id="Logd"><a href="#Logd" class="headerlink" title="Logd"></a>Logd</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># system/logging/logd/logd.rc<br><br>service logd /system/bin/logd<br>    socket logd stream 0666 logd logd<br>    socket logdr seqpacket 0666 logd logd<br>    socket logdw dgram+passcred 0222 logd logd<br>    file /proc/kmsg r<br>    file /dev/kmsg w<br>    user logd<br>    group logd system package_info readproc<br>    capabilities SYSLOG AUDIT_CONTROL<br>    priority 10<br>    task_profiles ServiceCapacityLow<br>    onrestart setprop logd.ready false<br></code></pre></td></tr></table></figure><p><code>rc</code>文件中就是基本的启动，首先启动了<code>logd</code>服务，然后创建了三个<code>socket</code>。因此可以直接回到main方法中去进行查看。这些都是由<code>init</code>进程进行解析并执行的，最终通过执行可执行文件<code>/system/bin/logd</code>来启动的<code>logd</code>服务.</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/main.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 初始化Log</span><br>    android::base::<span class="hljs-built_in">InitLogging</span>(<br>            argv, [](android::base::LogId log_id, android::base::LogSeverity severity,<br>                     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* tag, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> line, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* message) &#123;<br>                <span class="hljs-keyword">if</span> (tag &amp;&amp; <span class="hljs-built_in">strcmp</span>(tag, <span class="hljs-string">&quot;logd&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">auto</span> prefixed_message = android::base::<span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;%s: %s&quot;</span>, tag, message);<br>                    android::base::<span class="hljs-built_in">KernelLogger</span>(log_id, severity, <span class="hljs-string">&quot;logd&quot;</span>, file, line,<br>                                                prefixed_message.<span class="hljs-built_in">c_str</span>());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    android::base::<span class="hljs-built_in">KernelLogger</span>(log_id, severity, <span class="hljs-string">&quot;logd&quot;</span>, file, line, message);<br>                &#125;<br>            &#125;);<br><br>    ...<br><br>    LogTags log_tags;<br>    PruneList prune_list;<br><br>    <span class="hljs-comment">// 获取系统属性中日志的类型，默认是serialized</span><br>    std::string buffer_type = <span class="hljs-built_in">GetProperty</span>(<span class="hljs-string">&quot;logd.buffer_type&quot;</span>, <span class="hljs-string">&quot;serialized&quot;</span>);<br><br>    <span class="hljs-comment">// Partial (required for chatty) or full logging statistics.</span><br>    <span class="hljs-function">LogStatistics <span class="hljs-title">log_statistics</span><span class="hljs-params">(GetBoolPropertyEngSvelteDefault(<span class="hljs-string">&quot;logd.statistics&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">                                 buffer_type == <span class="hljs-string">&quot;serialized&quot;</span>)</span></span>;<br> <br>    LogReaderList reader_list;<br><br>    <span class="hljs-comment">// 根据类型获取不同的日志buffer</span><br>    LogBuffer* log_buffer = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (buffer_type == <span class="hljs-string">&quot;chatty&quot;</span>) &#123;<br>        log_buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ChattyLogBuffer</span>(&amp;reader_list, &amp;log_tags, &amp;prune_list, &amp;log_statistics);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer_type == <span class="hljs-string">&quot;serialized&quot;</span>) &#123;<br>        log_buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SerializedLogBuffer</span>(&amp;reader_list, &amp;log_tags, &amp;log_statistics);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer_type == <span class="hljs-string">&quot;simple&quot;</span>) &#123;<br>        log_buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SimpleLogBuffer</span>(&amp;reader_list, &amp;log_tags, &amp;log_statistics);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;buffer_type must be one of &#x27;chatty&#x27;, &#x27;serialized&#x27;, or &#x27;simple&#x27;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 监听日志的读取</span><br>    LogReader* reader = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LogReader</span>(log_buffer, &amp;reader_list);<br>    <span class="hljs-keyword">if</span> (reader-&gt;<span class="hljs-built_in">startListener</span>()) &#123;<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">// 监听日志的写入</span><br>    LogListener* swl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LogListener</span>(log_buffer);<br>    <span class="hljs-keyword">if</span> (!swl-&gt;<span class="hljs-built_in">StartListener</span>()) &#123;<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">// 监听logcat的命令行</span><br>    CommandListener* cl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CommandListener</span>(log_buffer, &amp;log_tags, &amp;prune_list, &amp;log_statistics);<br>    <span class="hljs-keyword">if</span> (cl-&gt;<span class="hljs-built_in">startListener</span>()) &#123;<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">// 在rc文件中该属性被设置为false，当启动完成后会置为true，表示日志服务的可用</span><br>    <span class="hljs-built_in">SetProperty</span>(<span class="hljs-string">&quot;logd.ready&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br><br>    <span class="hljs-comment">// LogAudit listens on NETLINK_AUDIT socket for selinux</span><br>    <span class="hljs-comment">// initiated log messages. New log entries are added to LogBuffer</span><br>    <span class="hljs-comment">// and LogReader is notified to send updates to connected clients.</span><br>    LogAudit* al = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (auditd) &#123;<br>        <span class="hljs-type">int</span> dmesg_fd = <span class="hljs-built_in">GetBoolProperty</span>(<span class="hljs-string">&quot;ro.logd.auditd.dmesg&quot;</span>, <span class="hljs-literal">true</span>) ? fdDmesg : <span class="hljs-number">-1</span>;<br>        al = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LogAudit</span>(log_buffer, dmesg_fd, &amp;log_statistics);<br>    &#125;<br><br>    LogKlog* kl = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (klogd) &#123;<br>        kl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LogKlog</span>(log_buffer, fdDmesg, fdPmesg, al != <span class="hljs-literal">nullptr</span>, &amp;log_statistics);<br>    &#125;<br><br>    <span class="hljs-built_in">readDmesg</span>(al, kl);<br><br>    <span class="hljs-comment">// failure is an option ... messages are in dmesg (required by standard)</span><br>    <span class="hljs-keyword">if</span> (kl &amp;&amp; kl-&gt;<span class="hljs-built_in">startListener</span>()) &#123;<br>        <span class="hljs-keyword">delete</span> kl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (al &amp;&amp; al-&gt;<span class="hljs-built_in">startListener</span>()) &#123;<br>        <span class="hljs-keyword">delete</span> al;<br>    &#125;<br><br>    TrustyLog::<span class="hljs-built_in">create</span>(log_buffer);<br><br>    <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">pause</span>());<br><br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里一共做了三件事，分别是初始化日志写入、创建日志<code>buffer</code>、启动日志<code>socket</code>监听。这里分别查看。</p><h3 id="日志初始化"><a href="#日志初始化" class="headerlink" title="日志初始化"></a>日志初始化</h3><p>日志初始化，这里的初始化实际上设置了如何写入日志的过程，当使用方去设置输出日志时，实际上就是通过这里初始化时设置的方法来输出日志的。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/libbase/include/android-base/logging.h</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitLogging</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv[],</span></span><br><span class="hljs-params"><span class="hljs-function">                 LogFunction&amp;&amp; logger = INIT_LOGGING_DEFAULT_LOGGER,</span></span><br><span class="hljs-params"><span class="hljs-function">                 AbortFunction&amp;&amp; aborter = DefaultAborter)</span></span>;<br></code></pre></td></tr></table></figure><p>其接收三个参数，后两个参数都有默认值，可以不需要传入，在logd的初始化中，实际上最主要的就是传入第二个参数<code>logger</code>，该方法的具体实现是在另一个文件中：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitLogging</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv[], LogFunction&amp;&amp; logger, AbortFunction&amp;&amp; aborter)</span> </span>&#123;<br>  <span class="hljs-built_in">SetLogger</span>(std::forward&lt;LogFunction&gt;(logger));<br>  <span class="hljs-built_in">SetAborter</span>(std::forward&lt;AbortFunction&gt;(aborter));<br><br>  <span class="hljs-keyword">if</span> (gInitialized) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 标记已初始化过了</span><br>  gInitialized = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 设置默认的tag，这里实际上是/system/bin/logd</span><br>  <span class="hljs-keyword">if</span> (argv != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">SetDefaultTag</span>(<span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* tags = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;ANDROID_LOG_TAGS&quot;</span>);<br>  <span class="hljs-keyword">if</span> (tags == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  std::vector&lt;std::string&gt; specs = <span class="hljs-built_in">Split</span>(tags, <span class="hljs-string">&quot; &quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; specs.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-comment">// &quot;tag-pattern:[vdiwefs]&quot;</span><br>    <span class="hljs-function">std::string <span class="hljs-title">spec</span><span class="hljs-params">(specs[i])</span></span>;<br>    <span class="hljs-keyword">if</span> (spec.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">StartsWith</span>(spec, <span class="hljs-string">&quot;*:&quot;</span>)) &#123;<br>      <span class="hljs-keyword">switch</span> (spec[<span class="hljs-number">2</span>]) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>          <span class="hljs-built_in">SetMinimumLogSeverity</span>(VERBOSE);<br>          <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>          <span class="hljs-built_in">SetMinimumLogSeverity</span>(DEBUG);<br>          <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;i&#x27;</span>:<br>          <span class="hljs-built_in">SetMinimumLogSeverity</span>(INFO);<br>          <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>:<br>          <span class="hljs-built_in">SetMinimumLogSeverity</span>(WARNING);<br>          <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br>          <span class="hljs-built_in">SetMinimumLogSeverity</span>(ERROR);<br>          <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br>          <span class="hljs-built_in">SetMinimumLogSeverity</span>(FATAL_WITHOUT_ABORT);<br>          <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// liblog will even suppress FATAL if you say &#x27;s&#x27; for silent, but fatal should</span><br>        <span class="hljs-comment">// never be suppressed.</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>          <span class="hljs-built_in">SetMinimumLogSeverity</span>(FATAL_WITHOUT_ABORT);<br>          <span class="hljs-keyword">continue</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;unsupported &#x27;&quot;</span> &lt;&lt; spec &lt;&lt; <span class="hljs-string">&quot;&#x27; in ANDROID_LOG_TAGS (&quot;</span> &lt;&lt; tags<br>               &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里最主要的就是<code>setLogger</code>设置成新的<code>logger</code>，然后就是一些初始化过程，这与<code>logd</code>的设计实现是暂时无关的，可以先就到这里。然后看后面的创建日志<code>buffer</code>。</p><h3 id="创建日志buffer"><a href="#创建日志buffer" class="headerlink" title="创建日志buffer"></a>创建日志buffer</h3><p>日志<code>buffer</code>决定了日志在内存中是如何存储记录的，它分为三种<code>buffer</code>，根据系统属性<code>logd.buffer_type</code>来决定使用哪种，默认情况下使用<code>serialized</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/LogBuffer.h</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogBuffer</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">LogBuffer</span>() &#123;&#125;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 写入log</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Log</span><span class="hljs-params">(<span class="hljs-type">log_id_t</span> log_id, log_time realtime, <span class="hljs-type">uid_t</span> uid, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> tid,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">uint16_t</span> len)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::unique_ptr&lt;FlushToState&gt; <span class="hljs-title">CreateFlushToState</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> start, LogMask log_mask)</span></span><br><span class="hljs-function">            <span class="hljs-title">REQUIRES</span><span class="hljs-params">(logd_lock)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">FlushTo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            LogWriter* writer, FlushToState&amp; state,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">const</span> std::function&lt;FilterResult(<span class="hljs-type">log_id_t</span> log_id, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">uint64_t</span> sequence,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             log_time realtime)&gt;&amp; filter)</span> <span class="hljs-title">REQUIRES</span><span class="hljs-params">(logd_lock)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">Clear</span><span class="hljs-params">(<span class="hljs-type">log_id_t</span> id, <span class="hljs-type">uid_t</span> uid)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">size_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">(<span class="hljs-type">log_id_t</span> id)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">SetSize</span><span class="hljs-params">(<span class="hljs-type">log_id_t</span> id, <span class="hljs-type">size_t</span> size)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">uint64_t</span> <span class="hljs-title">sequence</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>LogBuffer</code>定义了log的一些基本方法，不同的buffer都需要继承自LogBuffer并实现对应的方法。我们从上面的方法中可以看到，基本上每个方法都会有一个<code>log_id_t</code>参数，这是日志的分类参数，<code>Android</code>将日志按照分类拆分成多种日志，其关键字<code>log_id_t</code>。该值是一个枚举值：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/liblog/include/android/log.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">log_id</span> &#123;<br>  LOG_ID_MIN = <span class="hljs-number">0</span>,<br><br>  LOG_ID_MAIN = <span class="hljs-number">0</span>,<br>  LOG_ID_RADIO = <span class="hljs-number">1</span>,<br>  LOG_ID_EVENTS = <span class="hljs-number">2</span>,<br>  LOG_ID_SYSTEM = <span class="hljs-number">3</span>,<br>  LOG_ID_CRASH = <span class="hljs-number">4</span>,<br>  LOG_ID_STATS = <span class="hljs-number">5</span>,<br>  LOG_ID_SECURITY = <span class="hljs-number">6</span>,<br>  LOG_ID_KERNEL = <span class="hljs-number">7</span>,<br><br>  LOG_ID_MAX,<br>  LOG_ID_DEFAULT = <span class="hljs-number">0x7FFFFFFF</span><br>&#125; <span class="hljs-type">log_id_t</span>;<br></code></pre></td></tr></table></figure><p>其中就有我们很熟悉的<code>main</code>、<code>event</code>、<code>crash</code>等，其中我们应用中通过<code>Log.d</code>、<code>ALOGD</code>等打印的日志都是属于<code>main</code>分类的，也是最常见的日志。<code>LogBuffer</code>就是通过这些分类来将日志进行分类存储的。</p><h4 id="SimpleLogBuffer"><a href="#SimpleLogBuffer" class="headerlink" title="SimpleLogBuffer"></a>SimpleLogBuffer</h4><p><code>SimpleLogBuffer</code>是最基础的<code>LogBuffer</code>，几乎不会使用。其对应的文件：<code>system/logging/logd/SimpleLogBuffer.cpp</code>和<code>system/logging/logd/SimpleLogBuffer.h</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/SimpleLogBuffer.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SimpleLogBuffer::Log</span><span class="hljs-params">(<span class="hljs-type">log_id_t</span> log_id, log_time realtime, <span class="hljs-type">uid_t</span> uid, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> tid,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">uint16_t</span> len)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// log的顺序+1</span><br>    <span class="hljs-keyword">auto</span> sequence = sequence_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>    <span class="hljs-comment">// 将log包装成LogBufferElement添加进入</span><br>    <span class="hljs-built_in">LogInternal</span>(<span class="hljs-built_in">LogBufferElement</span>(log_id, realtime, uid, pid, tid, sequence, msg, len));<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SimpleLogBuffer::LogInternal</span><span class="hljs-params">(LogBufferElement&amp;&amp; elem)</span> </span>&#123;<br>    <span class="hljs-type">log_id_t</span> log_id = elem.<span class="hljs-built_in">log_id</span>();<br>    <span class="hljs-comment">// 添加到logs_集合中</span><br>    logs_.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(elem));<br>    stats_-&gt;<span class="hljs-built_in">Add</span>(logs_.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">ToLogStatisticsElement</span>());<br>    <span class="hljs-comment">// 查看当前的log_id存储是否满了，满了的话需要删除旧的日志</span><br>    <span class="hljs-built_in">MaybePrune</span>(log_id);<br>    <span class="hljs-comment">// 通知有新log插入</span><br>    reader_list_-&gt;<span class="hljs-built_in">NotifyNewLog</span>(<span class="hljs-number">1</span> &lt;&lt; log_id);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SimpleLogBuffer</code>的结构比较简单，就是使用了一个简单的<code>list</code>集合，每次有新<code>log</code>时，都是将其包装成一个<code>LogBufferElement</code>然后插入到集合中，并检查对应的<code>log_id</code>的日志是否需要删除。</p><p><img alt="SimpleLogBuffer" class="lozad post-image" src="/img/logd-simple.webp" data-src="/img/logd-simple.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><h4 id="SerializedLogBuffer"><a href="#SerializedLogBuffer" class="headerlink" title="SerializedLogBuffer"></a>SerializedLogBuffer</h4><p><code>SerializedLogBuffer</code>是最常用的日志缓存，默认就是使用它来存储系统日志。它与<code>SimpleLogBuffer</code>的区别就是它是可压缩的缓存，前面简单的缓存就是将每条日志都包装成<code>LogBufferElement</code>保存下来，原打印的内容有多大，就会在内存中占用多少存储空间；而<code>SerializedLogBuffer</code>会将保存的日志进行压缩，这样就能存储更多的日志信息。它对应的头文件和实现文件在<code>system/logging/logd/SerializedLogBuffer.h</code>和<code>system/logging/logd/SerializedLogBuffer.cpp</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/SerializedLogBuffer.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SerializedLogBuffer::Log</span><span class="hljs-params">(<span class="hljs-type">log_id_t</span> log_id, log_time realtime, <span class="hljs-type">uid_t</span> uid, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> tid,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">uint16_t</span> len)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 每条日志大小有限制，不能超过限制</span><br>    <span class="hljs-keyword">if</span> (len &gt; LOGGER_ENTRY_MAX_PAYLOAD) &#123;<br>        len = LOGGER_ENTRY_MAX_PAYLOAD;<br>    &#125;<br>    ...<br>    <span class="hljs-comment">// 日志顺序+1</span><br>    <span class="hljs-keyword">auto</span> sequence = sequence_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>    <span class="hljs-comment">// 添加到buffer中</span><br>    <span class="hljs-keyword">auto</span> entry = <span class="hljs-built_in">LogToLogBuffer</span>(logs_[log_id], max_size_[log_id], sequence, <br>                                realtime, uid, pid, tid,msg, len);<br>    ...<br>    <span class="hljs-comment">// 检查对应的log_id存储的数据是否满了，满了的话删除旧日志</span><br>    <span class="hljs-built_in">MaybePrune</span>(log_id);<br>    <span class="hljs-comment">// 通知有新日志插入</span><br>    reader_list_-&gt;<span class="hljs-built_in">NotifyNewLog</span>(<span class="hljs-number">1</span> &lt;&lt; log_id);<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> SerializedLogEntry* <span class="hljs-title">LogToLogBuffer</span><span class="hljs-params">(std::list&lt;SerializedLogChunk&gt;&amp; log_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">size_t</span> max_size, <span class="hljs-type">uint64_t</span> sequence, log_time realtime,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">uid_t</span> uid, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> tid, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">uint16_t</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// 集合为空，说明第一次插入</span><br>    <span class="hljs-keyword">if</span> (log_buffer.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 先往集合中插入一个空的SerializedLogChunk，大小max_size / 4</span><br>        <span class="hljs-comment">// 也就是每个log_id中可以存放四个chunk</span><br>        log_buffer.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">SerializedLogChunk</span>(max_size / SerializedLogBuffer::kChunkSizeDivisor));<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> total_len = <span class="hljs-built_in">sizeof</span>(SerializedLogEntry) + len;<br>    <span class="hljs-comment">// 集合中的最后一个chunk存不下了，则插入一个新的chunk</span><br>    <span class="hljs-keyword">if</span> (!log_buffer.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">CanLog</span>(total_len)) &#123;<br>        <span class="hljs-comment">// 结束写入日志，并压缩</span><br>        log_buffer.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">FinishWriting</span>();<br>        log_buffer.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">SerializedLogChunk</span>(max_size / SerializedLogBuffer::kChunkSizeDivisor));<br>    &#125;<br>    <span class="hljs-comment">// 将日志插入到集合的最后一个chunk中</span><br>    <span class="hljs-keyword">return</span> log_buffer.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">Log</span>(sequence, realtime, uid, pid, tid, msg, len);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>SerializedLogBuffer</code>中，数据并不是直接存储在<code>log_</code>中的，而是存在一个新的结构<code>SerializedLogChunk</code>中。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/SerializedLogChunk.cpp</span><br><br><span class="hljs-comment">// 将contents_中的数据压缩到compressed_log_中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SerializedLogChunk::FinishWriting</span><span class="hljs-params">()</span> </span>&#123;<br>    writer_active_ = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">CHECK_EQ</span>(compressed_log_.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0U</span>);<br>    CompressionEngine::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">Compress</span>(contents_, write_offset_, compressed_log_);<br>    <span class="hljs-built_in">LOG</span>(VERBOSE) &lt;&lt; <span class="hljs-string">&quot;Compressed Log, buffer max size: &quot;</span> &lt;&lt; contents_.<span class="hljs-built_in">size</span>()<br>                 &lt;&lt; <span class="hljs-string">&quot; size used: &quot;</span> &lt;&lt; write_offset_<br>                 &lt;&lt; <span class="hljs-string">&quot; compressed size: &quot;</span> &lt;&lt; compressed_log_.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (reader_ref_count_ == <span class="hljs-number">0</span>) &#123;<br>        contents_.<span class="hljs-built_in">Resize</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">SerializedLogEntry* <span class="hljs-title">SerializedLogChunk::Log</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> sequence, log_time realtime, <span class="hljs-type">uid_t</span> uid,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> tid, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">uint16_t</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// 记录新log的地址</span><br>    <span class="hljs-keyword">auto</span> new_log_address = contents_.<span class="hljs-built_in">data</span>() + write_offset_;<br>    <span class="hljs-comment">// 在该地址上创建一个新的entry存储日志</span><br>    <span class="hljs-keyword">auto</span>* entry = <span class="hljs-built_in">new</span> (new_log_address) <span class="hljs-built_in">SerializedLogEntry</span>(uid, pid, tid, sequence, realtime, len);<br>    <span class="hljs-built_in">memcpy</span>(entry-&gt;<span class="hljs-built_in">msg</span>(), msg, len);<br>    write_offset_ += entry-&gt;<span class="hljs-built_in">total_len</span>();<br>    highest_sequence_number_ = sequence;<br>    <span class="hljs-keyword">return</span> entry;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SerializedLogBuffer</code>将数据按照<code>log_id</code>进行区分，每个<code>log_id</code>对应自己的一个数据集合，集合的每个元素中存储自己对应的日志分类数据，当存储满之后进行压缩，后续的新日志存储在新的元素中。</p><p><img alt="SerializedLogBuffer" class="lozad post-image" src="/img/logd-serialized.webp" data-src="/img/logd-serialized.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><h4 id="ChattyLogBuffer"><a href="#ChattyLogBuffer" class="headerlink" title="ChattyLogBuffer"></a>ChattyLogBuffer</h4><p><code>ChattyLogBuffer</code>不是直接继承自<code>LogBuffer</code>，而是<code>SimpleLogBuffer</code>的一个子类。我们前面看过了<code>SimpleLogBuffer</code>的结构，整体就是一个<code>list</code>集合，然后所有的日志都会包装成一个<code>LogBufferElement</code>然后插入到集合中去。这种存储方式比较全面，能够记录所有的信息，但是比较占用空间。而<code>ChattyLogBuffer</code>就是对其的一种优化，它会将连续多次同样的日志进行过滤，只记录一次。从名字看它就是一种非正式的缓存，因此也一般不会使用。它对应的头文件和实现文件在<code>system/logging/logd/ChattyLogBuffer.h</code>和<code>system/logging/logd/ChattyLogBuffer.cpp</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/ChattyLogBuffer.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChattyLogBuffer::LogInternal</span><span class="hljs-params">(LogBufferElement&amp;&amp; elem)</span> </span>&#123;<br>    <span class="hljs-comment">// 安全相关的日志不去合并，直接使用默认的记录方式</span><br>    <span class="hljs-keyword">if</span> (elem.<span class="hljs-built_in">log_id</span>() == LOG_ID_SECURITY) &#123;<br>        SimpleLogBuffer::<span class="hljs-built_in">LogInternal</span>(std::<span class="hljs-built_in">move</span>(elem));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> log_id = elem.<span class="hljs-built_in">log_id</span>();<br><br>    <span class="hljs-comment">// 如果last_logged_elements_数组中未存储该id的日志，则直接存储</span><br>    <span class="hljs-keyword">if</span> (!last_logged_elements_[log_id]) &#123;<br>        last_logged_elements_[log_id].<span class="hljs-built_in">emplace</span>(elem);<br>        SimpleLogBuffer::<span class="hljs-built_in">LogInternal</span>(std::<span class="hljs-built_in">move</span>(elem));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取到最后一次存储的对应id的element</span><br>    LogBufferElement&amp; current_last = *last_logged_elements_[log_id];<br>    <span class="hljs-comment">// 比较本次的log和上次记录的log信息是否完全一致</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">match_type</span> match = <span class="hljs-built_in">Identical</span>(elem, current_last);<br>    <span class="hljs-comment">// 和上次打印的数据不一致，说明不需要合并</span><br>    <span class="hljs-keyword">if</span> (match == DIFFERENT) &#123;<br>        <span class="hljs-comment">// 之前已经有记录的重复的元素存在了</span><br>        <span class="hljs-keyword">if</span> (duplicate_elements_[log_id]) &#123;<br>            <span class="hljs-comment">// 如果重复数据大于0，则插入一条新的日志信息</span><br>            <span class="hljs-keyword">if</span> (duplicate_elements_[log_id]-&gt;<span class="hljs-built_in">dropped_count</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>                SimpleLogBuffer::<span class="hljs-built_in">LogInternal</span>(std::<span class="hljs-built_in">move</span>(*duplicate_elements_[log_id]));<br>            &#125;<br>            duplicate_elements_[log_id].<span class="hljs-built_in">reset</span>();<br>            <span class="hljs-comment">// 插入上次记录的日志信息</span><br>            SimpleLogBuffer::<span class="hljs-built_in">LogInternal</span>(std::<span class="hljs-built_in">move</span>(current_last));<br>        &#125;<br>        <span class="hljs-comment">// 插入新的日志信息</span><br>        last_logged_elements_[log_id].<span class="hljs-built_in">emplace</span>(elem);<br>        SimpleLogBuffer::<span class="hljs-built_in">LogInternal</span>(std::<span class="hljs-built_in">move</span>(elem));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 走到这里说明日志信息与上次的一致，但是重复信息却没有</span><br>    <span class="hljs-keyword">if</span> (!duplicate_elements_[log_id]) &#123;<br>        <span class="hljs-comment">// 插入重复信息</span><br>        duplicate_elements_[log_id].<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(current_last));<br>        <span class="hljs-comment">// 并更新最新的日志</span><br>        last_logged_elements_[log_id].<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(elem));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 相同的LIBLOG事件</span><br>    <span class="hljs-keyword">if</span> (match == SAME_LIBLOG) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">android_log_event_int_t</span>* current_last_event =<br>                <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">android_log_event_int_t</span>*&gt;(current_last.<span class="hljs-built_in">msg</span>());<br>        <span class="hljs-type">int64_t</span> current_last_count = current_last_event-&gt;payload.data;<br>        <span class="hljs-type">android_log_event_int_t</span>* elem_event =<br>                <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">android_log_event_int_t</span>*&gt;(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(elem.<span class="hljs-built_in">msg</span>()));<br>        <span class="hljs-type">int64_t</span> elem_count = elem_event-&gt;payload.data;<br>        <span class="hljs-comment">// 合并数量</span><br>        <span class="hljs-type">int64_t</span> total = current_last_count + elem_count;<br>        <span class="hljs-comment">// 超过最大限制后直接记录出来</span><br>        <span class="hljs-keyword">if</span> (total &gt; std::numeric_limits&lt;<span class="hljs-type">int32_t</span>&gt;::<span class="hljs-built_in">max</span>()) &#123;<br>            SimpleLogBuffer::<span class="hljs-built_in">LogInternal</span>(std::<span class="hljs-built_in">move</span>(current_last));<br>            last_logged_elements_[log_id].<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(elem));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 否则的话更新到last_logged_elements_中</span><br>        <span class="hljs-built_in">stats</span>()-&gt;<span class="hljs-built_in">AddTotal</span>(current_last.<span class="hljs-built_in">log_id</span>(), current_last.<span class="hljs-built_in">msg_len</span>());<br>        elem_event-&gt;payload.data = total;<br>        last_logged_elements_[log_id].<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(elem));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 完全相同的普通日志信息</span><br>    <span class="hljs-type">uint16_t</span> dropped_count = duplicate_elements_[log_id]-&gt;<span class="hljs-built_in">dropped_count</span>();<br>    <span class="hljs-comment">// 超过最大限制后直接记录</span><br>    <span class="hljs-keyword">if</span> (dropped_count == std::numeric_limits&lt;<span class="hljs-type">uint16_t</span>&gt;::<span class="hljs-built_in">max</span>()) &#123;<br>        SimpleLogBuffer::<span class="hljs-built_in">LogInternal</span>(std::<span class="hljs-built_in">move</span>(*duplicate_elements_[log_id]));<br>        dropped_count = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 记录新的重复条数并更新信息</span><br>    current_last.<span class="hljs-built_in">SetDropped</span>(dropped_count + <span class="hljs-number">1</span>);<br>    duplicate_elements_[log_id].<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(current_last));<br>    last_logged_elements_[log_id].<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(elem));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ChattyLogBuffer</code>最主要的就是重写了<code>LogInternal</code>方法，在实际需要记录<code>log</code>信息的地方进行了拦截，这也就导致了如果打印的数据是一模一样的话，并不会实际记录，而是设置<code>SetDropped</code>重复次数，当下次数据不一致的时候进行输出提示。</p><p><img alt="SimpleLogBuffer" class="lozad post-image" src="/img/logd-simple.webp" data-src="/img/logd-simple.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><h3 id="启用socket"><a href="#启用socket" class="headerlink" title="启用socket"></a>启用socket</h3><p>上面初始化完成之后，就是启用三个核心的socket，他们就是日志服务与外界进行交互的通道。</p><h4 id="logdr"><a href="#logdr" class="headerlink" title="logdr"></a>logdr</h4><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/main.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    ...<br>    LogReader* reader = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LogReader</span>(log_buffer, &amp;reader_list);<br>    <span class="hljs-keyword">if</span> (reader-&gt;<span class="hljs-built_in">startListener</span>()) &#123;<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>logdr</code>是通过<code>LogReader</code>来启动的，首先创建了一个<code>LogReader</code>，然后通过<code>startListener</code>启用监听。它监听的就是<code>/dev/socket/logdr</code>也就是读取日志信息的通道，该<code>socket</code>是在<code>rc</code>文件中创建的。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/LogReader.cpp</span><br><br>LogReader::<span class="hljs-built_in">LogReader</span>(LogBuffer* logbuf, LogReaderList* reader_list)<br>    <span class="hljs-comment">// socketListener进行监听套接字</span><br>    : <span class="hljs-built_in">SocketListener</span>(<span class="hljs-built_in">getLogSocket</span>(), <span class="hljs-literal">true</span>), <span class="hljs-built_in">log_buffer_</span>(logbuf), <span class="hljs-built_in">reader_list_</span>(reader_list) &#123;&#125;<br><br><span class="hljs-comment">// 获取到的是logdr套接字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LogReader::getLogSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> socketName[] = <span class="hljs-string">&quot;logdr&quot;</span>;<br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">android_get_control_socket</span>(socketName);<br><br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>) &#123;<br>        sock = <span class="hljs-built_in">socket_local_server</span>(<br>            socketName, ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_SEQPACKET);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sock;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>LogReader</code>是继承自<code>SocketListener</code>的，实际的监听也是在<code>SocketListener</code>中完成的。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/core/libsysutils/src/SocketListener.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SocketListener::startListener</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">startListener</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SocketListener::startListener</span><span class="hljs-params">(<span class="hljs-type">int</span> backlog)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 创建一个线程，然后执行threadStart方法</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;mThread, <span class="hljs-literal">nullptr</span>, SocketListener::threadStart, <span class="hljs-keyword">this</span>)) &#123;<br>        <span class="hljs-built_in">SLOGE</span>(<span class="hljs-string">&quot;pthread_create (%s)&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">SocketListener::threadStart</span><span class="hljs-params">(<span class="hljs-type">void</span> *obj)</span> </span>&#123;<br>    SocketListener *me = <span class="hljs-built_in">reinterpret_cast</span>&lt;SocketListener *&gt;(obj);<br>	<span class="hljs-comment">// 最终走到runListener中</span><br>    me-&gt;<span class="hljs-built_in">runListener</span>();<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SocketListener::runListener</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 死循环，该过程运行在子线程中</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 使用poll机制监听管道以及socket和client的变化</span><br>        std::vector&lt;pollfd&gt; fds;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mClientsLock);<br>        fds.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">2</span> + mClients.<span class="hljs-built_in">size</span>());<br>        fds.<span class="hljs-built_in">push_back</span>(&#123;.fd = mCtrlPipe[<span class="hljs-number">0</span>], .events = POLLIN&#125;);<br>        <span class="hljs-keyword">if</span> (mListen) fds.<span class="hljs-built_in">push_back</span>(&#123;.fd = mSock, .events = POLLIN&#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair : mClients) &#123;<br>            <span class="hljs-comment">// NB: calling out to an other object with mClientsLock held (safe)</span><br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> fd = pair.second-&gt;<span class="hljs-built_in">getSocket</span>();<br>            <span class="hljs-keyword">if</span> (fd != pair.first) <span class="hljs-built_in">SLOGE</span>(<span class="hljs-string">&quot;fd mismatch: %d != %d&quot;</span>, fd, pair.first);<br>            fds.<span class="hljs-built_in">push_back</span>(&#123;.fd = fd, .events = POLLIN&#125;);<br>        &#125;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mClientsLock);<br><br>        <span class="hljs-comment">// 进入阻塞，直到监听的文件描述符发生变化后，才会唤醒</span><br>        <span class="hljs-type">int</span> rc = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">poll</span>(fds.<span class="hljs-built_in">data</span>(), fds.<span class="hljs-built_in">size</span>(), <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">SLOGE</span>(<span class="hljs-string">&quot;poll failed (%s) mListen=%d&quot;</span>, <span class="hljs-built_in">strerror</span>(errno), mListen);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 管道中读取数据，如果是关闭命令，则结束监听</span><br>        <span class="hljs-keyword">if</span> (fds[<span class="hljs-number">0</span>].revents &amp; (POLLIN | POLLERR)) &#123;<br>            <span class="hljs-type">char</span> c = CtrlPipe_Shutdown;<br>            <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">read</span>(mCtrlPipe[<span class="hljs-number">0</span>], &amp;c, <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span> (c == CtrlPipe_Shutdown) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从logdr中读取数据</span><br>        <span class="hljs-keyword">if</span> (mListen &amp;&amp; (fds[<span class="hljs-number">1</span>].revents &amp; (POLLIN | POLLERR))) &#123;<br>            <span class="hljs-comment">// 创建一个新的套接字描述符</span><br>            <span class="hljs-type">int</span> c = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">accept4</span>(mSock, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, SOCK_CLOEXEC));<br>            <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">SLOGE</span>(<span class="hljs-string">&quot;accept failed (%s)&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));<br>                <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mClientsLock);<br>            <span class="hljs-comment">// 创建一个对应的SocketClient用于进行交互</span><br>            mClients[c] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SocketClient</span>(c, <span class="hljs-literal">true</span>, mUseCmdNum);<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mClientsLock);<br>        &#125;<br><br>        <span class="hljs-comment">// 将所有有消息的mClients添加到pending中</span><br>        std::vector&lt;SocketClient*&gt; pending;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mClientsLock);<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> size = fds.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mListen ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>; i &lt; size; ++i) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span>&amp; p = fds[i];<br>            <span class="hljs-keyword">if</span> (p.revents &amp; (POLLIN | POLLERR)) &#123;<br>                <span class="hljs-keyword">auto</span> it = mClients.<span class="hljs-built_in">find</span>(p.fd);<br>                <span class="hljs-keyword">if</span> (it == mClients.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-built_in">SLOGE</span>(<span class="hljs-string">&quot;fd vanished: %d&quot;</span>, p.fd);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                SocketClient* c = it-&gt;second;<br>                pending.<span class="hljs-built_in">push_back</span>(c);<br>                c-&gt;<span class="hljs-built_in">incRef</span>();<br>            &#125;<br>        &#125; <br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mClientsLock);<br><br>        <span class="hljs-comment">// 然后在onDataAvailable中进行处理</span><br>        <span class="hljs-keyword">for</span> (SocketClient* c : pending) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">onDataAvailable</span>(c)) &#123;<br>                <span class="hljs-built_in">release</span>(c, <span class="hljs-literal">false</span>);<br>            &#125;<br>            c-&gt;<span class="hljs-built_in">decRef</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要逻辑就是通过<code>SocketListener</code>进行监听<code>logdr</code>套接字的数据信息以及管道数据信息，其中当有人连接到<code>logdr</code>后，就会建立连接并获取到<code>socketFd</code>，最终创建出一个<code>SocketClient</code>，然后在<code>onDataAvailable</code>中进行处理。但是该方法是个虚函数，最终的实现是在<code>LogReader</code>中处理的。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/LogReader.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LogReader::onDataAvailable</span><span class="hljs-params">(SocketClient* cli)</span> </span>&#123;<br>    ...<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">255</span>];<br>    <span class="hljs-comment">// 读取数据</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">read</span>(cli-&gt;<span class="hljs-built_in">getSocket</span>(), buffer, <span class="hljs-built_in">sizeof</span>(buffer) - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">DoSocketDelete</span>(cli);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    buffer[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 每次socket数据只能发送一次数据，发送完之后就结束掉</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">DoSocketDelete</span>(cli)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 后面就是具体的数据交互部分了</span><br>    ...<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="logdw"><a href="#logdw" class="headerlink" title="logdw"></a>logdw</h4><p><code>logdw</code>是写入日志信息的<code>socket</code>，也是在<code>rc</code>文件中启动的。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/main.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    ...<br>    LogListener* swl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LogListener</span>(log_buffer);<br>    <span class="hljs-keyword">if</span> (!swl-&gt;<span class="hljs-built_in">StartListener</span>()) &#123;<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，也是通过listener开启一个线程，然后在单独的线程中处理日志数据。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/LogListener.cpp</span><br><br>LogListener::<span class="hljs-built_in">LogListener</span>(LogBuffer* buf) : <span class="hljs-built_in">socket_</span>(<span class="hljs-built_in">GetLogSocket</span>()), <span class="hljs-built_in">logbuf_</span>(buf) &#123;&#125;<br><br><span class="hljs-comment">// 获取到logdw</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LogListener::GetLogSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> socketName[] = <span class="hljs-string">&quot;logdw&quot;</span>;<br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">android_get_control_socket</span>(socketName);<br><br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// logd started up in init.sh</span><br>        sock = <span class="hljs-built_in">socket_local_server</span>(<br>            socketName, ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_DGRAM);<br><br>        <span class="hljs-type">int</span> on = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">setsockopt</span>(sock, SOL_SOCKET, SO_PASSCRED, &amp;on, <span class="hljs-built_in">sizeof</span>(on))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sock;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里和<code>LogReader</code>是不一样，他没有继承自<code>SocketListener</code>，就是一个普通的类而已。接着继续看<code>startListener</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/LogListener.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LogListener::StartListener</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (socket_ &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 创建线程，然后执行ThreadFunction函数</span><br>    <span class="hljs-keyword">auto</span> thread = std::<span class="hljs-built_in">thread</span>(&amp;LogListener::ThreadFunction, <span class="hljs-keyword">this</span>);<br>    thread.<span class="hljs-built_in">detach</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogListener::ThreadFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">prctl</span>(PR_SET_NAME, <span class="hljs-string">&quot;logd.writer&quot;</span>);<br>    <span class="hljs-comment">// 子线程中运行，循环处理数据</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-built_in">HandleData</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理日志数据，每次处理一条，循环执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogListener::HandleData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// + 1 to ensure null terminator if MAX_PAYLOAD buffer is received</span><br>    __attribute__((uninitialized)) <span class="hljs-type">char</span><br>            buffer[<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">android_log_header_t</span>) + LOGGER_ENTRY_MAX_PAYLOAD + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> iov = &#123;buffer, <span class="hljs-built_in">sizeof</span>(buffer) - <span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">4</span>) <span class="hljs-type">char</span> control[<span class="hljs-built_in">CMSG_SPACE</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> ucred))];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msghdr</span> hdr = &#123;<br>        <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, &amp;iov, <span class="hljs-number">1</span>, control, <span class="hljs-built_in">sizeof</span>(control), <span class="hljs-number">0</span>,<br>    &#125;;<br><br>    <span class="hljs-comment">// 从socket中读取数据</span><br>    <span class="hljs-type">ssize_t</span> n = <span class="hljs-built_in">recvmsg</span>(socket_, &amp;hdr, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (n &lt;= (<span class="hljs-type">ssize_t</span>)(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">android_log_header_t</span>))) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ...<br>    <span class="hljs-comment">// 中间的一大截就是解析数据，最终获取到对应的日志信息，然后记录在LogBuffer中</span><br><br>    logbuf_-&gt;<span class="hljs-built_in">Log</span>(logId, header-&gt;realtime, cred-&gt;uid, cred-&gt;pid, header-&gt;tid, msg,<br>                 ((<span class="hljs-type">size_t</span>)n &lt;= UINT16_MAX) ? (<span class="hljs-type">uint16_t</span>)n : UINT16_MAX);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的结果就是其他地方通过<code>logdw</code>写入日志数据，最终由<code>logd</code>存储在的对应的缓存结构中。</p><h4 id="logd"><a href="#logd" class="headerlink" title="logd"></a>logd</h4><p><code>logd</code>套接字是负责命令相关的，最主要的用途就是<code>logcat</code>了，每次通过<code>logcat</code>发出命令后，都会给<code>logd</code>发送对应的数据，最终解析出来并进行处理。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/main.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    ...<br>    CommandListener* cl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CommandListener</span>(log_buffer, &amp;log_tags, &amp;prune_list, &amp;log_statistics);<br>    <span class="hljs-keyword">if</span> (cl-&gt;<span class="hljs-built_in">startListener</span>()) &#123;<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>和前面一样，都是通过创建<code>Listener</code>并开启监听，最终来到子线程中进行处理。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/logd/CommandListener.cpp</span><br><br>CommandListener::<span class="hljs-built_in">CommandListener</span>(LogBuffer* buf, LogTags* tags, PruneList* prune,<br>                                 LogStatistics* stats)<br>    : <span class="hljs-built_in">FrameworkListener</span>(<span class="hljs-built_in">getLogSocket</span>()), <span class="hljs-built_in">buf_</span>(buf), <span class="hljs-built_in">tags_</span>(tags), <span class="hljs-built_in">prune_</span>(prune), <span class="hljs-built_in">stats_</span>(stats) &#123;<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ClearCmd</span>(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">GetBufSizeCmd</span>(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SetBufSizeCmd</span>(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">GetBufSizeReadableCmd</span>(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">GetBufSizeUsedCmd</span>(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">GetStatisticsCmd</span>(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SetPruneListCmd</span>(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">GetPruneListCmd</span>(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">GetEventTagCmd</span>(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ReinitCmd</span>(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-built_in">registerCmd</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ExitCmd</span>(<span class="hljs-keyword">this</span>));<br>&#125;<br><br><span class="hljs-comment">// 获取到logd的socket</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CommandListener::getLogSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> socketName[] = <span class="hljs-string">&quot;logd&quot;</span>;<br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">android_get_control_socket</span>(socketName);<br><br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>) &#123;<br>        sock = <span class="hljs-built_in">socket_local_server</span>(<br>            socketName, ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_STREAM);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sock;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法中注册了多个命令，后续就会解析套接字中的命令数据，然后交给对应的命令进行处理，这里就不在展开了。其中<code>CommandListener</code>是继承自<code>FrameworkListener</code>的，然后在<code>FrameworkListener</code>又继承自<code>SocketListener</code>，因此它和前面的<code>LogReader</code>是有些相似的。</p><p>当<code>CommandListener</code>启动之后，就代表了<code>logd</code>服务已经完成了启动，此时会在系统属性中写入<code>SetProperty(&quot;logd.ready&quot;, &quot;true&quot;);</code>。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>logdr</code>和<code>logdw</code>提供了对日志的读写功能，是通过<code>socket</code>进行交互的，但是实际上我们肯定不可能直接对其进行操作，一方面是权限问题，另一方面则是协议问题。直接交互无法保障数据格式以及交互方的身份情况，因此提供了一系列的方法供我们使用。</p><p>在<code>Java</code>层，<code>log</code>的写入是通过一系列的静态方法去写入的，如<code>Log.d</code>等，我们直接通过这些静态方法打印日志即可，不需要关注身份以及格式问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/util/Log.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> &#123;<br>    <span class="hljs-comment">// MAIN类型的日志</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">d</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String tag, <span class="hljs-meta">@NonNull</span> String msg)</span> &#123;<br>        <span class="hljs-keyword">return</span> println_native(LOG_ID_MAIN, DEBUG, tag, msg);<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">v</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String tag, <span class="hljs-meta">@NonNull</span> String msg)</span> &#123;<br>        <span class="hljs-keyword">return</span> println_native(LOG_ID_MAIN, VERBOSE, tag, msg);<br>    &#125;<br>    ...<br>    <span class="hljs-comment">// RADIO类型的日志</span><br>    <span class="hljs-meta">@SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">logToRadioBuffer</span><span class="hljs-params">(<span class="hljs-meta">@Level</span> <span class="hljs-type">int</span> priority, <span class="hljs-meta">@Nullable</span> String tag,</span><br><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> String message)</span> &#123;<br>        <span class="hljs-keyword">return</span> println_native(LOG_ID_RADIO, priority, tag, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们正常通过<code>Log</code>打印的日志都是通过<code>println_native</code>走到<code>native</code>层进行打印的，并且分类是<code>LOG_ID_MAIN</code>。分类<code>id</code>是固定的，不允许指定，如果想要打印别的<code>id</code>，则需要使用其他工具类进行打印。如<code>SLog</code>打印的是<code>SYSTEM</code>类型的日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/util/Slog.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SLog</span> &#123;<br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">v</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String tag, <span class="hljs-meta">@NonNull</span> String msg)</span> &#123;<br>        <span class="hljs-keyword">return</span> Log.println_native(Log.LOG_ID_SYSTEM, Log.VERBOSE, tag, msg);<br>    &#125;<br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">d</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String tag, <span class="hljs-meta">@NonNull</span> String msg)</span> &#123;<br>        <span class="hljs-keyword">return</span> Log.println_native(Log.LOG_ID_SYSTEM, Log.DEBUG, tag, msg);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上还是走到了<code>Log</code>类中进行的打印，只是换了个<code>ID</code>而已。注意<code>SLog</code>在普通的应用中是不允许使用的，应该是在系统组件中使用。<code>EVENT</code>类型的日志是在另外一个文件中打印的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/util/EventLog.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLog</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">writeEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> tag, <span class="hljs-type">int</span> value)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">writeEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> tag, <span class="hljs-type">long</span> value)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">writeEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> tag, String str)</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>主要分为了两个部分进入到<code>native</code>层进行打印，一个是<code>println_native</code>一个是<code>writeEvent</code>，接下来继续看这两个方法的实现。因为这两个方法都是在<code>Java</code>层中的，对于<code>framework</code>层的<code>jni</code>方法都是动态注册的，他们对应的文件都在<code>frameworks/base/core/jni/</code>目录下，因此我们如果想要找对应的<code>jni</code>文件，则可以直接在该目录下搜<code>包名_类名.cpp</code>文件，如这里我们就应该找<code>android.util.Log.cpp</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// native对应的方法</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> JNINativeMethod gMethods[] = &#123;<br>    <span class="hljs-comment">/* name, signature, funcPtr */</span><br>    &#123; <span class="hljs-string">&quot;isLoggable&quot;</span>,      <span class="hljs-string">&quot;(Ljava/lang/String;I)Z&quot;</span>, (<span class="hljs-type">void</span>*) android_util_Log_isLoggable &#125;,<br>    &#123; <span class="hljs-string">&quot;println_native&quot;</span>,  <span class="hljs-string">&quot;(IILjava/lang/String;Ljava/lang/String;)I&quot;</span>, (<span class="hljs-type">void</span>*) android_util_Log_println_native &#125;,<br>    &#123; <span class="hljs-string">&quot;logger_entry_max_payload_native&quot;</span>,  <span class="hljs-string">&quot;()I&quot;</span>, (<span class="hljs-type">void</span>*) android_util_Log_logger_entry_max_payload_native &#125;,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> jint <span class="hljs-title">android_util_Log_println_native</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><br><span class="hljs-params"><span class="hljs-function">        jint bufID, jint priority, jstring tagObj, jstring msgObj)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* tag = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (msgObj == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-string">&quot;println needs a message&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bufID &lt; <span class="hljs-number">0</span> || bufID &gt;= LOG_ID_MAX) &#123;<br>        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-string">&quot;bad bufID&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (tagObj != <span class="hljs-literal">NULL</span>)<br>        tag = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(tagObj, <span class="hljs-literal">NULL</span>);<br>    msg = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(msgObj, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 写入log。该方法对应的头文件是log/log.h，实际声明是在android/log.h中</span><br>    <span class="hljs-type">int</span> res = __android_log_buf_write(bufID, (android_LogPriority)priority, tag, msg);<br><br>    <span class="hljs-keyword">if</span> (tag != <span class="hljs-literal">NULL</span>)<br>        env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(tagObj, tag);<br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(msgObj, msg);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>jni</code>层中的方法只是一个转发，实际上还是走到了<code>liblog</code>中的方法，该方法定义在<code>system/logging/liblog/include/android/log.h</code>中，然后被包含在了<code>system/logging/liblog/include/log/log.h</code>中，实际的实现文件在<code>system/logging/liblog/logger_write.cpp</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/liblog/logger_write.cpp</span><br><br><span class="hljs-type">int</span> __android_log_buf_write(<span class="hljs-type">int</span> bufID, <span class="hljs-type">int</span> prio, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* tag, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg) &#123;<br>  ...<br>  <span class="hljs-comment">// 将打印的数据包装成log_message，然后写入</span><br>  __android_log_message log_message = &#123;<br>      <span class="hljs-built_in">sizeof</span>(__android_log_message), bufID, prio, tag, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, msg&#125;;<br>  __android_log_write_log_message(&amp;log_message);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> __android_log_write_log_message(__android_log_message* log_message) &#123;<br>  ...<br>  <span class="hljs-comment">// logger_function是定义的宏，实际对应于方法__android_log_logd_logger</span><br>  <span class="hljs-built_in">logger_function</span>(log_message);<br>&#125;<br><br><span class="hljs-comment">// 该宏定义实际在文件的最前面，这里放到下边方便查看</span><br><span class="hljs-type">static</span> __android_logger_function logger_function = __android_log_logd_logger;<br><br><span class="hljs-type">void</span> __android_log_logd_logger(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> __android_log_message* log_message) &#123;<br>  <span class="hljs-type">int</span> buffer_id = log_message-&gt;buffer_id == LOG_ID_DEFAULT ? LOG_ID_MAIN : log_message-&gt;buffer_id;<br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> vec[<span class="hljs-number">3</span>];<br>  vec[<span class="hljs-number">0</span>].iov_base =<br>      <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(&amp;log_message-&gt;priority));<br>  vec[<span class="hljs-number">0</span>].iov_len = <span class="hljs-number">1</span>;<br>  vec[<span class="hljs-number">1</span>].iov_base = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(log_message-&gt;tag));<br>  vec[<span class="hljs-number">1</span>].iov_len = <span class="hljs-built_in">strlen</span>(log_message-&gt;tag) + <span class="hljs-number">1</span>;<br>  vec[<span class="hljs-number">2</span>].iov_base = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(log_message-&gt;message));<br>  vec[<span class="hljs-number">2</span>].iov_len = <span class="hljs-built_in">strlen</span>(log_message-&gt;message) + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 写入日志文件</span><br>  <span class="hljs-built_in">write_to_log</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">log_id_t</span>&gt;(buffer_id), vec, <span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">write_to_log</span><span class="hljs-params">(<span class="hljs-type">log_id_t</span> log_id, <span class="hljs-keyword">struct</span> iovec* vec, <span class="hljs-type">size_t</span> nr)</span> </span>&#123;<br>  <span class="hljs-type">int</span> ret;<br>  ...<br>  <span class="hljs-comment">// 最终的打印log的地方</span><br>  ret = <span class="hljs-built_in">LogdWrite</span>(log_id, &amp;ts, vec, nr);<br>  <span class="hljs-built_in">PmsgWrite</span>(log_id, &amp;ts, vec, nr);<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>反正就是经过一系列的方法调用以及数据和权限检测等，最后走到的是<code>LogdWrite</code>来实际进行打印。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/liblog/logd_writer.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LogdWrite</span><span class="hljs-params">(<span class="hljs-type">log_id_t</span> logId, <span class="hljs-keyword">struct</span> timespec* ts, <span class="hljs-keyword">struct</span> iovec* vec, <span class="hljs-type">size_t</span> nr)</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">// 向/dev/socket/logdw中写入日志</span><br>  ret = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">writev</span>(logd_socket.<span class="hljs-built_in">sock</span>(), newVec, i));<br>  <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span> &amp;&amp; errno != EAGAIN) &#123;<br>    logd_socket.<span class="hljs-built_in">Reconnect</span>();<br><br>    ret = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">writev</span>(logd_socket.<span class="hljs-built_in">sock</span>(), newVec, i));<br>  &#125;<br>  ...<br>&#125;  <br></code></pre></td></tr></table></figure><p>最终实际上还是往<code>/dev/socket/logdw</code>中写入的数据，然后经由<code>logd</code>服务的处理，最终存储在日志缓存中。以上的整个链路就是<code>Java</code>层打印普通<code>log</code>的一个流程，而对应<code>EVENT</code>类型的日志，走的是另一条路，我们重新回过头看<code>android_utils_EventLog.cpp</code>。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/base/core/jni/android_util_EventLog.cpp</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> JNINativeMethod gRegisterMethods[] = &#123;<br>    <span class="hljs-comment">/* name, signature, funcPtr */</span><br>    &#123; <span class="hljs-string">&quot;writeEvent&quot;</span>, <span class="hljs-string">&quot;(II)I&quot;</span>, (<span class="hljs-type">void</span>*) ELog::writeEventInteger &#125;,<br>    &#123; <span class="hljs-string">&quot;writeEvent&quot;</span>, <span class="hljs-string">&quot;(IJ)I&quot;</span>, (<span class="hljs-type">void</span>*) ELog::writeEventLong &#125;,<br>    &#123; <span class="hljs-string">&quot;writeEvent&quot;</span>, <span class="hljs-string">&quot;(IF)I&quot;</span>, (<span class="hljs-type">void</span>*) ELog::writeEventFloat &#125;,<br>    &#123; <span class="hljs-string">&quot;writeEvent&quot;</span>, <span class="hljs-string">&quot;(ILjava/lang/String;)I&quot;</span>, (<span class="hljs-type">void</span>*) ELog::writeEventString &#125;,<br>    &#123; <span class="hljs-string">&quot;writeEvent&quot;</span>, <span class="hljs-string">&quot;(I[Ljava/lang/Object;)I&quot;</span>, (<span class="hljs-type">void</span>*) ELog::writeEventArray &#125;,<br>    &#123; <span class="hljs-string">&quot;readEvents&quot;</span>,<br>      <span class="hljs-string">&quot;([ILjava/util/Collection;)V&quot;</span>,<br>      (<span class="hljs-type">void</span>*) android_util_EventLog_readEvents<br>    &#125;,<br>    &#123; <span class="hljs-string">&quot;readEventsOnWrapping&quot;</span>,<br>      <span class="hljs-string">&quot;([IJLjava/util/Collection;)V&quot;</span>,<br>      (<span class="hljs-type">void</span>*) android_util_EventLog_readEventsOnWrapping<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>对应的<code>native</code>方法被映射到了<code>ELog</code>类中去了，该类是在<code>eventlog_helper.h</code>中定义的。它不像<code>MAIN</code>类型的日志那样全部当成了字符串，而是将打印的日志根据数据类型进行区分了，对应的方法也有好几个方法，不过都基本上差不多，我们看一个即可。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// frameworks/base/core/jni/eventlog_helper.h</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLogHelper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> jint <span class="hljs-title">writeEventInteger</span><span class="hljs-params">(JNIEnv* env ATTRIBUTE_UNUSED, jobject clazz ATTRIBUTE_UNUSED,</span></span><br><span class="hljs-params"><span class="hljs-function">            jint tag, jint value)</span> </span>&#123;<br>        <span class="hljs-function">android_log_event_list <span class="hljs-title">ctx</span><span class="hljs-params">(tag)</span></span>;<br>        ctx &lt;&lt; (<span class="hljs-type">int32_t</span>)value;<br>        <span class="hljs-keyword">return</span> ctx.<span class="hljs-built_in">write</span>(LogID);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>看流程就是构建了一个<code>ctx</code>的<code>list</code>，然后写入了一个<code>int</code>值，在然后通过<code>write</code>写入。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/liblog/include/log/log_event_list.h</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">android_log_event_list</span> &#123;<br> ...<br> <span class="hljs-keyword">public</span>:<br>  ...<br>  android_log_event_list&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">int32_t</span> value) &#123;<br>    <span class="hljs-type">int</span> retval = <span class="hljs-built_in">android_log_write_int32</span>(ctx, value);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>) ret = retval;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">log_id_t</span> id = LOG_ID_EVENTS)</span> </span>&#123;<br>    <span class="hljs-comment">/* facilitate -EBUSY retry */</span><br>    <span class="hljs-keyword">if</span> ((ret == -EBUSY) || (ret &gt; <span class="hljs-number">0</span>)) ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> retval = <span class="hljs-built_in">android_log_write_list</span>(ctx, id);<br>    <span class="hljs-comment">/* existing errors trump transmission errors */</span><br>    <span class="hljs-keyword">if</span> (!ret) ret = retval;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>继续跟踪，这两个方法实际调用的方法实现不在头文件中，而是在对应的实现文件中，继续追踪即可查看。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/liblog/log_event_list.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">android_log_write_int32</span><span class="hljs-params">(android_log_context context, <span class="hljs-type">int32_t</span> value)</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">// 将记录的数据存储起来</span><br>  context-&gt;count[context-&gt;list_nest_depth]++;<br>  <span class="hljs-keyword">auto</span>* event_int = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">android_event_int_t</span>*&gt;(&amp;context-&gt;storage[context-&gt;pos]);<br>  event_int-&gt;type = EVENT_TYPE_INT;<br>  event_int-&gt;data = value;<br>  context-&gt;pos += needed;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">android_log_write_list</span><span class="hljs-params">(android_log_context context, <span class="hljs-type">log_id_t</span> id)</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg;<br>  <span class="hljs-type">ssize_t</span> len;<br>  ...<br>  <span class="hljs-comment">// 最终通过__android_log_bwrite写入数据</span><br>  <span class="hljs-keyword">return</span> (id == LOG_ID_EVENTS)<br>             ? __android_log_bwrite(context-&gt;tag, msg, len)<br>             : ((id == LOG_ID_STATS) ? __android_log_stats_bwrite(context-&gt;tag, msg, len)<br>                                     : __android_log_security_bwrite(context-&gt;tag, msg, len));<br>&#125;<br></code></pre></td></tr></table></figure><p>最终还是走到了<code>logger_write</code>中，与前面的保持了一致。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/liblog/logger_write.cpp</span><br><br><span class="hljs-type">int</span> __android_log_bwrite(<span class="hljs-type">int32_t</span> tag, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> len) &#123;<br>  ErrnoRestorer errno_restorer;<br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> vec[<span class="hljs-number">2</span>];<br><br>  vec[<span class="hljs-number">0</span>].iov_base = &amp;tag;<br>  vec[<span class="hljs-number">0</span>].iov_len = <span class="hljs-built_in">sizeof</span>(tag);<br>  vec[<span class="hljs-number">1</span>].iov_base = (<span class="hljs-type">void</span>*)payload;<br>  vec[<span class="hljs-number">1</span>].iov_len = len;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">write_to_log</span>(LOG_ID_EVENTS, vec, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，实际上在<code>Java</code>层的几种的类型的日志，实际上都会通过<code>jni</code>走到<code>native</code>层，然后最终汇聚在<code>logger_write</code>中，由其向<code>/dev/socket/logdw</code>写入数据，最终在<code>logd</code>服务中保存。实际上，<code>logger</code>就是<code>logd</code>提供的给外界其他应用或进程使用的一个日志接口。</p><p>那么我们在开发<code>jni</code>层面的代码时，打印<code>log</code>也需要引入<code>logger</code>吗？当然可以：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;log/log.h&gt;</span></span><br><br><span class="hljs-comment">// 通过这种方式打印log，可以指定bufID</span><br>__android_log_buf_write(bufID, priority, tag, msg);<br><br><span class="hljs-comment">// 通过这种方式打印log，默认的bufID是MAIN</span><br>__android_log_write(<span class="hljs-type">int</span> priority, tag, msg)<br></code></pre></td></tr></table></figure><p>但是我们实际上不这么用，而是使用给定的打印日志的宏来进行日志打印，如我们熟悉的<code>ALOG</code>，它是定义的一系列宏，可以帮助我们快速打印日志。</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-comment">// system/logging/liblog/include/log/log_main.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALOGD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALOGD(...) ((void)ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__))</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALOG</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALOG(priority, tag, ...) LOG_PRI(ANDROID_##priority, tag, __VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LOG_PRI</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_PRI(priority, tag, ...) android_printLog(priority, tag, __VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 最终通过这种方式打印的日志</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> android_printLog(prio, tag, ...) \</span><br><span class="hljs-meta">  __android_log_print(prio, tag, __VA_ARGS__)</span><br></code></pre></td></tr></table></figure><p>该方法定义在<code>android/log.h</code>，实际实现在<code>logger_writer.cpp</code>中。具体就不再看了，最终还是走到了同样的逻辑中，只是使用这种方式，我们写起来比较简单，还可以使用占位符来生成字串等信息。同时也帮我们省去了<code>priority</code>和<code>tag</code>参数，我们只需要关注后面的<code>message</code>即可。如我们想打印<code>DEBUG</code>类型的日志，就可以使用<code>ALOGD</code>；若是打印<code>ERROR</code>类型的日志，就可以使用<code>ALOGE</code>。如下：</p><figure class="c++ highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="c++ hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;log/log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TAG <span class="hljs-string">&quot;MyTAG&quot;</span></span><br><br><span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;打印日志&quot;</span>);<br><span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;打印日志：%d&quot;</span>, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>其他的如<code>SLOG</code>、<code>RLOG</code>等打印的是对应其他ID的日志信息，使用方式上和<code>ALOG</code>一模一样，这里不在多赘述了。当然，对于应用层的<code>jni</code>开发，我们可能会无法引入<code>log/log.h</code>头文件，我们只能引入<code>android/log.h</code>头文件，因此我们只能使用<code>__android_log_print</code>来打印日志，或者模仿<code>ALOG</code>去自己定义一些宏。</p><p>但是，在最新的<code>NDK</code>中，已经集成了<code>android/log_macros.h</code>头文件，因此我们引入该头文件后就可以使用<code>ALOG</code>了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们基本上看完了<code>logd</code>的实现以及使用，实际上我们最主要关注的就是<code>logd</code>的实现以及日志的写入，对于日志的读取基本上没怎么查看。这是因为在我们大多数的场景下，我们都不需要直接读取日志信息，而是通过<code>logcat</code>等方式去查看日志内容。</p><p><code>logd</code>作为<code>init</code>进程中较早启动的进程，它是在<code>ServiceManager</code>前启动的，因此也没有采用<code>binder</code>的方式进行跨进程（后面又引入了<code>binder</code>，只是在比较晚的时候才去注册了自身的服务），而是使用了<code>socket</code>的方式。一共提供了三个套接字，分别是<code>logdr</code>负责读取日志，<code>logdw</code>负责写入日志，<code>logd</code>负责处理<code>logcat</code>命令等。</p><p><img alt="logd" class="lozad post-image" src="/img/logd.webp" data-src="/img/logd.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Mon Jul 25 2022 14:00:26 GMT+0800");let n="Mon Jul 25 2022 14:00:26 GMT+0800";n="2025-01-05 14:55:56 +0800";var o=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-o)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Android-Framework/" class="post-footer-category">#&nbsp;Android Framework</a> <a href="/tags/AOSP/" class="post-footer-tag">#&nbsp;AOSP</a></div><div class="nav"><div class="nav-item-prev"><a href="/2022/08/12/zygote/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">Java进程祖先-zygote服务</div></div></a></div><div class="nav-item-next"><a href="/2022/06/03/init/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Android Init进程</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#Logd" class="toc-link"><span class="toc-text">Logd</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E6%97%A5%E5%BF%97%E5%88%9D%E5%A7%8B%E5%8C%96" class="toc-link"><span class="toc-text">日志初始化</span></a></li><li class="toc-item toc-level-3"><a href="#%E5%88%9B%E5%BB%BA%E6%97%A5%E5%BF%97buffer" class="toc-link"><span class="toc-text">创建日志buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#SimpleLogBuffer" class="toc-link"><span class="toc-text">SimpleLogBuffer</span></a></li><li class="toc-item toc-level-4"><a href="#SerializedLogBuffer" class="toc-link"><span class="toc-text">SerializedLogBuffer</span></a></li><li class="toc-item toc-level-4"><a href="#ChattyLogBuffer" class="toc-link"><span class="toc-text">ChattyLogBuffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E5%90%AF%E7%94%A8socket" class="toc-link"><span class="toc-text">启用socket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#logdr" class="toc-link"><span class="toc-text">logdr</span></a></li><li class="toc-item toc-level-4"><a href="#logdw" class="toc-link"><span class="toc-text">logdw</span></a></li><li class="toc-item toc-level-4"><a href="#logd" class="toc-link"><span class="toc-text">logd</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E4%BD%BF%E7%94%A8" class="toc-link"><span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2022-10-02</div><a href="/2022/10/02/ams/"><div class="recent-posts-item-content">App管理服务-ActivityManagerService</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-09-21</div><a href="/2022/09/21/system_server/"><div class="recent-posts-item-content">Java服务总管-system_server进程</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-08-12</div><a href="/2022/08/12/zygote/"><div class="recent-posts-item-content">Java进程祖先-zygote服务</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-06-03</div><a href="/2022/06/03/init/"><div class="recent-posts-item-content">Android Init进程</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-05-13</div><a href="/2022/05/13/android-lint-language/"><div class="recent-posts-item-content">【翻译】Android Init Language</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2024-12-20</div><a href="/2024/12/20/flutter-getx-source/"><div class="recent-posts-item-content">GetX原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-11-15</div><a href="/2024/11/15/flutter-provider-source/"><div class="recent-posts-item-content">Provider原理分析</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-10-05</div><a href="/2024/10/05/flutter-provider/"><div class="recent-posts-item-content">Flutter状态管理框架Provider</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2024-09-10</div><a href="/2024/09/10/flutter-state/"><div class="recent-posts-item-content">Flutter状态管理</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>