<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1,minimum-scale=1" name="viewport"><meta content="ie=edge" http-equiv="X-UA-Compatible"><meta content="#fff" name="theme-color" id="theme-color"><meta content="Hexo" name="description"><link href="/img/website.svg" rel="icon"><title>Java服务总管-system_server进程</title><link href="/css/main.css" rel="preload" as="style"><link href="/css/main.css" rel="stylesheet"><link href="/css/libs/atom-one-light.min.css" rel="preload" as="style"><link href="/css/libs/atom-one-light.min.css" rel="stylesheet"><script>function loadScript(e,t){var n=document.createElement("script");n.src=e,t&&(n.onload=t),n.async=!0,document.body.appendChild(n)}function loadCSS(e){var t=document.createElement("link");t.ref="stylesheet",t.href=e,document.head.appendChild(t)}function changeCSS(e,t,n){var t=document.querySelector(t),c=document.createElement("link");c.setAttribute("rel","stylesheet"),c.setAttribute("href",e),c.dataset.prism=n,document.head.replaceChild(c,t)}</script><link href="/js/lib/lozad.min.js" rel="preload" as="script"><meta content="Hexo 7.3.0" name="generator"></head><body><div class="wrapper"><nav class="navbar"><div class="nav-container"><div class="navbar-menu"><a href="/" class="navbar-menu-item">首页 </a><a href="/archives" class="navbar-menu-item">归档 </a><a href="/tags" class="navbar-menu-item">标签 </a><a href="/categories" class="navbar-menu-item">分类</a></div></div></nav><div class="section-wrap"><div class="container"><div class="columns"><aside class="left-column"><div class="card card-author"><img alt="author avatar" class="author-img" src="/img/website.svg" height="88" width="88"><p class="author-name">pppeng</p><p class="author-description">一日不书 百事荒芜</p><div class="author-message"><a href="/archives" class="author-posts-count"><span>28</span> <span>文章</span> </a><a href="/categories" class="author-categories-count"><span>4</span> <span>分类</span> </a><a href="/tags" class="author-tags-count"><span>16</span> <span>标签</span> </a><a class="author-word-count"><span>11.5</span> <span>万字</span></a></div></div><div class="sticky-tablet"><article class="display-when-two-columns spacer"><div class="card card-content toc-card"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#system-server" class="toc-link"><span class="toc-text">system_server</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E6%B3%A8%E5%86%8Cdump" class="toc-link"><span class="toc-text">注册dump</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#SystemServiceManager" class="toc-link"><span class="toc-text">SystemServiceManager</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%89%B9%E9%87%8F%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" class="toc-link"><span class="toc-text">批量启动服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#bootstrap%E6%9C%8D%E5%8A%A1" class="toc-link"><span class="toc-text">bootstrap服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#WatchDog" class="toc-link"><span class="toc-text">WatchDog</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#%E6%A0%B8%E5%BF%83%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1" class="toc-link"><span class="toc-text">核心服务和其他服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></li></ol></div></article><article class="card card-content categories-widget"><div class="categories-card"><div class="categories-header">分类</div><div class="categories-list"><a href="/categories/Android-Framework/"><div class="categories-list-item">Android Framework <span class="categories-list-item-badge">12</span></div></a><a href="/categories/Android-View/"><div class="categories-list-item">Android View <span class="categories-list-item-badge">4</span></div></a><a href="/categories/Third-Libraries/"><div class="categories-list-item">Third Libraries <span class="categories-list-item-badge">6</span></div></a><a href="/categories/Kotlin/"><div class="categories-list-item">Kotlin <span class="categories-list-item-badge">6</span></div></a></div></div></article></div></aside><main class="main-column"><div class="image-wrapper"><img alt="Java服务总管-system_server进程 thumbnail" class="lozad image" src="/img/cover/cover-system-server.webp" data-src="</%= page.banner_img " srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></div><article class="card card-content article-content"><header><h1 class="post-title">Java服务总管-system_server进程</h1></header><div class="post-meta post-show-meta"><time datetime="2022-09-21T12:16:47.000Z"><i class="icon-calendar iconfont" style="margin-right:2px"></i> <span>2022-09-21</span> </time><span class="dot"></span> <a href="/categories/Android-Framework/" class="post-meta-link">Android Framework </a><span class="dot"></span> <span>约4.6k 字</span></div><div class="post-content" id="section"><p><code>system_server</code>进程管理着<code>Java</code>世界的服务，主要分为<code>boot</code>服务、核心服务以及其他服务。开机时由<code>init</code>进程拉起<code>zygote</code>，最终走到<code>java</code>世界的<code>zygote</code>。后续所有的<code>java</code>进程都是由<code>zygote</code>直接或间接孵化而出，而<code>system_server</code>就是<code>zygote</code>孵化出的第一个进程。这个流程可以查看前面的<a href="https://pgaofeng.github.io/2022/08/12/zygote/" rel="noopener" target="_blank">Java进程祖先-zygote服务</a>，后续其他服务就是由<code>system_server</code>启动的。</p><blockquote><p>源码基于Android 13</p></blockquote><h2 id="system-server"><a href="#system-server" class="headerlink" title="system_server"></a>system_server</h2><p>它是<code>zygote</code>孵化出的第一个进程，当<code>system_server</code>被<code>fork</code>出之后，<code>zygote</code>就不再直接<code>fork</code>其他进程了，而是进入循环阻塞状态，等待<code>socket</code>的消息来决定什么时候<code>fork</code>新进程。而<code>system_server</code>进程启动后，就走到其主函数中开始了它自己的流程。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/java/com/android/server/SystemServer.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dumpable</span> &#123;<br>    <span class="hljs-comment">// dump服务</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SystemServerDumper</span> <span class="hljs-variable">mDumper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServerDumper</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServer</span>().run();<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.traceBegin(<span class="hljs-string">&quot;InitBeforeStartServices&quot;</span>);<br>            ...<br>            <span class="hljs-comment">// 开启Looper机制</span><br>            Looper.prepareMainLooper();<br>            ...<br>            <span class="hljs-comment">// 初始化systemContext</span><br>            createSystemContext();<br>            ...<br>            <span class="hljs-comment">// 加入dumper服务，该服务用于adb shell dumpsys命令</span><br>            ServiceManager.addService(<span class="hljs-string">&quot;system_server_dumper&quot;</span>, mDumper);<br>            mDumper.addDumpable(<span class="hljs-built_in">this</span>);<br><br>            <span class="hljs-comment">// 系统服务管理者</span><br>            mSystemServiceManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServiceManager</span>(mSystemContext);<br>            mSystemServiceManager.setStartInfo(mRuntimeRestart,<br>                    mRuntimeStartElapsedTime, mRuntimeStartUptime);<br>            <span class="hljs-comment">// 加入到dumper中</span><br>            mDumper.addDumpable(mSystemServiceManager);<br>            <span class="hljs-comment">// 加入到本地service中</span><br>            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);<br>            <span class="hljs-comment">// 初始化线程池</span><br>            <span class="hljs-type">SystemServerInitThreadPool</span> <span class="hljs-variable">tp</span> <span class="hljs-operator">=</span> SystemServerInitThreadPool.start();<br>            mDumper.addDumpable(tp);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            t.traceEnd();  <span class="hljs-comment">// InitBeforeStartServices</span><br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 启动主要的一些服务</span><br>            startBootstrapServices(t);<br>            startCoreServices(t);<br>            startOtherServices(t);<br>            startApexServices(t);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            t.traceEnd(); <span class="hljs-comment">// StartServices</span><br>        &#125;<br>        ...<br>        <span class="hljs-comment">// 进入死循环等待，后续由handler机制唤醒执行操作</span><br>        Looper.loop();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个<code>system_server</code>进程也是通过<code>Looper</code>机制进入循环等待的，关于Looper的可以查看<a href="https://pgaofeng.github.io/2022/03/07/handler/" rel="noopener" target="_blank">Handler从Java到Native</a>。它在启动中做了很多的操作，其中几乎都是我们需要关注的，如创建上下文以及注册<code>dump</code>等，我们一点一点的查看。</p><h3 id="注册dump"><a href="#注册dump" class="headerlink" title="注册dump"></a>注册dump</h3><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/java/com/android/server/SystemServer.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dumpable</span> &#123;<br>    ...<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemServerDumper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Binder</span> &#123;<br><br>        <span class="hljs-comment">// 存放多Dumpable，这些是具体用来打印输入信息的</span><br>        <span class="hljs-meta">@GuardedBy(&quot;mDumpables&quot;)</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayMap&lt;String, Dumpable&gt; mDumpables = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;&gt;(<span class="hljs-number">4</span>);<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dump</span><span class="hljs-params">(FileDescriptor fd, PrintWriter pw, String[] args)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasArgs</span> <span class="hljs-operator">=</span> args != <span class="hljs-literal">null</span> &amp;&amp; args.length &gt; <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">synchronized</span> (mDumpables) &#123;<br>                <span class="hljs-comment">// adb shell dumpsys system_server_dumper --list</span><br>                <span class="hljs-comment">// 列出system_server_dumper的所有Dumpable</span><br>                <span class="hljs-keyword">if</span> (hasArgs &amp;&amp; <span class="hljs-string">&quot;--list&quot;</span>.equals(args[<span class="hljs-number">0</span>])) &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">dumpablesSize</span> <span class="hljs-operator">=</span> mDumpables.size();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dumpablesSize; i++) &#123;<br>                        pw.println(mDumpables.keyAt(i));<br>                    &#125;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// adb shell dumpsys system_server_dumper --name SystemServer</span><br>                <span class="hljs-comment">// --name后面跟具体的Dumpable</span><br>                <span class="hljs-keyword">if</span> (hasArgs &amp;&amp; <span class="hljs-string">&quot;--name&quot;</span>.equals(args[<span class="hljs-number">0</span>])) &#123;<br>                    <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">2</span>) &#123;<br>                        pw.println(<span class="hljs-string">&quot;Must pass at least one argument to --name&quot;</span>);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">Dumpable</span> <span class="hljs-variable">dumpable</span> <span class="hljs-operator">=</span> mDumpables.get(name);<br>                    <span class="hljs-keyword">if</span> (dumpable == <span class="hljs-literal">null</span>) &#123;<br>                        pw.printf(<span class="hljs-string">&quot;No dummpable named %s\n&quot;</span>, name);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><br>                    <span class="hljs-keyword">try</span> (<span class="hljs-type">IndentingPrintWriter</span> <span class="hljs-variable">ipw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndentingPrintWriter</span>(pw, <span class="hljs-string">&quot;  &quot;</span>)) &#123;<br>                        <span class="hljs-comment">// Strip --name DUMPABLE from args</span><br>                        <span class="hljs-keyword">final</span> String[] actualArgs = Arrays.copyOfRange(args, <span class="hljs-number">2</span>, args.length);<br>                        dumpable.dump(ipw, actualArgs);<br>                    &#125;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// adb shell dumpsys system_server_dumper</span><br>                <span class="hljs-comment">// 后后缀会dump出所有的信息</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">dumpablesSize</span> <span class="hljs-operator">=</span> mDumpables.size();<br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">IndentingPrintWriter</span> <span class="hljs-variable">ipw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndentingPrintWriter</span>(pw, <span class="hljs-string">&quot;  &quot;</span>)) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dumpablesSize; i++) &#123;<br>                        <span class="hljs-keyword">final</span> <span class="hljs-type">Dumpable</span> <span class="hljs-variable">dumpable</span> <span class="hljs-operator">=</span> mDumpables.valueAt(i);<br>                        ipw.printf(<span class="hljs-string">&quot;%s:\n&quot;</span>, dumpable.getDumpableName());<br>                        ipw.increaseIndent();<br>                        dumpable.dump(ipw, args);<br>                        ipw.decreaseIndent();<br>                        ipw.println();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加新的dumpable</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addDumpable</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Dumpable dumpable)</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (mDumpables) &#123;<br>                mDumpables.put(dumpable.getDumpableName(), dumpable);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>dump</code>服务是有多个的，用于我们的命令<code>adb shell dump</code>，后面跟的就是<code>dump</code>服务的名字，我们可以从<code>dump</code>服务中查询各种信息。如在<code>system_server</code>进程启动中，注册的就是名为<code>system_server_dumper</code>的一个服务，从类中可以看到它是<code>SystemServer</code>的内部类，但是它继承自<code>Binder</code>，也就是说它是一个<code>Binder</code>服务，是可以注册到<code>ServiceManager</code>中的。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/core/java/android/os/ServiceManager.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceManager</span> &#123;<br>    <span class="hljs-comment">// 包装了从native层的ServiceManager到Java层的过程，包括查询服务，注册服务等</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>ServiceManager</code>是封装了<code>native</code>层的<code>ServiceManager</code>，使得我们可以直接使用而不用关注<code>native</code>层是如何实现的。这里主要就是通过<code>ServiceManager</code>注册了<code>system_server_dumper</code>服务就结束了。</p><h4 id="SystemServiceManager"><a href="#SystemServiceManager" class="headerlink" title="SystemServiceManager"></a>SystemServiceManager</h4><p>在注册了<code>system_server_dumper</code>后，紧接着又创建了一个<code>SystemServiceManager</code>，并加入到了本地的服务中。注意这里只是加入到了本地的服务列表中，并没有通过<code>ServiceManager</code>去注册服务，因为它并不是<code>Binder</code>，因此也就无法注册。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemServiceManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dumpable</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// frameworks/base/core/java/com/android/server/LocalServices.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalServices</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LocalServices</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">// 存放本地服务，注意key是class</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ArrayMap&lt;Class&lt;?&gt;, Object&gt; sLocalServiceObjects =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;Class&lt;?&gt;, Object&gt;();<br><br>    <span class="hljs-comment">// 获取服务</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getService</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (sLocalServiceObjects) &#123;<br>            <span class="hljs-keyword">return</span> (T) sLocalServiceObjects.get(type);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加服务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">addService</span><span class="hljs-params">(Class&lt;T&gt; type, T service)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (sLocalServiceObjects) &#123;<br>            <span class="hljs-keyword">if</span> (sLocalServiceObjects.containsKey(type)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Overriding service registration&quot;</span>);<br>            &#125;<br>            sLocalServiceObjects.put(type, service);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 移除服务</span><br>    <span class="hljs-meta">@VisibleForTesting</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeServiceForTest</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (sLocalServiceObjects) &#123;<br>            sLocalServiceObjects.remove(type);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为不是远程的<code>Binder</code>服务，因此无法注册到<code>ServiceManager</code>中，所以这里注册到<code>LocalServices</code>中。这里的<code>LocalServices</code>维护了一个静态<code>map</code>用于存储本地服务，注意这里的**<code>SystemServiceManager</code><strong>服务的<code>key</code>是</strong><code>SystemServer.class</code>**。该服务的主要作用就是维护其他服务，以及启动其他服务等，这里后面我们再继续查看。</p><h3 id="批量启动服务"><a href="#批量启动服务" class="headerlink" title="批量启动服务"></a>批量启动服务</h3><p>最后也就是<code>system_server</code>的最主要的流程了，就是启动各种服务，注意这里的服务并不是Binder服务，而是Java层中定义的服务，它们并不能注册到<code>ServiceManager</code>中的。</p><h4 id="bootstrap服务"><a href="#bootstrap服务" class="headerlink" title="bootstrap服务"></a>bootstrap服务</h4><p>这里启动的是系统启动引导服务，是非常重要的一系列服务。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/java/com/android/server/SystemServer.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dumpable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startBootstrapServices</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;<br>        t.traceBegin(<span class="hljs-string">&quot;startBootstrapServices&quot;</span>);<br><br>        <span class="hljs-comment">// 看门狗服务，该服务用于保障其他服务的正常运行</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Watchdog</span> <span class="hljs-variable">watchdog</span> <span class="hljs-operator">=</span> Watchdog.getInstance();<br>        watchdog.start();<br>        ...<br>        <span class="hljs-type">ActivityTaskManagerService</span> <span class="hljs-variable">atm</span> <span class="hljs-operator">=</span> mSystemServiceManager.startService(<br>                ActivityTaskManagerService.Lifecycle.class).getService();<br>        mActivityManagerService = ActivityManagerService.Lifecycle.startService(<br>                mSystemServiceManager, atm);<br>        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);<br>        ...<br>        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);<br>        ...<br>        mActivityManagerService.initPowerManagement();<br>        ...<br>        IPackageManager iPackageManager;<br>        t.traceBegin(<span class="hljs-string">&quot;StartPackageManagerService&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Watchdog.getInstance().pauseWatchingCurrentThread(<span class="hljs-string">&quot;packagemanagermain&quot;</span>);<br>            Pair&lt;PackageManagerService, IPackageManager&gt; pmsPair = PackageManagerService.main(<br>                    mSystemContext, installer, domainVerificationService,<br>                    mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);<br>            mPackageManagerService = pmsPair.first;<br>            iPackageManager = pmsPair.second;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            Watchdog.getInstance().resumeWatchingCurrentThread(<span class="hljs-string">&quot;packagemanagermain&quot;</span>);<br>        &#125;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里启动和很多的服务，也有很多我们常见的一些服务，这里先不去关注这些服务具体做了什么，我们先看两点，一是如何启动的服务，另外就是看门狗是怎么保证这些服务的正常运行的。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemServiceManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dumpable</span> &#123;<br>    <span class="hljs-comment">// 启动服务</span><br>    <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SystemService</span>&gt; T <span class="hljs-title function_">startService</span><span class="hljs-params">(Class&lt;T&gt; serviceClass)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> serviceClass.getName();<br>            <span class="hljs-comment">// 反射调用构造方法获取service实例</span><br>            <span class="hljs-keyword">final</span> T service;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);<br>                service = constructor.newInstance(mContext);<br>            &#125;...<br><br>            startService(service);<br>            <span class="hljs-keyword">return</span> service;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startService</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> SystemService service)</span> &#123;<br>        <span class="hljs-comment">// 已经启动过了就不需要再启动一份了</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> service.getClass().getName();<br>        <span class="hljs-keyword">if</span> (mServiceClassnames.contains(className)) &#123;<br>            Slog.i(TAG, <span class="hljs-string">&quot;Not starting an already started service &quot;</span> + className);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将服务名字添加到集合中</span><br>        mServiceClassnames.add(className);<br>        <span class="hljs-comment">// 将服务添加到集合中</span><br>        mServices.add(service);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 执行onStart</span><br>            service.onStart();<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Failed to start service &quot;</span> + service.getClass().getName()<br>                    + <span class="hljs-string">&quot;: onStart threw an exception&quot;</span>, ex);<br>        &#125;<br>        warnIfTooLong(SystemClock.elapsedRealtime() - time, service, <span class="hljs-string">&quot;onStart&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这些服务都是继承自<code>SystemService</code>的，所以启动服务就是通过<code>class</code>反射调用构造方法，获取到实例，并加入到本地的一个集合中保存用于避免重复启动服务，而实际的启动服务就是执行其<code>onStart</code>方法而已，因此，对应的服务应该在<code>onStart</code>中处理自己的逻辑，完成服务的启动。</p><h5 id="WatchDog"><a href="#WatchDog" class="headerlink" title="WatchDog"></a>WatchDog</h5><p><code>WatchDog</code>看门狗是用于保障服务的正常运行的，它在启动<code>boot</code>服务的最开始就已经通过<code>start</code>启动了，它本身也可以算是一个独立运行的服务或线程，其他服务如果想要接入的话，则需要在其<code>onStart</code>中将其自身添加进来。如下面的下面我们用<code>PowerMS</code>作为示例查看下：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SystemService</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watchdog</span>.Monitor &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 注册了一个远程服务，一个本地服务</span><br>        publishBinderService(Context.POWER_SERVICE, mBinderService, <span class="hljs-comment">/* allowIsolated= */</span> <span class="hljs-literal">false</span>,<br>                DUMP_FLAG_PRIORITY_DEFAULT | DUMP_FLAG_PRIORITY_CRITICAL);<br>        publishLocalService(PowerManagerInternal.class, mLocalService);<br>        <span class="hljs-comment">// 将自己添加到看门狗中</span><br>        Watchdog.getInstance().addMonitor(<span class="hljs-built_in">this</span>);<br>        Watchdog.getInstance().addThread(mHandler);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// Watchdog.Monitor implementation</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Grab and release lock for watchdog monitor to detect deadlocks.</span><br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，在<code>PowerManagerService</code>中，继承自<code>WatchDog.Monitor</code>，然后在启动时先添加了<code>monitor</code>，再添加了一个线程，该线程就是<code>Handler</code>线程。我们一步一步往下看，先是添加<code>Monitor</code>：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/Watchdog.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watchdog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dumpable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HandlerChecker mMonitorChecker;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;HandlerCheckerAndTimeout&gt; mHandlerCheckers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Watchdog</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 启动线程，当WatchDog启动时实际就是启动该线程</span><br>        mThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>::run, <span class="hljs-string">&quot;watchdog&quot;</span>);<br>        <span class="hljs-comment">// 前台线程</span><br>        mMonitorChecker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(FgThread.getHandler(),<span class="hljs-string">&quot;foreground thread&quot;</span>);<br>        mHandlerCheckers.add(withDefaultTimeout(mMonitorChecker));<br>    	...<br>    &#125;<br>    <br>    <span class="hljs-comment">// 添加到前台检测中，这里是PowerMS的主线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMonitor</span><span class="hljs-params">(Monitor monitor)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            mMonitorChecker.addMonitorLocked(monitor);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 添加到检测集合中，这里是PowerMS的Handler线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addThread</span><span class="hljs-params">(Handler thread)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> thread.getLooper().getThread().getName();<br>            mHandlerCheckers.add(withDefaultTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(thread, name)));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里可以看出，在<code>WatchDog</code>中有一个集合常量，里面存储的全都是需要检测的线程，然后在构造方法中会提前创建一个检测线程即前台线程，当<code>addMonitor</code>实际就是添加到前台线程检测中，而<code>addThread</code>则是添加到检测集合中，与前台线程是同一级别的。看下<code>Ha</code>的结构：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/Watchdog.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watchdog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dumpable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChecker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-comment">// 待检测的线程    </span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Handler mHandler;<br>        <span class="hljs-comment">// 线程的名字</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String mName;<br>        <span class="hljs-comment">// 检测开始时，会将待检测的Monitor添加到这里面进行检测，避免</span><br>        <span class="hljs-comment">// 检测时再添加Monitor导致多线程的异常</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;Monitor&gt; mMonitors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Monitor&gt;();<br>        <span class="hljs-comment">// 待检测的Monitor</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;Monitor&gt; mMonitorQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Monitor&gt;();<br>        <span class="hljs-comment">// 最大等待时长</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> mWaitMax;<br>        <span class="hljs-comment">// 是否检测完毕</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> mCompleted;<br>        <span class="hljs-keyword">private</span> Monitor mCurrentMonitor;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> mStartTime;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> mPauseCount;<br><br>        HandlerChecker(Handler handler, String name) &#123;<br>            mHandler = handler;<br>            mName = name;<br>            mCompleted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>HandlerChecker</code>是<code>WatchDog</code>的一个内部类，其内也有一个集合用于存放各种<code>Monitor</code>，实际上检测就是去执行各个<code>HandlerChecker</code>中的<code>Monitor</code>集合。至于我们通过<code>addThread</code>添加进来的会被包装成<code>HandlerCheckerAndTimeout</code>实际就是多了一个自定义的超时时间而已。</p><p><img alt="HandlerChecker" class="lozad post-image" src="/img/watchdog-checker.webp" data-src="/img/watchdog-checker.webp" srcset="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nMjQwJz48cmVjdCB4PScwJyB5PScwJyB3aWR0aD0nODAwJyBoZWlnaHQ9JzI0MCcgZmlsbD0nI2ZhZmFmYScvPjx0ZXh0IHg9JzUwJScgeT0nNTAlJyBzdHlsZT0nZG9taW5hbnQtYmFzZWxpbmU6bWlkZGxlO3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6NTNweCcgZmlsbD0nI2I3YjdiNyc+5Zu+54mH5Yqg6L295LitPC90ZXh0Pjwvc3ZnPg=="></p><p>接下来就是<code>WatchDog</code>的启动了，注意这里的启动是在服务启动之前就已经启动了的，然后服务启动时会将自身添加到<code>WatchDog</code>中：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/Watchdog.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watchdog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dumpable</span> &#123;<br>    <span class="hljs-comment">// 超时时间，debug模式下是10秒，否则是60秒</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">DEFAULT_TIMEOUT</span> <span class="hljs-operator">=</span> DB ? <span class="hljs-number">10</span> * <span class="hljs-number">1000</span> : <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br>    ...<br>    <br>    <span class="hljs-comment">// 开启看门狗后线程执行的方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">waitedHalf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            List&lt;HandlerChecker&gt; blockedCheckers = Collections.emptyList();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">allowRestart</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">debuggerWasConnected</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">doWaitedHalfDump</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 超时时间以及检测间隔</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">watchdogTimeoutMillis</span> <span class="hljs-operator">=</span> mWatchdogTimeoutMillis;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">checkIntervalMillis</span> <span class="hljs-operator">=</span> watchdogTimeoutMillis / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">final</span> ArrayList&lt;Integer&gt; pids;<br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                <span class="hljs-comment">// 30秒</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> checkIntervalMillis;<br>                <span class="hljs-comment">// 遍历所有的Checkers，包括前台线程以及通过addThread添加的Handler线程</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;<br>                    <span class="hljs-type">HandlerCheckerAndTimeout</span> <span class="hljs-variable">hc</span> <span class="hljs-operator">=</span> mHandlerCheckers.get(i);<br>                    <span class="hljs-comment">// 执行方法，参数时长还是60秒</span><br>                    hc.checker().scheduleCheckLocked(hc.customTimeoutMillis()<br>                            .orElse(watchdogTimeoutMillis * Build.HW_TIMEOUT_MULTIPLIER));<br>                &#125;<br>                ...<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码可以看出，<code>WatchDog</code>在运行时会遍历所有的<code>Checker</code>，然后执行其<code>scheduleCheckLocked</code>方法，然后再通过<code>wait</code>方法等待，我们先看下<code>Checker</code>做了什么：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/Watchdog.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watchdog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dumpable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChecker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleCheckLocked</span><span class="hljs-params">(<span class="hljs-type">long</span> handlerCheckerTimeoutMillis)</span> &#123;<br>            <span class="hljs-comment">// 最大等待时长60秒</span><br>            mWaitMax = handlerCheckerTimeoutMillis;<br>            <span class="hljs-comment">// 当前状态是已完成状态，说明是重新开始的，这里将monitor加入到待执行的集合中</span><br>            <span class="hljs-keyword">if</span> (mCompleted) &#123;<br>                mMonitors.addAll(mMonitorQueue);<br>                mMonitorQueue.clear();<br>            &#125;<br>            <span class="hljs-comment">// 待检测的monitor为空并且handler处于空闲状态，或者当前Checker的检测被暂停了</span><br>            <span class="hljs-comment">// 就直接返回并结束</span><br>            <span class="hljs-keyword">if</span> ((mMonitors.size() == <span class="hljs-number">0</span> &amp;&amp; mHandler.getLooper().getQueue().isPolling())<br>                    || (mPauseCount &gt; <span class="hljs-number">0</span>)) &#123;<br>                mCompleted = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 此时已经在执行中了，不需要再次执行</span><br>            <span class="hljs-keyword">if</span> (!mCompleted) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 标记当前状态</span><br>            mCompleted = <span class="hljs-literal">false</span>;<br>            mCurrentMonitor = <span class="hljs-literal">null</span>;<br>            mStartTime = SystemClock.uptimeMillis();<br>            <span class="hljs-comment">// 开始执行检测</span><br>            mHandler.postAtFrontOfQueue(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// Checker实际执行的逻辑</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 遍历自身的Monitor集合，执行其monitor方法</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mMonitors.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size ; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                    mCurrentMonitor = mMonitors.get(i);<br>                &#125;<br>                mCurrentMonitor.monitor();<br>            &#125;<br>            <span class="hljs-comment">// 全部执行完就返回了</span><br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                mCompleted = <span class="hljs-literal">true</span>;<br>                mCurrentMonitor = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使<code>Checker</code>开始执行，最后实际是往其对应的<code>Handler</code>中发送消息，在其<code>Handler</code>的线程中执行它里面的<code>Monitor</code>。而在<code>PowerMS</code>中，它的<code>monitor()</code>方法什么都没做，只是获取锁再释放锁而已。其实默认情况下很多的服务的检测方法都是仅仅获取并是否锁来判断前台线程是否发生死锁的。</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SystemService</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watchdog</span>.Monitor &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// Watchdog.Monitor implementation</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 当前台线程发生死锁时，这里获取不到锁会一直卡在这里</span><br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们自己的服务，就可以在<code>monitor</code>中做一些自己的检测逻辑。继续回到<code>WatchDog</code>的<code>run</code>中往下看：</p><figure class="java highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="java hljs"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/Watchdog.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watchdog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dumpable</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evaluateCheckerCompletionLocked</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> COMPLETED;<br>        <span class="hljs-comment">// 遍历所有的Checker，找出等待状态</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;<br>            <span class="hljs-type">HandlerChecker</span> <span class="hljs-variable">hc</span> <span class="hljs-operator">=</span> mHandlerCheckers.get(i).checker();<br>            state = Math.max(state, hc.getCompletionStateLocked());<br>        &#125;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">waitedHalf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            ...<br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                <span class="hljs-comment">// 前半部分的逻辑就是调用所有的Checker，然后执行其内部的Monitor</span><br>                <span class="hljs-comment">// 这些monitor默认的实现大部分都是获取锁再释放锁</span><br>                ...<br>                <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>                <span class="hljs-keyword">while</span> (timeout &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 等待30秒并释放掉锁，这样monitor才能执行</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        mLock.wait(timeout);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Log.wtf(TAG, e);<br>                    &#125;<br>                    <span class="hljs-comment">// 计算等待时间是否是30秒，如果不是30秒说明当前线程被异常中断唤醒了</span><br>                    <span class="hljs-comment">// 因此需要继续等待</span><br>                    timeout = checkIntervalMillis - (SystemClock.uptimeMillis() - start);<br>                &#125;<br>                <span class="hljs-comment">// 30秒后开始计算当前的等待状态</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">waitState</span> <span class="hljs-operator">=</span> evaluateCheckerCompletionLocked();<br>                <span class="hljs-keyword">if</span> (waitState == COMPLETED) &#123;<br>                    <span class="hljs-comment">// 所有的Checker都是正常完成了的，标记状态后再次进入检测</span><br>                    waitedHalf = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITING) &#123;<br>                    <span class="hljs-comment">// 还有任务未完成，并且等待时间未超过一半的超时时间，再次进入检测</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITED_HALF) &#123;<br>                    <span class="hljs-comment">// 还有任务未完成，并且此时时间已经超过一半的超时时间了</span><br>                    <span class="hljs-keyword">if</span> (!waitedHalf) &#123;<br>                        <span class="hljs-comment">// 标记已经等了一半的时间了</span><br>                        waitedHalf = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-comment">// 获取超过一半时间的Checker</span><br>                        blockedCheckers = getCheckersWithStateLocked(WAITED_HALF);<br>                        <span class="hljs-comment">// 记录这些Checker的信息，后面会打印出来</span><br>                        subject = describeCheckersLocked(blockedCheckers);<br>                        pids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(mInterestingJavaPids);<br>                        doWaitedHalfDump = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 已经标记过等了一半时间了，继续循环执行等待</span><br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 有Checker超时了，获取到这些Checker并记录信息，后面打印</span><br>                    blockedCheckers = getCheckersWithStateLocked(OVERDUE);<br>                    subject = describeCheckersLocked(blockedCheckers);<br>                    <span class="hljs-comment">// 标记为true，后续会重启</span><br>                    allowRestart = mAllowRestart;<br>                    pids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(mInterestingJavaPids);<br>                &#125;<br>            &#125;<span class="hljs-comment">// END synchronized (mLock)</span><br>            <br>            <span class="hljs-comment">// 打印日志，这里会打印超过一半超时时间的Checker信息，以及完全超时的Checker信息</span><br>            logWatchog(doWaitedHalfDump, subject, pids);<br>            <span class="hljs-comment">// 如果打印的是超过一半超时时间的信息，则继续循环等待</span><br>            <span class="hljs-keyword">if</span> (doWaitedHalfDump) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            IActivityController controller;<br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                controller = mController;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (controller != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Binder.setDumpDisabled(<span class="hljs-string">&quot;Service dumps disabled due to hung system process.&quot;</span>);<br>                    <span class="hljs-comment">// 由IActivityController来检测下是否需要重启系统</span><br>                    <span class="hljs-comment">// 1:继续等待，-1：杀死进程</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> controller.systemNotResponding(subject);<br>                    <span class="hljs-keyword">if</span> (res &gt;= <span class="hljs-number">0</span>) &#123;<br>                        Slog.i(TAG, <span class="hljs-string">&quot;Activity controller requested to coninue to wait&quot;</span>);<br>                        waitedHalf = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (Debug.isDebuggerConnected()) &#123;<br>                debuggerWasConnected = <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (debuggerWasConnected &gt;= <span class="hljs-number">2</span>) &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;Debugger connected: Watchdog is *not* killing the system process&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (debuggerWasConnected &gt; <span class="hljs-number">0</span>) &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;Debugger was connected: Watchdog is *not* killing the system process&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!allowRestart) &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;Restart not allowed: Watchdog is *not* killing the system process&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;*** WATCHDOG KILLING SYSTEM PROCESS: &quot;</span> + subject);<br>                WatchdogDiagnostics.diagnoseCheckers(blockedCheckers);<br>                Slog.w(TAG, <span class="hljs-string">&quot;*** GOODBYE!&quot;</span>);<br>                <span class="hljs-keyword">if</span> (!Build.IS_USER &amp;&amp; isCrashLoopFound()<br>                        &amp;&amp; !WatchdogProperties.should_ignore_fatal_count().orElse(<span class="hljs-literal">false</span>)) &#123;<br>                    breakCrashLoop();<br>                &#125;<br>                <span class="hljs-comment">// 杀死system_server进程手机</span><br>                Process.killProcess(Process.myPid());<br>                System.exit(<span class="hljs-number">10</span>);<br>            &#125;<br>            waitedHalf = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>WatchDog</code>设置超时时长为60秒，系统或卡顿，或阻塞，或死锁等超过了60秒(<code>debug</code>下是10秒)就会直接杀死<code>system_server</code>进程重启手机。整体流程：<code>WatchDog</code>触发添加到它内部的所有的<code>Checker</code>执行，而<code>Checker</code>又会向它内部的<code>Handler</code>发消息以执行它内部的<code>Monitor</code>集合，然后<code>WatchDog</code>等待30秒，查看是否有<code>Checker</code>未完成，如果已完成则再次循环触发检测，如果未完成并且阻塞了也未超过30秒则再次循环继续等待，如果未完成超过了30秒，则打印这些<code>Checker</code>的信息，如果未完成并且超过了60秒，则杀死进程并重启手机。</p><p><code>WatchDog</code>检测的是添加的<code>Handler</code>线程是否阻塞，以及<code>system_server</code>的<code>Handler</code>线程以及运行在其线程上的对应的服务是否阻塞。</p><h4 id="核心服务和其他服务"><a href="#核心服务和其他服务" class="headerlink" title="核心服务和其他服务"></a>核心服务和其他服务</h4><p>核心服务与<code>bootstrap</code>服务的逻辑差不多，都是通过<code>SystemServiceManager</code>启动的，区别就是核心服务不会加入到<code>WatchDog</code>中。其他服务<code>startOtherServices</code>中启动的是更低一级的服务，它更不会加入到<code>WatchDog</code>中了，如我们非常熟悉的<code>WindowManagerService</code>就属于其他服务，正常如果我们自定义服务的话，都可以加在其他服务中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里我们基本上看完了<code>system_server</code>进程，它作为<code>zygote</code>的第一个<code>java</code>进程，主要作用就是启动各种服务进程。它首先是注册了<code>dump</code>服务用于命令行进行调试，然后通过<code>SystemServiceManager</code>启动各种我们常见的服务，按照服务的重要性分类，其中<code>bootstrap</code>类型的服务最为重要，在这些服务上使用了<code>WatchDog</code>进行监测，一旦这些服务或者<code>system_server</code>卡死，就会直接杀死进程。所以，我们熟悉的<code>AMS</code>、<code>PMS</code>都是运行在<code>system_server</code>进程的。</p></div></article><div><div class="copyright note-warning post-note"><p></p><div class="post-data">本文发布于<span id="post-time"></span>天前，最后更新于<span id="update-time"></span>天前，内容可能会与最新版本有所差异。</div><script>document.addEventListener("DOMContentLoaded",function(){var e=new Date,t=new Date("Wed Sep 21 2022 20:16:47 GMT+0800");let n="Wed Sep 21 2022 20:16:47 GMT+0800";n="2025-01-09 22:19:32 +0800";var d=new Date(n),t=Math.floor((e-t)/864e5),e=Math.floor((e-d)/864e5);document.getElementById("post-time").innerText=t,document.getElementById("update-time").innerText=e})</script><p></p></div></div><div class="post-footer"><a href="/categories/Android-Framework/" class="post-footer-category">#&nbsp;Android Framework</a> <a href="/tags/AOSP/" class="post-footer-tag">#&nbsp;AOSP</a></div><div class="nav"><div class="nav-item-prev"><a href="/2022/10/02/ams/" class="nav-link"><div><div class="nav-label">上一篇</div><div class="nav-title">App管理服务-ActivityManagerService</div></div></a></div><div class="nav-item-next"><a href="/2022/08/12/zygote/" class="nav-link"><div><div class="nav-label">下一篇</div><div class="nav-title">Java进程祖先-zygote服务</div></div></a></div></div><div class="card card-content toc-card" id="mobiletoc"><div class="toc-header">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a href="#system-server" class="toc-link"><span class="toc-text">system_server</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a href="#%E6%B3%A8%E5%86%8Cdump" class="toc-link"><span class="toc-text">注册dump</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#SystemServiceManager" class="toc-link"><span class="toc-text">SystemServiceManager</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%89%B9%E9%87%8F%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" class="toc-link"><span class="toc-text">批量启动服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a href="#bootstrap%E6%9C%8D%E5%8A%A1" class="toc-link"><span class="toc-text">bootstrap服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a href="#WatchDog" class="toc-link"><span class="toc-text">WatchDog</span></a></li></ol></li><li class="toc-item toc-level-4"><a href="#%E6%A0%B8%E5%BF%83%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1" class="toc-link"><span class="toc-text">核心服务和其他服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a href="#%E6%80%BB%E7%BB%93" class="toc-link"><span class="toc-text">总结</span></a></li></ol></li></ol></div></main><aside class="right-column"><div class="sticky-widescreen"><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">相关文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2022-10-02</div><a href="/2022/10/02/ams/"><div class="recent-posts-item-content">App管理服务-ActivityManagerService</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-08-12</div><a href="/2022/08/12/zygote/"><div class="recent-posts-item-content">Java进程祖先-zygote服务</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-07-25</div><a href="/2022/07/25/logd/"><div class="recent-posts-item-content">Android logd日志服务</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-06-03</div><a href="/2022/06/03/init/"><div class="recent-posts-item-content">Android Init进程</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2022-05-13</div><a href="/2022/05/13/android-lint-language/"><div class="recent-posts-item-content">【翻译】Android Init Language</div></a></div></div></div></article><article class="card card-content"><div class="recent-posts-card"><div class="recent-posts-header">最近文章</div><div class="recent-posts-list"><div class="recent-posts-item"><div class="recent-posts-item-title">2023-08-27</div><a href="/2023/08/27/overscroll/"><div class="recent-posts-item-content">View自定义回弹动效</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-07-11</div><a href="/2023/07/11/coroutine-2/"><div class="recent-posts-item-content">Kotlin协程的实现</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-06-05</div><a href="/2023/06/05/flow-2/"><div class="recent-posts-item-content">SharedFlow、StateFlow、SafeFlow的区别</div></a></div><div class="recent-posts-item recent-posts-item-other"><div class="recent-posts-item-title">2023-05-22</div><a href="/2023/05/22/flow/"><div class="recent-posts-item-content">协程数据流Flow</div></a></div></div></div></article></div></aside></div></div></div></div><script>let initCount=0;function initClipboard(){++initCount<2||new ClipboardJS(".btn-copy").on("success",function(n){n.clearSelection(),n.trigger.innerHTML=icon_yes,setTimeout(()=>{n.trigger.innerHTML=icon_copy},1e3)})}var addLazyload=function(){lozad(".lozad",{load:function(n){n.srcset=n.getAttribute("data-src")},loaded:function(n){n.classList.add("loaded")}}).observe()}</script><script>loadScript("/js/lib/lozad.min.js",addLazyload)</script><script>loadScript("/js/lib/toc-highlight-scroll.min.js",()=>{tocSetup(),addCopyButton(),initClipboard()})</script><script>loadScript("/js/lib/clipboard.min.js",()=>initClipboard())</script></body></html>